//@version=5

strategy('TTB 7.6', overlay=true, initial_capital=1000000, default_qty_type=strategy.cash, default_qty_value=100000, currency=currency.USD, pyramiding=999, calc_on_every_tick=false, max_bars_back=5000)

import thetradingbot/TTB_TableBuilder/1 as TTBTableBuilder

//main colors
color bullish = #00a2ff
color bullish2 = #00a2ff7a
color bullish3 = #00a2ff1f
color bearish = #C70A80ff
color bearish2 = color.rgb(199, 10, 126, 54)
color bearish3 = color.rgb(199, 10, 126, 88)

// f_security function for MTF
f_security(_sym, _res, _src, _rep) =>
    request.security(_sym, _res, _src[not _rep and barstate.isrealtime ? 1 : 0])[_rep or barstate.isrealtime ? 0 : 1]
var bool i_repaint = false // Set to false to avoid repainting
var string ticker = syminfo.tickerid

round_to(n, decimals) =>
    mult = 1.0
    for i = 1 to decimals
        mult := mult * 10
    round_n = na(n * mult + 0.5) ? na : (n * mult + 0.5) - (n * mult + 0.5) % 1
    round_n / mult

show_table = input(true, title='Show table')
direction = input.string(defval='Long', title='Trading Direction', options=['All', 'Long', 'Short'])
// Date Ranges
start = input.time(timestamp("1 Feb 2021 12:00"), title="Start")
finish = input.time(timestamp("1 Feb 2025 12:00"), title="End")
window = time >= start and time <= finish ? true : false  
source_type = 'Close'

truncate(number, decimals) =>
    factor = math.pow(10, decimals)
    int(number * factor) / factor

var long = false
var short = true

if direction == 'All'
    long := true
    short := true
    short
else if direction == 'Long'
    long := true
    short := false
    short
else if direction == 'Short'
    long := false
    short := true
    short

// Strategy Inputs
ID = 6700960415957
version = input(defval='7-6', title='version')
test = input(defval='1', title='test')
barsToWait = input(500, title="Bars Wait to Start")
direction_text = direction == 'Long' ? 'L' : 'S'
long_trigger = input(title='Long trigger value', defval=1)
short_trigger = input(title='Short trigger value', defval=-1)
trigger = input(title='Enter trigger', defval=close)
MinSOBars = input(100, title="Min Bars Between SOs")
ATRP_daily_factor = input.float(0.11, title='TP Factor: D atrp', step=0.01)
atrp_SO_deviation = input.float(0.005, title='ATRP SO Deviation', step=0.001, minval=0.001)
base_order_lots = input.float(0.4, title='Base Order Size (Lots)', step=0.01)
safe_order_lots = input.float(0.4, title='Safe Order Size (Lots)', step=0.01)
safe_order_volume_scale = input.float(1.1, step=0.1, title='Safety order volume scale')
safe_order_step_scale = input.float(1.6, step=0.1, title='Safety order step scale')
max_safe_order = input(6, title='max no. of safe orders')
base_S_order_lots = input.float(0.4, title='Base Sell Order Size (Lots)', step=0.01)
safe_S_order_lots = input.float(0.4, title='Safe Sell Order Size (Lots)', step=0.01)
safe_S_order_volume_scale = input.float(1.1, step=0.1, title='Safety sell order volume scale')
safe_S_order_step_scale = input.float(1.6, step=0.1, title='Safety sell order step scale')
max_S_safe_order = input(6, title='max no. of sell safe orders')
webhookMessage = input.string("pineconnector", "Choose message version", options=["fdas", "pineconnector"])

// ATRP
// ATRP, like the ATR indicator, measures volatility. However, unlike ATR which provides absolute values, ATRP presents volatility as a percentage. This allows for comparison of securities with different share prices, as it normalizes volatility irrespective of the stock price level.
atr_length = 100
atrp_length = 14
atrp_length_d = 2
atrp_length_deviation = 7
ATRP_deviation_factor = 1

// Declare variables
var trp = 0.0
var atrps = 0.0
var float atrp_daily = na

//True Range Percentage Calculation
trp := ta.tr / hl2 * 100

atr_value = ta.atr(atr_length)
atrp = (atr_value / close) * 100
// Smoothed true range percentage calculation
atrps := ta.sma(trp, atrp_length)

// Daily ATRP calculation
atrp_daily_temp = round_to(f_security(ticker, "D", atrps, i_repaint), 4)
// Get and store yesterday's ATRP value
atrp_daily_yesterday = atrp_daily_temp[1]

if not barstate.isfirst
    atrp_daily := atrp_daily_yesterday
//define ATRP Target to be used in Take Profit Calculations
atrp_target = atrp_daily * ATRP_daily_factor

atrp_deviation_temp = round_to(f_security(ticker, "D", ta.sma(trp, atrp_length_deviation), i_repaint), 4)
atrp_deviation = atrp_deviation_temp * ATRP_deviation_factor

take_profit = atrp_target/ 100
take_S_profit = atrp_target / 100
//end atrp


var current_so = 0
var current_S_so = 0
var initial_order = 0.0
var initial_S_order = 0.0
var original_ttp_value = 0.0
var quantity = 0.0
var entry_price = 0.0
var firstBarTime = 0.0
var maxDiffDays = 0.0
var soCount = 0
var SO1 = 0
var SO2 = 0
var SO3 = 0
var SO4 = 0
var SO5 = 0
var SO6 = 0
var SO7 = 0
var noSO = 0
var initial_price = 0.0
var initial_S_price = 0.0
var price_drop = 0.0
var price_pump = 0.0
var max_drop = 0.0
var max_pump = 0.0
var pump_date = 0
var pump_month = 0
var drop_date = 0
var drop_month = 0
var longest_trade_day = 0
var longest_trade_month = 0
var take_profit_level = 0.0
var take_S_profit_level = 0.0
var tp_plot = 0.0
var tp_S_plot = 0.0
var threshold = 0.0
var S_threshold = 0.0
timeDiff = time - firstBarTime
maxDev = 0.0
maxSDev = 0.0
closedTrades = 0
var tradeCount = 0
var i = 0
var avg_price = 0.0
var total_funds_in_trade = 0.0
var total_qty_in_trade = 0.0
var capital = 1000000.0
var initial_capital = 1000000.0

var int long_sequence_counter = 0
var int short_sequence_counter = 0

var max_drop_atrp = 0.0
var max_pump_atrp = 0.0

var int last_so_bar = na

// Turn that time difference into days
diffDays = timeDiff / 86400000

// Calculate our TP levels
take_profit_level := avg_price * (1 + take_profit)
take_S_profit_level := avg_price * (1 - take_S_profit)

var float last_so_exec_price = na // Initialize with 'na' or the initial order price
var float maxDevATRP = na // Initialize with 'na' to indicate it's not yet calculated

// NO trade time
no_trade_time = (hour(time) == 0 and minute(time) < 59)

// calculate the first SO deviation
atrp_price_deviation = atrp_daily * atrp_SO_deviation / max_safe_order
atrp_price_S_deviation = atrp_daily * atrp_SO_deviation / max_S_safe_order

// // First Position price % based
// for i = 0 to max_safe_order - 1 by 1
//     maxDev := int((maxDev + price_deviation * 100 * math.pow(safe_order_step_scale, i)) * 100) / 100
//     maxDev
// for i = 0 to max_S_safe_order - 1 by 1
//     maxSDev := int((maxSDev + price_S_deviation * 100 * math.pow(safe_S_order_step_scale, i)) * 100) / 100
//     maxSDev

//var float maxSDevATRP = 0.0

// // maxDev Calculation to find Max SO deviation (ATRP based) 
// for i = 0 to max_safe_order - 1 by 1
//     maxDev := int((maxDev + atrp_price_deviation * 100 * math.pow(safe_order_step_scale, i)) * 100) / 100
//     maxDev
// for i = 0 to max_S_safe_order - 1 by 1
//     maxSDev := int((maxSDev + atrp_price_S_deviation * 100 * math.pow(safe_S_order_step_scale, i)) * 100) / 100
//     maxSDev

// Calculate maxDevATRP within the correct scope
if barstate.isnew
    maxDevATRP := 0.0 // Reset maxDevATRP for the new bar calculation
    for i = 1 to max_safe_order
        so_distance = atrp_price_deviation * math.pow(safe_order_step_scale, i - 1)
        maxDevATRP := math.max(maxDevATRP, so_distance / atrp_daily)
    for i = 1 to max_S_safe_order
        soS_distance = atrp_price_S_deviation * math.pow(safe_S_order_step_scale, i - 1)
        maxDevATRP := math.max(maxDevATRP, soS_distance / atrp_daily)
    maxDevATRP := round_to(maxDevATRP, 3) // Round maxDevATRP to 3 decimal places



if math.abs(strategy.position_size) != 0 and current_so[1] == 0
    strategy.close_all()


// long entry
if long
    if bar_index > barsToWait and strategy.position_size == 0 and close > 0 and window and not no_trade_time and trigger == long_trigger
    long_sequence_counter := long_sequence_counter + 1
    longId = "Long" + str.tostring(long_sequence_counter)
    _string_long = ""
    if webhookMessage == "fdas"
        _string_long := 'type=order,order-type=long,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + direction_text + '",entry=true'
    else if webhookMessage == "pineconnector"
        _string_long := str.tostring(ID) + ',long,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.order(longId, strategy.long, qty=(base_order_lots * 100000), comment="#" + str.tostring(long_sequence_counter) + "L E " + str.tostring(close), alert_message=_string_long)
    initial_order := close
    current_so := 1
    initial_price := close
    price_drop := close
    original_ttp_value := 0
    firstBarTime := time
    tradeCount += 1
    avg_price := close
    total_funds_in_trade := avg_price * base_order_lots * 100000
    total_qty_in_trade := base_order_lots * 100000
    last_so_bar := na
    //initial_atrp = atrps(close, atrp_length)
    total_qty_in_trade
    log.info("#{0} - LE - SO#{1}  - Avg price: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Strategy position size: {5}, Take Profit Level {6}", long_sequence_counter, (current_so - 1), avg_price, total_funds_in_trade, total_qty_in_trade, strategy.position_size, take_profit_level)

// short entry
else if short
    if bar_index > barsToWait and strategy.position_size == 0 and close > 0 and window and not no_trade_time and trigger == short_trigger
    short_sequence_counter := short_sequence_counter + 1
    shortId = "Short" + str.tostring(short_sequence_counter)
    _string_short = ""
    if webhookMessage == "fdas"
        _string_short := 'type=order,order-type=short,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + direction_text + '",entry=true'
    else if webhookMessage == "pineconnector"
        _string_short := str.tostring(ID) + ',short,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.order(shortId, strategy.short, qty=(base_order_lots * 100000), comment="#" + str.tostring(short_sequence_counter) + "S E " + str.tostring(close), alert_message=_string_short)
    initial_S_order := close
    current_so := 1
    firstBarTime := time
    tradeCount += 1
    initial_S_price := close
    price_pump := close
    avg_price := close
    total_funds_in_trade := avg_price * base_S_order_lots *100000
    total_qty_in_trade := base_S_order_lots * 100000
    last_so_bar := na
    //initial_S_atrp = atrps(close, atrp_length)
    total_qty_in_trade
    log.info("#{0} - SE - SO#{1} - Avg price: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Strategy position size: {5}, Take Profit Level: {6}, atrp_price_deviation: {7}, safe_order_step_scale: {8}, maxDevATRP: {9}", long_sequence_counter, (current_so - 1), avg_price, total_funds_in_trade, total_qty_in_trade, strategy.position_size, take_S_profit_level, atrp_price_deviation, safe_order_step_scale, maxDevATRP)
longId = "Long" + str.tostring(long_sequence_counter)
shortId = "Short" + str.tostring(short_sequence_counter)


//makes the red and green line plot pretty at the position opening
if strategy.position_size == 0
    threshold := low[1]
    S_threshold := high[1]
    S_threshold

// Safety order (SO) levels calculation
// Update best_tp_deviation for long positions within target_bars
if strategy.position_size > 0
    if i == 0 and bar_index - entry_bar_index <= target_bars
        high_since_entry = highest(high, bar_index - entry_bar_index + 1)
        best_tp_deviation := math.max(nz(best_tp_deviation, 0), (high_since_entry - entry_price) / atrp_daily)
    // Long position logic
    atrp_price_deviation = atrp_daily * atrp_SO_deviation / max_safe_order

    if current_so > 0
        // Calculate the distance for the current SO
        so_distance = atrp_price_deviation * math.pow(safe_order_step_scale, current_so - 1)
        // Set the threshold based on the last SO's execution price and the calculated distance
        threshold := nz(last_so_exec_price, initial_order) - so_distance
    else
        // First SO calculation
        threshold := initial_order - atrp_price_deviation

else // Update best_tp_deviation for short positions within target_bars
if strategy.position_size < 0 and i == 0 and bar_index - entry_bar_index <= target_bars
   low_since_entry = lowest(low, bar_index - entry_bar_index + 1)
   best_tp_deviation := math.min(nz(best_tp_deviation, 0), (entry_price - low_since_entry) / atrp_daily)
    // Short position logic
    atrp_price_S_deviation = atrp_daily * atrp_SO_deviation / max_S_safe_order

    if current_so > 0
        // Calculate the distance for the current SO
        so_distance = atrp_price_S_deviation * math.pow(safe_S_order_step_scale, current_so - 1)
        // Set the threshold based on the last SO's execution price and the calculated distance
        S_threshold := nz(last_so_exec_price, initial_S_order) + so_distance
    else
        // First SO calculation
        S_threshold := initial_S_order + atrp_price_S_deviation

plot(threshold, color=color.rgb(255, 82, 82, 94), title="Threshold")
plot(S_threshold, color=color.rgb(33, 149, 243, 94), title="S_Threshold")
// log.info("Threshold: {0}", threshold)
// log.info("S Threshold: {0}", s_threshold)

groupTitleSOsLongConditions = "Long SO Conditions"
//UseThreshold_long_SO = input.bool(false, "Use long SO Threshold", group = groupTitleSOsLongConditions)
use_SO_filters_long = input.bool(false, "Use SO filter Long", group = groupTitleSOsLongConditions)
//min_SO_for_filter_long = input.int(3, title="Minimum SOs before using SO filter Long", group = groupTitleSOsLongConditions)
SO_filter_input_long = input(defval=close, title="Enter SO filter Input Long", group = groupTitleSOsLongConditions) 
SO_filter_value_long = input(title='SO filter value Long', defval=1, group = groupTitleSOsLongConditions)
// use_SO_trigger_long = input.bool(false, "Use SO trigger Long", group = groupTitleSOsLongConditions)
// min_SO_for_trigger_long = input.int(3, title="Minimum SOs before using SO Trigger Long", group = groupTitleSOsLongConditions) 
// SO_trigger_input_long = input(defval=close, title="Enter SO trigger Input Long", group = groupTitleSOsLongConditions) // SO_filter_longs_value = 1
// SO_triggervalue_long = input(title='SO trigger value Long', defval=1, group = groupTitleSOsLongConditions)

groupTitleSOsShortConditions = "Short SO Conditions"
useShort_SO_filters = input.bool(false, "Use Short SO filter", group = groupTitleSOsShortConditions)
//min_S_SO_for_filter = input.int(3, title="Minimum SOs before using Short SO filter", group = groupTitleSOsShortConditions)
SO_filter_input_short = input(defval=close, title="Enter Short SO filter Input", group = groupTitleSOsShortConditions)
SO_filter_value_short = input(title='Short SO filter value', defval=-1, group = groupTitleSOsShortConditions)
// useShort_SO_trigger = input.bool(false, "Use Short SO trigger", group = groupTitleSOsShortConditions)
// min_S_SO_for_trigger = input.int(3, title="Minimum SOs before using Short SO_trigger_value_short", group = groupTitleSOsShortConditions) 
// S_SO_trigger = input(defval=close, title="Enter Short SO trigger", group = groupTitleSOsShortConditions) // SO_filter_shorts_value = 1
// short_SO_triggervalue = input(title='Short trigger value', defval=-1, group = groupTitleSOsShortConditions)


// Average Down SOs (safety orders) for longs
if current_so > 0 and
   i == 0 and 
   strategy.position_size > 0 and 
   low <= threshold and
   not no_trade_time and
   (use_SO_filters_long ? SO_filter_input_long == SO_filter_value_long : true) and
   (na(last_so_bar) or bar_index > last_so_bar + MinSOBars) and 
   current_so <= max_safe_order
    order_size_units = safe_order_lots * math.pow(safe_order_volume_scale, current_so - 1) * 100000
    _string_long_so = ""
    if webhookMessage == "fdas"
        _string_long_so := 'type=order,order-type=long,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(safe_order_lots * math.pow(safe_order_volume_scale, current_so - 1)) + ',comment="' + version + '-' + test + direction_text + '",entry=false'
    else if webhookMessage == "pineconnector"
        _string_long_so := str.tostring(ID) + ',long,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(safe_order_lots * math.pow(safe_order_volume_scale, current_so - 1)) + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.order(longId, strategy.long, qty=(safe_order_lots * 100000) * math.pow(safe_order_volume_scale, current_so - 1), comment="#" + str.tostring(long_sequence_counter) + "L SO " + str.tostring(current_so) + '@' + str.tostring(close), alert_message=_string_long_so)
    total_funds_in_trade += threshold * order_size_units
    total_qty_in_trade += order_size_units
    avg_price := total_funds_in_trade / total_qty_in_trade
    current_so += 1
    tradeCount += 1
    last_so_bar := bar_index // Update the bar index when an SO is executed
    last_so_exec_price := close
    log.info("#{0} - L SO#{1} - Avg price: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Strategy position size: {5}, Safe order: {6}, SO volume scale: {7}, SO Step Scale: {8}, Take Profit Level {9}, atrp_price_deviation: {10}, safe_order_step_scale: {11}, atrp_daily: {12}, maxDevATRP: {13}", long_sequence_counter, (current_so - 1), avg_price, total_funds_in_trade, total_qty_in_trade, strategy.position_size, (safe_order_lots * 100000), safe_order_volume_scale, safe_order_step_scale, take_profit_level, atrp_price_deviation, safe_order_step_scale, atrp_daily, maxDevATRP)

order_size_units = safe_S_order_lots * math.pow(safe_S_order_volume_scale, current_so - 1) * 100000

// Average Up SOs (safety orders) for longs
if current_so > 0 and 
   i == 0 and 
   strategy.position_size < 0 and 
   high >= S_threshold and
   not no_trade_time and
   (useShort_SO_filters? SO_filter_input_short == SO_filter_value_short : true) and
   //(useShort_SO_trigger ? (current_so > min_S_SO_for_trigger and S_SO_trigger == short_SO_triggervalue) : true) and
   (na(last_so_bar) or bar_index > last_so_bar + MinSOBars) and
   current_so <= max_S_safe_order
    order_size_units = safe_S_order_lots * math.pow(safe_S_order_volume_scale, current_so - 1) * 100000
    _string_short_so = ""
    if webhookMessage == "fdas"
        _string_short_so := 'type=order,order-type=short,symbol=' + str.replace(syminfo.ticker, " ", "") + '.PRO' + ',risk=' + str.tostring(safe_S_order_lots * math.pow(safe_S_order_volume_scale, current_so - 1)) + ',comment="' + version + '-' + test + direction_text + '",entry=false'
    else if webhookMessage == "pineconnector"
        _string_short_so := str.tostring(ID) + ',short,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(safe_S_order_lots * math.pow(safe_S_order_volume_scale, current_so - 1)) + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.order(shortId, strategy.short, qty=(safe_S_order_lots * 100000) * math.pow(safe_S_order_volume_scale, current_so - 1), comment="#" + str.tostring(short_sequence_counter) + "S SO " + str.tostring(current_so) + '@' + str.tostring(close), alert_message=_string_short_so)
    total_funds_in_trade += S_threshold * order_size_units
    total_qty_in_trade += order_size_units
    avg_price := total_funds_in_trade / total_qty_in_trade
    current_so += 1
    tradeCount += 1
    last_so_bar := bar_index // Update the bar index when an SO is executed
    last_so_exec_price := close
    log.info("#{0} - S SO#{1} - Avg price: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Strategy position size: {5}, Safe order: {6}, SO volume scale: {7}, SO Step Scale: {8}, Take Profit Level: {9}, Last SO execution Price: {10}, maxDevATRP: {11}", short_sequence_counter, (current_so - 1), avg_price, total_funds_in_trade, total_qty_in_trade, strategy.position_size, (safe_S_order_lots * 100000), safe_S_order_volume_scale, safe_S_order_step_scale, take_profit_level, last_so_exec_price, maxDevATRP)


// Take Profit! 
if i == 1
    strategy.close_all()
    i := 0
    i

// take profit long
if take_profit_level <= high and
   not no_trade_time and
   strategy.position_size > 0
    _string_close_long = ""
    if webhookMessage == "fdas"
        _string_close_long := 'type=order,order-type=closelong,symbol=' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + direction_text + '"'
    else if webhookMessage == "pineconnector"
        _string_close_long := str.tostring(ID) + ',closelong,' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.close(longId, comment="#" + str.tostring(long_sequence_counter) + "L Close @" + str.tostring(close), alert_message=_string_close_long)
    soCount := current_so
    current_so := 0
    original_ttp_value := 0
    price_drop := na
    initial_price := na
    diffDays := time - firstBarTime
    if diffDays > maxDiffDays
        maxDiffDays := diffDays
        longest_trade_day := dayofmonth
        longest_trade_month := month
        longest_trade_month
    i := 1
    initial_order := 0.0
    avg_price := na
    capital *= (1 + total_qty_in_trade * take_profit / 100)
    capital
    log.info("#{0} - L CLOSE - SO#{1} - Avg price: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Strategy position size: {5}, Safe order: {6}, SO volume scale: {7}, SO Step Scale: {8}, Take Profit Level {9}", long_sequence_counter, (current_so - 1), avg_price, total_funds_in_trade, total_qty_in_trade, strategy.position_size, (safe_order_lots * 100000), safe_order_volume_scale, safe_order_step_scale, take_profit_level)

// take profit short 
if take_S_profit_level >= low and 
   not no_trade_time and
   strategy.position_size < 0
    _string_close_short = ""
    if webhookMessage == "fdas"
        _string_close_short := 'type=order,order-type=closeshort,symbol=' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + direction_text + '"'
    else if webhookMessage == "pineconnector"
        _string_close_short := str.tostring(ID) + ',closeshort,' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.close(shortId, comment="#" + str.tostring(short_sequence_counter) + "S Close Short @" + str.tostring(close), alert_message=_string_close_short)
    soCount := current_so
    current_so := 0
    price_pump := na
    initial_S_price := na
    diffDays := time - firstBarTime
    if diffDays > maxDiffDays
        maxDiffDays := diffDays
        maxDiffDays
    initial_S_order := 0.0
    avg_price := na
    capital *= (1 + total_qty_in_trade * take_S_profit / 100)
    last_so_exec_price := na
    log.info("#{0} - S CLOSE - SO#{1} - Avg price: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Strategy position size: {5}, Safe order: {6}, SO volume scale: {7}, SO Step Scale: {8}, Take Profit Level: {9}", long_sequence_counter, (current_so - 1), avg_price, total_funds_in_trade, total_qty_in_trade, strategy.position_size, (safe_S_order_lots * 100000), safe_S_order_volume_scale, safe_S_order_step_scale, take_S_profit_level)

//Table building and calculations
if strategy.position_size == 0
    if soCount == 1
        noSO += 1
        noSO
    else if soCount == 2
        SO1 += 1
        SO1
    else if soCount == 3
        SO2 += 1
        SO2
    else if soCount == 4
        SO3 += 1
        SO3
    else if soCount == 5
        SO4 += 1
        SO4
    else if soCount == 6
        SO5 += 1
        SO5
    else if soCount == 7
        SO6 += 1
        SO6
    else if soCount == 8
        SO7 += 1
        SO7
    soCount := 0
    soCount
closedTrades := noSO + SO1 * 2 + SO2 * 3 + SO3 * 4 + SO4 * 5 + SO5 * 6 + SO6 * 7 + SO7 * 8


// Calculate the Max Pumps and Max Drops
if low < price_drop and window and strategy.position_size > 0
    price_drop := low
    if max_drop < int((1 - price_drop / initial_price) * 10000) / 100
        max_drop := int((1 - price_drop / initial_price) * 10000) / 100
        drop_date := dayofmonth(time)you would need to
        drop_month := month(time)
    price_change_percentage = ((initial_price - price_drop) / initial_price) * 100
    max_drop_atrp_temp = price_change_percentage / atrp_daily
    max_drop_atrp := round_to(math.max(max_drop_atrp, max_drop_atrp_temp), 3)
    //log.info("Max Drop ATRP: {0}, Max Drop: {1}, Price Drop: {2}, Date: {3}/{4}", max_drop_atrp, max_drop, price_drop, drop_month, drop_date)
bgcolor(max_drop_atrp[1] < max_drop_atrp ? color.new(#00bbd4, 100) : na)
plot(max_drop_atrp[1] < max_drop_atrp ? max_drop_atrp : na, title="Max Drop ATRP", color=color.new(color.red, 100))
plot(max_drop[1] < max_drop ? max_drop : na, title="Max Drop", color=color.new(#ff5252, 100))

if high > price_pump and window and strategy.position_size < 0
    price_pump := high
    price_change_percentage = ((price_pump - initial_S_price) / initial_S_price) * 100
    max_pump_atrp_temp = price_change_percentage / atrp_daily
    max_pump_atrp := round_to(math.max(max_pump_atrp, max_pump_atrp_temp), 3)
    if max_pump < price_change_percentage
        max_pump := round_to(price_change_percentage, 3)
        pump_date := dayofmonth(time)
        pump_month := month(time)
    //log.info("Max Pump ATRP: {0}, Max Pump: {1}, Price Pump: {2}, Date: {3}/{4}", max_pump_atrp, max_pump, price_pump, pump_month, pump_date)
bgcolor(max_pump_atrp[1] < max_pump_atrp ? color.new(#9b27b0, 100) : na)
plot(max_pump_atrp[1] < max_pump_atrp ? max_pump_atrp : na, title="Max Pump ATRP", color=color.new(#4caf4f, 100))
plot(max_pump[1] < max_pump ? max_pump : na, title="Max Pump", color=color.new(color.green, 100))

// Plot the TP levels
if take_profit_level > 0 and strategy.position_size > 0
    tp_plot := take_profit_level
    tp_plot
else
    tp_plot := close
    tp_plot

if take_S_profit_level > 0 and strategy.position_size < 0
    tp_S_plot := take_S_profit_level
    tp_S_plot
else
    tp_S_plot := close
    tp_S_plot

//Plotting the levels
p1 = plot(tp_plot, title='tp_plot', color=strategy.position_size <= 0 ? na : bullish2, style = plot.style_linebr)
p2 = plot(avg_price, title='avg_price', color=strategy.position_size == 0 ? na : color.rgb(255, 255, 255, 50), style = plot.style_circles)

p3 = plot(threshold, color=strategy.position_size <= 0 ? na : bearish2)
p4 = plot(tp_S_plot, color=strategy.position_size >= 0 ? na : bullish2)
p5 = plot(S_threshold, color=strategy.position_size >= 0 ? na : bearish2)
fill(p1, p2, color=strategy.position_size > 0 ? bullish3 : na)
fill(p2, p3, color=strategy.position_size > 0 ? bearish3 : na)
fill(p4, p2, color=strategy.position_size < 0 ? bullish3 : na)
fill(p5, p2, color=strategy.position_size < 0 ? bearish3 : na)
profit_color = strategy.openprofit < 0 ? bearish : bullish

// Apply shaded background when condition is true
bgcolor(no_trade_time ? color.new(#3a3a3b, 84) : na)

// plot Max Deviation
plot(maxDevATRP, title="Max Deviation ATRP", color=color.blue)
//plot(maxSDevATRP, title="Max Deviation ATRP - Shorts", color=color.red)



color rowBG = color.rgb(29, 29, 29, 9)
color tableText = color.rgb(223, 222, 222, 9)

if show_table
    var tbb2 = TTBTableBuilder.new(position.bottom_right, 2, 20) // Adjust position and size as needed
    if barstate.isconfirmed
        header2 = tbb2.R(0).TextColor(color.rgb(18, 247, 255)).TextSize(size.small).Font(font.family_monospace)
        header2.Text("", "") // Replace with your column headers
        tbb2.R(1).TextColor(tableText).TextSize(size.small).Text("Net Profit", str.tostring(int((capital - initial_capital) * 100) / 100) + '%').Bg(rowBG)
        tbb2.R(2).TextColor(color.rgb(150, 152, 158)).TextSize(size.small).Text("Max Deviation", str.tostring(maxDevATRP) + '%').Bg(rowBG)
        tbb2.R(3).TextColor(tableText).TextSize(size.small).Text("No SO", str.tostring(noSO)).Bg(rowBG)
        tbb2.R(4).TextColor(tableText).TextSize(size.small).Text("SO 1", str.tostring(SO1)).Bg(rowBG)
        tbb2.R(5).TextColor(tableText).TextSize(size.small).Text("SO 2", str.tostring(SO2)).Bg(rowBG)
        tbb2.R(6).TextColor(tableText).TextSize(size.small).Text("SO 3", str.tostring(SO3)).Bg(rowBG)
        tbb2.R(7).TextColor(tableText).TextSize(size.small).Text("SO 4", str.tostring(SO4)).Bg(rowBG)
        tbb2.R(8).TextColor(tableText).TextSize(size.small).Text("SO 5", str.tostring(SO5)).Bg(rowBG)
        tbb2.R(9).TextColor(tableText).TextSize(size.small).Text("SO 6", str.tostring(SO6)).Bg(rowBG)
        tbb2.R(10).TextColor(tableText).TextSize(size.small).Text("SO 7", str.tostring(SO7)).Bg(rowBG)
        tbb2.R(11).TextColor(tableText).TextSize(size.small).Text("Closed/Open trades", str.tostring(closedTrades) + '/' + str.tostring(strategy.opentrades)).Bg(rowBG)
        tbb2.R(12).TextColor(tableText).TextSize(size.small).Text("Current Deal Time", strategy.position_size != 0 ? str.tostring(int((time - firstBarTime) / 8640000) / 10) + ' days' : '0').Bg(rowBG)
        tbb2.R(13).TextColor(tableText).TextSize(size.small).Text("Unrealized position", str.tostring(int(strategy.openprofit / (strategy.initial_capital + strategy.netprofit) * 10000) / 100) + ' %').Bg(rowBG)
        tbb2.R(14).TextColor(tableText).TextSize(size.small).Text("Longest deal:", str.tostring(int(maxDiffDays / 8640000) / 10) + ' days, ' + str.tostring(longest_trade_day) + '/' + str.tostring(longest_trade_month)).Bg(rowBG)
        tbb2.R(15).TextColor(tableText).TextSize(size.small).Text("Max price drop:", str.tostring(max_drop) + ' %, ' + str.tostring(drop_month) + '/' + str.tostring(drop_date)).Bg(rowBG)
        tbb2.R(16).TextColor(tableText).TextSize(size.small).Text("Max price pump:", str.tostring(max_pump) + ' %, ' + str.tostring(pump_month) + '/' + str.tostring(pump_date)).Bg(rowBG)
        tbb2.R(17).TextColor(tableText).TextSize(size.small).Text("Max price drop ATRP:", str.tostring(max_drop_atrp) + ' %, ' + str.tostring(drop_month) + '/' + str.tostring(drop_date)).Bg(rowBG)
        tbb2.R(18).TextColor(tableText).TextSize(size.small).Text("Max price pump ATRP:", str.tostring(max_pump_atrp) + ' %, ' + str.tostring(pump_month) + '/' + str.tostring(pump_date)).Bg(rowBG)
// User input for target bars to track the best take profit deviation
target_bars = input(20, title="Target Bars for Best TP Deviation")

// Initialize variable to store the best take profit deviation
var float best_tp_deviation = na
// Calculate best_tp_deviation as a percentage of the daily ATRP
best_tp_deviation_percentage = best_tp_deviation * 100
plot(best_tp_deviation_percentage, title="Best TP Deviation ATRP", color=color.purple)
// User input for target bars to track the best take profit deviation
target_bars = input(20, title="Target Bars for Best TP Deviation")

// Initialize variable to store the best take profit deviation
var float best_tp_deviation = na
var float best_tp_deviation_percentage = na // Initialize with 'na' to indicate it's not yet calculated

// Calculate best_tp_deviation as a percentage of the daily ATRP
best_tp_deviation_percentage := best_tp_deviation * 100
plot(best_tp_deviation_percentage, title="Best TP Deviation ATRP", color=color.purple)
// User input for target bars to track the best take profit deviation
target_bars = input(20, title="Target Bars for Best TP Deviation")

// Initialize variable to store the best take profit deviation
var float best_tp_deviation = na
var float best_tp_deviation_percentage = na // Initialize with 'na' to indicate it's not yet calculated

// Update best_tp_deviation for long positions within target_bars
var float high_since_entry = na // Initialize with 'na' to indicate it's not yet calculated
if strategy.position_size > 0
    entry_bar_index = bar_index[1] // Assuming entry_bar_index is declared elsewhere with the correct entry bar index
    if bar_index - entry_bar_index <= target_bars
        high_since_entry := highest(high, bar_index - entry_bar_index + 1)
        best_tp_deviation := math.max(nz(best_tp_deviation, 0), (high_since_entry - entry_price) / atrp_daily)

// Update best_tp_deviation for short positions within target_bars
var float low_since_entry = na // Initialize with 'na' to indicate it's not yet calculated
if strategy.position_size < 0
    entry_bar_index = bar_index[1] // Assuming entry_bar_index is declared elsewhere with the correct entry bar index
    if bar_index - entry_bar_index <= target_bars
        low_since_entry := lowest(low, bar_index - entry_bar_index + 1)
        best_tp_deviation := math.min(nz(best_tp_deviation, 0), (entry_price - low_since_entry) / atrp_daily)

// Calculate best_tp_deviation as a percentage of the daily ATRP
best_tp_deviation_percentage := best_tp_deviation * 100
plot(best_tp_deviation_percentage, title="Best TP Deviation ATRP", color=color.purple)
// User input for target bars to track the best take profit deviation
target_bars = input(20, title="Target Bars for Best TP Deviation")

// Initialize variable to store the best take profit deviation
var float best_tp_deviation = na
var float best_tp_deviation_percentage = na // Initialize with 'na' to indicate it's not yet calculated

// Reset best_tp_deviation at the start of a new trade round for longs
if long and bar_index > barsToWait and strategy.position_size == 0 and close > 0 and window and not no_trade_time and trigger == long_trigger
    best_tp_deviation := na

// Reset best_tp_deviation at the start of a new trade round for shorts
else if short and bar_index > barsToWait and strategy.position_size == 0 and close > 0 and window and not no_trade_time and trigger == short_trigger
    best_tp_deviation := na

// Update best_tp_deviation for long positions within target_bars
if strategy.position_size > 0 and bar_index - entry_bar_index <= target_bars
    high_since_entry = highest(high, bar_index - entry_bar_index + 1)
    best_tp_deviation := math.max(nz(best_tp_deviation, 0), (high_since_entry - entry_price) / atrp_daily)

// Update best_tp_deviation for short positions within target_bars
if strategy.position_size < 0 and bar_index - entry_bar_index <= target_bars
    low_since_entry = lowest(low, bar_index - entry_bar_index + 1)
    best_tp_deviation := math.min(nz(best_tp_deviation, 0), (entry_price - low_since_entry) / atrp_daily)

// Calculate best_tp_deviation as a percentage of the daily ATRP
best_tp_deviation_percentage := best_tp_deviation * 100
plot(best_tp_deviation_percentage, title="Best TP Deviation ATRP", color=color.purple)
