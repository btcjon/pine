//@version=5
strategy('TTB DCA 7.5', overlay=true, initial_capital=1000000, default_qty_type=strategy.cash, default_qty_value=100000, currency=currency.USD, pyramiding=999, calc_on_every_tick=false)

import thetradingbot/TTB_TableBuilder/1 as TTBTableBuilder

//main colors
color bullish = #00FFD1
color bearish = #C70A80ff

// f_security function for MTF
f_security(_sym, _res, _src, _rep) =>
    request.security(_sym, _res, _src[not _rep and barstate.isrealtime ? 1 : 0])[_rep or barstate.isrealtime ? 0 : 1]
var bool i_repaint = false // Set to false to avoid repainting
var string ticker = syminfo.tickerid

truncate(number, decimals) =>
    factor = math.pow(10, decimals)
    int(number * factor) / factor

groupTitleGeneralInputs = "General Inputs"
direction = input.string(defval='Long', title='Trading Direction', options=['All', 'Long', 'Short'], group = groupTitleGeneralInputs)
direction_text = direction == 'Long' ? 'L' : 'S'

var long = false
var short = false

if direction == 'All'
    long := true
    short := true
else if direction == 'Long'
    long := true
else if direction == 'Short'
    short := true


ID = 6700960415957
//method = input.string(title="Method for setting TP and Deviation Level", defval="ATRP", options=["ATRP", "Price % Change", "Avg ATR"], group = groupTitleGeneralInputs)
show_table = input(true, title='Show table', group = groupTitleGeneralInputs)
text_size_switch = true
barsToWait = input(200, title="Bars Wait to Start")
HTF1 = input.int(15, title='HTF1', group = groupTitleGeneralInputs)
HTF2 = HTF1 * 2
HTF3 = HTF1 * 4
HTF4 = HTF1 * 8

// Convert integer timeframes to string
HTF1_str = str.tostring(HTF1)
HTF2_str = str.tostring(HTF2)
HTF3_str = str.tostring(HTF3)
HTF4_str = str.tostring(HTF4)

MinSOBars = input(10, title="Min Bars Between SOs", group = groupTitleGeneralInputs)
version = input(defval='7-5', title='version', group = groupTitleGeneralInputs)
test = input(defval='1', title='test', group = groupTitleGeneralInputs)

// Triggers
trigger = input(defval=close, title="Enter trigger", group = groupTitleGeneralInputs)
long_trigger_value = input(title='Long trigger value', defval=1, group = groupTitleGeneralInputs)
short_trigger_value = input(title='Short trigger value', defval=-1, group = groupTitleGeneralInputs)
//trigger = close
webhookMessage = input.string("fdas", "Choose message version", options=["fdas", "pineconnector"])

groupTitleStratPlots = "Strategy Plots"
ShowAvgEntryPlot = input.bool(true, title='Show Avg Entry Plot', group = groupTitleStratPlots)
ShowTPPlot = input.bool(true, title='Show TP Plot', group = groupTitleStratPlots)
ShowSOPlot = input.bool(false, title='Show SO Plot', group = groupTitleStratPlots)

//Recovery Inputs
groupTitleRecoveryInputs = "Recovery Inputs"
recovery_mode = input.bool(false, title='Recovery Mode', group = groupTitleRecoveryInputs)
avg_entry_price = input(1.0, "Average Entry Price", group = groupTitleRecoveryInputs)
waitBars_recovery = input(10, title="Number of Bars to Wait After Entry for SO", group = groupTitleRecoveryInputs)
AvgPrice_Entry = ta.cross(close, avg_entry_price)

// Date Ranges
startDateTime = input.time(timestamp("1 Feb 2021 12:00"), title="Start", group="Strategy Date Range")
endDateTime = input.time(timestamp("1 Feb 2025 12:00"), title="End", group="Strategy Date Range")
window = time >= startDateTime and time <= endDateTime ? true : false 


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// ATRP
atrp_length = input.int(75, title='ATRP Length', minval=1, group = groupTitleGeneralInputs)

// Declare variables
var trp = float(0)
var atrp = float(0)

// Calculate true range percent
trp := ta.tr / hl2 * 100

round_to(n, decimals) =>
    mult = 1.0
    for i = 1 to decimals
        mult := mult * 10
    round_n = na(n * mult + 0.5) ? na : (n * mult + 0.5) - (n * mult + 0.5) % 1
    round_n / mult

// Calculate smoothed percentage range
atrp := ta.sma(trp, atrp_length)

//atrp_htf1 = f_security(ticker, HTF1, atrp, i_repaint)
atrp_htf1 = round_to(f_security(ticker, HTF1_str, atrp, i_repaint), 4)
atrp_htf2 = round_to(f_security(ticker, HTF2_str, atrp, i_repaint), 4)
atrp_htf3 = round_to(f_security(ticker, HTF3_str, atrp, i_repaint), 4)
atrp_htf4 = round_to(f_security(ticker, HTF4_str, atrp, i_repaint), 4)
plot(atrp, title='ATRP', color=color.rgb(255, 177, 20, 94), linewidth=1, style=plot.style_linebr)
//end atrp
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// atr
atr_length = 100
ma_function(_source, _length) => ta.rma(_source, _length)
avg_atr = ma_function(ta.tr, atr_length)

plot(ma_function(ta.tr(true), atr_length), title = "ATR", color=color.new(#B71C1C, 0))
//end atr


// SO Inputs
groupTitleSOInputs = "SO Inputs"
so_dev_factor = input.float(3, title='SO Deviation Factor', step=0.1, minval=0.0, group = groupTitleSOInputs)
tp_factor = input.float(6, title='TP ATRP Factor', step=0.1, minval=0.0, group = groupTitleSOInputs)
base_order_lots = input.float(0.4, "Entry / Recovery (Lots)", group = groupTitleSOInputs)
SO_lots = input.float(0.4, "SO Lots", group = groupTitleSOInputs)
SO_volume_scale = input.float(1, step=0.1, title='SO Volume Scale', group = groupTitleSOInputs)
SO_step_scale = input.float(2, step=0.1, title='SO Step Distance Scale', group = groupTitleSOInputs)
max_SOs = input(6, title='Max SOs', group = groupTitleSOInputs)
input_bars_to_wait = input(1, title="TP Number of bars to wait after SO", group = groupTitleSOInputs)

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// Structure
groupTitleStructureSettings = "Structure Settings"
MSlength  = input(5, 'Pivot Lookback', group = groupTitleStructureSettings)
incr    = input.float(95, 'Increment Factor %', minval = 0, group = groupTitleStructureSettings)
showTS  = input(false, "Show TS", group = groupTitleStructureSettings)
showTrendChange = input.bool(false, "Show Trend Change", group = groupTitleStructureSettings)
show_ts_htf1 = input.bool(false, title="Show HTF1 Trailing Stop", group = groupTitleStructureSettings)
show_ts_htf2 = input.bool(false, title="Show HTF2 Trailing Stop", group = groupTitleStructureSettings)
show_ts_htf3 = input.bool(false, title="Show HTF3 Trailing Stop", group = groupTitleStructureSettings)
show_ts_htf4 = input.bool(false, title="Show HTF4 Trailing Stop", group = groupTitleStructureSettings)

resetOn = 'CHoCH'

//Style 
bullCss    = #035686
bearCss    = color.rgb(61, 1, 52)
retCss     = #413002
areaTransp = 90

bullCss2    = #0394e8
bearCss2    = color.rgb(148, 2, 126)
retCss2    = #413002
areaTransp2 = 90

//structure Global variables
var float ph_y = na , var int ph_x = na
var float pl_y = na , var int pl_x = na
var float top = na  , var float btm = na
var ph_cross = false, var pl_cross = false

var float max = na
var float min = na
var float ts = na

var os = 0
ms = 0

//Detect pivots and get coordinates
n = bar_index
ph = ta.pivothigh(MSlength, MSlength)
pl = ta.pivotlow(MSlength, MSlength)

if ph > 0
    ph_y := ph
    ph_x := n - MSlength
    ph_cross := false

if pl > 0
    pl_y := pl
    pl_x := n - MSlength
    pl_cross := false

//Bullish structures
if close > ph_y and not ph_cross
    if resetOn == 'CHoCH'
        ms := os == -1 ? 1 : 0
    else
        ms := 1

    ph_cross := true


    os := 1

    //Search for local minima
    btm := low
    for i = 0 to (n - ph_x)-1
        btm := math.min(low[i], btm)

    osChange = os != os[1]

//Bearish structures
if close < pl_y and not pl_cross
    if resetOn == 'CHoCH'
        ms := os == 1 ? -1 : 0
    else
        ms := -1

    pl_cross := true

    os := -1

    //Search for local maxima
    top := high
    for i = 0 to (n - pl_x)-1
        top := math.max(high[i], top)

    osChange = os != os[1]

//Trailing stop max/min
if ms == 1
    max := close
else if ms == -1
    min := close
else
    max := math.max(close, max)
    min := math.min(close, min)

//Trailing stop
ts := ms == 1 ? btm
  : ms == -1 ? top
  : os == 1 ? ts + (max - max[1]) * incr / 100
  : ts + (min - min[1]) * incr / 100

css = (ms > 0) ? na 
  : os == 1 ? bullCss
  : bearCss

css2 = (ms > 0) ? na 
  : os == 1 ? bullCss2
  : bearCss2

css_area = (close - ts) * os < 0 ? retCss
  : css

osChange = os != os[1]

// MTF
ts_htf1 = f_security(ticker, HTF1_str, ts, i_repaint)
ts_htf2 = f_security(ticker, HTF2_str, ts, i_repaint)
ts_htf3 = f_security(ticker, HTF3_str, ts, i_repaint)
ts_htf4 = f_security(ticker, HTF4_str, ts, i_repaint)
os_htf1 = f_security(ticker, HTF1_str, os, i_repaint)
os_htf2 = f_security(ticker, HTF2_str, os, i_repaint)
os_htf3 = f_security(ticker, HTF3_str, os, i_repaint)
os_htf4 = f_security(ticker, HTF4_str, os, i_repaint)

trendUp = os == 1 and osChange
trendDown = os == -1 and osChange

trendingUp = os == 1
trendingDown = os == -1

//MTF os
trendingUpHTF1 = os_htf1 == 1
trendingDownHTF1 = os_htf1 == -1
trendingUpHTF2 = os_htf2 == 1
trendingDownHTF2 = os_htf2 == -1
trendingUpHTF3 = os_htf3 == 1
trendingDownHTF3 = os_htf3 == -1
trendingUpHTF4 = os_htf4 == 1
trendingDownHTF4 = os_htf4 == -1

trendstatusHTF1 = trendingUpHTF1 ? 'Up'
  : trendingDownHTF1 ? 'Down'
  : 'Neutral'

trendstatusHTF2 = trendingUpHTF2 ? 'Up'
  : trendingDownHTF2 ? 'Down'
  : 'Neutral'

trendstatusHTF3 = trendingUpHTF3 ? 'Up'
  : trendingDownHTF3 ? 'Down'
  : 'Neutral'

trendstatusHTF4 = trendingUpHTF4 ? 'Up'
  : trendingDownHTF4 ? 'Down'
  : 'Neutral'

trendChangeUpHTF1 = os_htf1 == 1 and (os_htf1 != os_htf1[1])
trendChangeDownHTF1 = os_htf1 == -1 and (os_htf1 != os_htf1[1])
trendChangeUpHTF2 = os_htf2 == 1 and (os_htf2 != os_htf2[1])
trendChangeDownHTF2 = os_htf2 == -1 and (os_htf2 != os_htf2[1])
trendChangeUpHTF3 = os_htf3 == 1 and (os_htf3 != os_htf3[1])
trendChangeDownHTF3 = os_htf3 == -1 and (os_htf3 != os_htf3[1])
trendChangeUpHTF4 = os_htf4 == 1 and (os_htf4 != os_htf4[1])
trendChangeDownHTF4 = os_htf4 == -1 and (os_htf4 != os_htf4[1])

above_ts_htf1 = close > ts_htf1
below_ts_htf1 = close < ts_htf1
above_ts_htf2 = close > ts_htf2
below_ts_htf2 = close < ts_htf2
above_ts_htf3 = close > ts_htf3
below_ts_htf3 = close < ts_htf3
above_ts_htf4 = close > ts_htf4
below_ts_htf4 = close < ts_htf4

//Plots

plot_ts    = plot(showTS ? ts : na, 'Trailing Stop', color = css2)
plotshape(showTrendChange ? trendUp : na, style=shape.triangleup, location=location.belowbar, color=bullish, size=size.tiny, title="Up Trend")
plotshape(showTrendChange ? trendDown : na, style=shape.triangledown, location=location.abovebar, color=bearish, size=size.tiny, title="Down Trend")
barcolor(showTrendChange and trendUp ? bullish : na)
barcolor(showTrendChange and trendDown ? bearish : na)

// Plot the trailing stops with individual checkboxes
plot_ts_htf1 = plot(show_ts_htf1 ? ts_htf1 : na, 'HTF1 Trailing Stop', color = css)
plot_ts_htf2 = plot(show_ts_htf2 ? ts_htf2 : na, 'HTF2 Trailing Stop', color = css)
plot_ts_htf3 = plot(show_ts_htf3 ? ts_htf3 : na, 'HTF3 Trailing Stop', color = css)
plot_ts_htf4 = plot(show_ts_htf4 ? ts_htf4 : na, 'HTF4 Trailing Stop', color = css)

//plotshape(trendChangeUpHTF3, style=shape.triangleup, location=location.belowbar, color=bullish, size=size.small, title="Up Trend Change HTF3")
//plotshape(trendChangeDownHTF3, style=shape.triangledown, location=location.abovebar, color=bearish, size=size.small, title="Up Trend Change HTF3")
bgcolor(trendChangeUpHTF3 ? color.new(bullish, 80) : na)
bgcolor(trendChangeDownHTF3 ? color.new(bearish, 80) : na)

// end structure


// random rules
twobarup = close[1] > open[1] and close > open
twobardown = close[1] < open[1] and close < open
threebarup = close[2] > open[2] and close[1] > open[1] and close > open
threebardown = close[2] < open[2] and close[1] < open[1] and close < open


var float initial_capital = 10000.0 // Starting capital
// variables long
var current_so = 0 
var initial_order = 0.0
var original_ttp_value = 0.0 //
var quantity = 0.0 //
var entry_price = 0.0 //
var firstBarTime = 0.0 //
var maxDiffDays = 0.0 //
var soCount = 0 //
var SO1 = 0 //
var SO2 = 0
var SO3 = 0
var SO4 = 0
var SO5 = 0
var SO6 = 0
var SO7 = 0
var noSO = 0
var initial_price = 0.0
var price_drop = 0.0
var price_pump = 0.0
var max_drop = 0.0
var max_pump = 0.0
var pump_date = 0
var pump_month = 0
var drop_date = 0
var drop_month = 0
var longest_trade_day = 0
var longest_trade_month = 0
var take_profit_level = 0.0
var tp_plot = 0.0
var threshold = 0.0
var tradeCount = 0
//var i = 0
var avg_price = 0.0
var total_funds_in_trade = 0.0
var total_qty_in_trade = 0.0
var int entry_bar_index = na
var int last_so_bar = na
var barCountSinceEntry = 0 // Variables to track entry and bars since entry
var entrySignal = false
var int last_so_bar_index = na // track bars since last SO
var bool waitXbarsTP = na
var int longEntryBarIndex = na 
var float long_position_size = 0.0
var float last_SO_execution_price = na
var int long_sequence_counter = 0
timeDiff = time - firstBarTime
maxDev = 0.0
closedTrades = 0
var float capital = initial_capital 
var float first_long_trade_time = na
var current_boost = 0
var last_BO_execution_price = 0.0
var int last_bo_bar_index = na
// end variables long

// variables short
var current_so_s = 0
var initial_order_s = 0.0
var original_ttp_value_s = 0.0
var quantity_s = 0.0
var entry_price_s = 0.0
var firstBarTime_s = 0.0
var maxDiffDays_s = 0.0
var soCount_s = 0
var SO1_s = 0
var SO2_s = 0
var SO3_s = 0
var SO4_s = 0
var SO5_s = 0
var SO6_s = 0
var SO7_s = 0
var noSO_s = 0
var initial_price_s = 0.0
var price_drop_s = 0.0
var price_pump_s = 0.0
var max_drop_s = 0.0
var max_pump_s = 0.0
var pump_date_s = 0
var pump_month_s = 0
var drop_date_s = 0
var drop_month_s = 0
var longest_trade_day_s = 0
var longest_trade_month_s = 0
var take_profit_level_s = 0.0
var tp_plot_s = 0.0
var threshold_s = 0.0
var tradeCount_s = 0
//var i_s = 0
var avg_price_s = 0.0
var total_funds_in_trade_s = 0.0
var total_qty_in_trade_s = 0.0
var int entry_bar_index_s = na
var int last_so_bar_s = na
var barCountSinceEntry_s = 0 // Variables to track entry and bars since entry
var entrySignal_s = false
var int last_so_bar_index_s = na // track bars since last SO
var bool waitXbarsTP_s = na
var int shortEntryBarIndex = na
var float short_position_size = 0.0
var float last_SO_execution_price_s = na
var float last_avg_price = na
var int short_sequence_counter = 0
maxDev_s = 0.0
closedTrades_s = 0
timeDiff_s = time - firstBarTime_s
var float capital_s = initial_capital
var float first_short_trade_time = na
// end variables short


// Helper parameters and calculations
// Turn that time difference into days
diffDays = timeDiff / 86400000
diffDays_s = timeDiff_s / 86400000


// take_profit = tp_factor * atrp / 100
// take_profit_level := long_position_size > 0 ? avg_price * (1 + take_profit) : na
// take_profit_level_s := short_position_size < 0 ? avg_price_s * (1 - take_profit) : na

// Calculate the price deviation and take profit based on the chosen method
price_deviation = so_dev_factor * atrp / 100


take_profit = tp_factor * atrp / 100 

//take_profit_level := long_position_size > 0 ? avg_price * (1 + take_profit) : na
//take_profit_level_s := short_position_size < 0 ? avg_price_s * (1 - take_profit) : na


// Calculate our TP levels
take_profit_level := avg_price * (1 + take_profit)
take_profit_level_s := avg_price_s * (1 - take_profit)



waitXbarsTP := na(last_so_bar_index) ? na : last_so_bar_index + input_bars_to_wait // wait X bars after SO for TP
doneSOwaiting = barCountSinceEntry > waitBars_recovery
min_bars_between_sos = MinSOBars // Minimum number of bars between SOs

so_multiplier_4 = input(1.5, title="Multiplier for SO4", group = groupTitleSOInputs)
so_multiplier_5_6 = input(2.0, title="Multiplier for SO5 and SO6", group = groupTitleSOInputs)
so_multiplier = current_so == 4 ? so_multiplier_4 : current_so >= 5 and current_so <= 6 ? so_multiplier_5_6 : 1
so_multiplier_s = current_so_s == 4 ? so_multiplier_4 : current_so_s >= 5 and current_so_s <= 6 ? so_multiplier_5_6 : 1


//Long and short entry
///Strategy Inputs
groupTitleLongEntry = "Long Entry"
trigger_long_Input = input.bool(false, "Trigger Long", group = groupTitleLongEntry)
Struc_trigger_long_Input = input.bool(true, "Struc Trigger Long", group = groupTitleLongEntry)

groupTitleLongFilters = "Long Filters"
trendingUp_filter = input.bool(false, "trendingUp long trend filter", group = groupTitleLongFilters)
twobarup_filter = input.bool(false, "2nd bar up filter", group = groupTitleLongFilters)
above_ts_htf1_filter = input.bool(false, "Use hft1 long trend filter", group = groupTitleLongFilters)
above_ts_htf2_filter = input.bool(false, "Use hft2 long trend filter", group = groupTitleLongFilters)
above_ts_htf3_filter = input.bool(true, "Use hft3 long trend filter", group = groupTitleLongFilters)
above_ts_htf4_filter = input.bool(false, "Use hft4 long trend filter", group = groupTitleLongFilters)

groupTitleSOsLong = "Long SOs"
UseThreshold_long_SO = input.bool(false, "Use long SO Threshold", group = groupTitleSOsLong)
Uselong_SO_trigger = input.bool(false, "Use Long SO trigger", group = groupTitleSOsLong)
min_SO_for_trigger = input.int(3, title="Minimum SOs before using Long SO_trigger", group = groupTitleSOsLong)
SO_trigger = input(defval=close, title="Enter Long SO trigger", group = groupTitleSOsLong)
long_SO_triggervalue = input(title='Long trigger value', defval=1, group = groupTitleSOsLong)
trendUp_triggerSO = input.bool(false, "trendUp long trend trigger for SO", group = groupTitleSOsLong)
trendingUp_filterSO = input.bool(false, "trendingUp long trend filter for SO", group = groupTitleSOsLong)
twoBarUp_filterSO = input.bool(false, "2 bar up filter for SO", group = groupTitleSOsLong)
above_ts_htf1_filterSO = input.bool(false, "Use hft1 long trend filter for SO", group = groupTitleSOsLong)
above_ts_htf2_filterSO = input.bool(false, "Use hft2 long trend filterfor SO", group = groupTitleSOsLong)
above_ts_htf3_filterSO = input.bool(false, "Use hft3 long trend filter for SO", group = groupTitleSOsLong)
above_ts_htf4_filterSO = input.bool(false, "Use hft4 long trend filter for SO", group = groupTitleSOsLong)

groupTitleShortEntry = "Short Entry"
trigger_short_Input = input.bool(false, "Trigger Short", group = groupTitleShortEntry)
Struc_trigger_short_Input = input.bool(true, "Struc Trigger Short", group = groupTitleShortEntry)

groupTitleShortFilters = "Short Filters"
trendingDown_filter = input.bool(false, "trendingDown short trend filter", group = groupTitleShortFilters)
twobardown_filter = input.bool(false, "2nd bar down filter", group = groupTitleShortFilters)
below_ts_htf1_filter = input.bool(false, "Use hft1 short trend filter", group = groupTitleShortFilters)
below_ts_htf2_filter = input.bool(false, "Use hft2 short trend filter", group = groupTitleShortFilters)
below_ts_htf3_filter = input.bool(true, "Use hft3 short trend filter", group = groupTitleShortFilters)
below_ts_htf4_filter = input.bool(false, "Use hft4 short trend filter", group = groupTitleShortFilters)

groupTitleSOsShort = "Short SOs"
UseThreshold_short_SO = input.bool(false, "Use short SO Threshold", group = groupTitleSOsShort)
Use_SO_trigger_s = input.bool(false, "Use Short SO trigger", group = groupTitleSOsShort)
min_SO_for_trigger_s = input.int(3, title="Minimum SOs before using Short SO_trigger_s", group = groupTitleSOsShort)
SO_trigger_s = input(defval=close, title="Enter Short SO trigger", group = groupTitleSOsShort)
short_SO_triggervalue_s = input(title='Short trigger value', defval=1, group = groupTitleSOsShort)
trendDown_triggerSO = input.bool(true, "trendDown short trend trigger for SO", group = groupTitleSOsShort)
trendingDown_filterSO = input.bool(false, "trendingDown short trend filter for SO", group = groupTitleSOsShort)
twoBarDown_filterSO = input.bool(false, "2 bar down filter for SO", group = groupTitleSOsShort)
below_ts_htf1_filterSO = input.bool(false, "Use hft1 short trend filter for SO", group = groupTitleSOsShort)
below_ts_htf2_filterSO = input.bool(false, "Use hft2 short trend filter for SO", group = groupTitleSOsShort)
below_ts_htf3_filterSO = input.bool(false, "Use hft3 short trend filter for SO", group = groupTitleSOsShort)
below_ts_htf4_filterSO = input.bool(false, "Use hft4 short trend filter for SO", group = groupTitleSOsShort)


// groupTitleBoostInputs = "Boost Inputs"
// BoostVolumeScale = input.float(0.5, step=0.1, title='Boost Volume Scale', group = groupTitleBoostInputs)
// max_boosts = input(1, title='Max Boosts', group = groupTitleBoostInputs)
// boost_percent_to_tp = input(70, title="Percentage", group = groupTitleBoostInputs) / 100.0

// groupTitleBoostLong = "Long Boost"
// useBoostLong = input.bool(false, "Use Long Boost", group = groupTitleBoostLong)
// twobarup_boostCondition = input.bool(false, "2nd bar up boost", group = groupTitleBoostLong)
// threebarup_boostCondition = input.bool(false, "3rd bar up boost", group = groupTitleBoostLong)


groupTitleTPconditions_long = "TP and Exits Long"
TPbyPercentCondition_long = input.bool(true, "TP by % long", group = groupTitleTPconditions_long)
ExitByTrendChange_long = input.bool(false, "Exit by trend ↓ long", group = groupTitleTPconditions_long)
ExitByTrendChangeHTF1_long = input.bool(false, "Exit by trend ↓ HTF1 long", group = groupTitleTPconditions_long)
ExitByTrendChangeHTF2_long = input.bool(false, "Exit by trend ↓ HTF2 long", group = groupTitleTPconditions_long)
ExitByTrendChangeHTF3_long = input.bool(false, "Exit by trend ↓ HTF3 long", group = groupTitleTPconditions_long)
ExitByTrendChangeHTF4_long = input.bool(false, "Exit by trend ↓ HTF4 long", group = groupTitleTPconditions_long)
waitXbarsTPcondition = input.bool(false, "Wait X bars after SO for TP", group = groupTitleTPconditions_long)

groupTitleTPconditions_short = "TP and Exits Short"
TPbyPercentCondition_short = input.bool(true, "TP by % short", group = groupTitleTPconditions_short)
ExitByTrendChange_short = input.bool(false, "Exit by trend ↑ short", group = groupTitleTPconditions_short)
ExitByTrendChangeHTF1_short = input.bool(false, "Exit by trend ↑ HTF1 short", group = groupTitleTPconditions_short)
ExitByTrendChangeHTF2_short = input.bool(false, "Exit by trend ↑ HTF2 short", group = groupTitleTPconditions_short)
ExitByTrendChangeHTF3_short = input.bool(false, "Exit by trend ↑ HTF3 short", group = groupTitleTPconditions_short)
ExitByTrendChangeHTF4_short = input.bool(false, "Exit by trend ↑ HTF4 short", group = groupTitleTPconditions_short)
waitXbarsTPcondition_short = input.bool(false, "Wait X bars after SO for TP", group = groupTitleTPconditions_short)

// MaxDev calculation
maxDev := 0.0
for j = 0 to max_SOs - 1 by 1
    maxDev := math.round((maxDev + price_deviation * 100 * math.pow(SO_step_scale, j)) * 100) / 100

maxDev_s := 0.0
for j = 0 to max_SOs - 1 by 1
    maxDev_s := math.round((maxDev_s + price_deviation * 100 * math.pow(SO_step_scale, j)) * 100) / 100

// Calculate the hit conditions for the thresholds
threshold_hit = low <= threshold
threshold_s_hit = high >= threshold_s

// long entry
if long and
   bar_index > barsToWait and
   long_position_size == 0 and 
   window and not(hour(time) == 0 and 
   minute(time) < 59) and 
   (recovery_mode ? AvgPrice_Entry : true) and
   (trigger_long_Input ? trigger == long_trigger_value : true) and 
   (Struc_trigger_long_Input ? trendUp : true) and 
   (trendingUp_filter ? trendingUp : true) and
   (above_ts_htf1_filter ? above_ts_htf1 : true) and
   (above_ts_htf2_filter ? above_ts_htf2 : true) and
   (above_ts_htf3_filter ? above_ts_htf3 : true) and
   (above_ts_htf4_filter ? above_ts_htf4 : true) and
   (twobarup_filter ? twobarup : true)
    long_sequence_counter := long_sequence_counter + 1
    longId = "Long" + str.tostring(long_sequence_counter)
    _string_long = ""
    if webhookMessage == "fdas"
        _string_long := 'type=order,order-type=long,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + direction_text + '",entry=true'
    else if webhookMessage == "pineconnector"
        _string_long := str.tostring(ID) + ',long,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.order(longId, strategy.long, qty=(base_order_lots * 100000), comment="#" + str.tostring(long_sequence_counter) + "L E " + str.tostring(close), alert_message=_string_long)
    long_position_size := long_position_size + (base_order_lots * 100000)
    initial_order := close
    current_so := 1
    initial_price := close
    price_drop := close
    original_ttp_value := 0
    firstBarTime := time
    tradeCount += 1
    avg_price := close
    total_funds_in_trade := avg_price * (base_order_lots * 100000)
    total_qty_in_trade := (base_order_lots * 100000)
    entry_bar_index := bar_index
    entrySignal := true
    barCountSinceEntry := 0  // Reset the counter at entry
    last_so_bar_index := na
    first_long_trade_time := time
    log.info("#{0}L : Avg price after Entry updated: {1}, Total funds in trade: {2}, Total qty in trade: {3}, Long position size: {4}, Short position size: {5}", long_sequence_counter, avg_price, total_funds_in_trade, total_qty_in_trade, long_position_size, short_position_size)
longId = "Long" + str.tostring(long_sequence_counter)

// short entry
if short and
   bar_index > barsToWait and
   short_position_size == 0 and 
   window and not(hour(time) == 0 and 
   minute(time) < 59) and 
   (recovery_mode ? AvgPrice_Entry : true) and
   (trigger_short_Input ? trigger == short_trigger_value : true) and
   (Struc_trigger_short_Input ? trendDown : true) and 
   (trendingDown_filter ? trendingDown : true) and
   (below_ts_htf1_filter ? below_ts_htf1 : true) and
   (below_ts_htf2_filter ? below_ts_htf2 : true) and
   (below_ts_htf3_filter ? below_ts_htf3 : true) and
   (below_ts_htf4_filter ? below_ts_htf4 : true) and
   (twobardown_filter ? twobardown : true)
    short_sequence_counter := short_sequence_counter + 1
    shortId = "Short" + str.tostring(short_sequence_counter)
    _string_short = ""
    if webhookMessage == "fdas"
        _string_short := 'type=order,order-type=short,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + direction_text + '",entry=true'
    else if webhookMessage == "pineconnector"
        _string_short := str.tostring(ID) + ',short,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.order(shortId, strategy.short, qty=(base_order_lots * 100000), comment="#" + str.tostring(short_sequence_counter) + "S E " + str.tostring(close), alert_message=_string_short)
    short_position_size := short_position_size - (base_order_lots * 100000)
    initial_order_s := close
    current_so_s := 1
    initial_price_s := close
    price_pump_s := close
    original_ttp_value_s := 0
    firstBarTime_s := time
    tradeCount_s += 1
    avg_price_s := close
    total_funds_in_trade_s := avg_price_s * (base_order_lots * 100000)
    total_qty_in_trade_s := (base_order_lots * 100000)
    entry_bar_index_s := bar_index
    entrySignal_s := true
    barCountSinceEntry_s := 0  // Reset the counter at entry
    last_so_bar_index_s := na
    first_short_trade_time := time
    log.info("#{0} SE  SO{11}: Avg price after Entry updated: {1}, Total funds in trade: {2}, Total qty in trade: {3}, Short position size: {4}, Threshold: {5}, Short TP Level: {6}, tp_factor: {7}, atrp: {8}, close: {9}, price_deviation: {10}, current_so_s: {11}, entrySignal_s: {12}, barCountSinceEntry_s: {13}, take_profit: {14}", short_sequence_counter, avg_price_s, total_funds_in_trade_s, total_qty_in_trade_s, short_position_size, threshold_s, take_profit_level_s, tp_factor, atrp, close, price_deviation, current_so_s, entrySignal_s, barCountSinceEntry_s, take_profit)
shortId = "Short" + str.tostring(short_sequence_counter)

// Update bar counter on each bar if there was an entry
if entrySignal
    barCountSinceEntry += 1
plot(barCountSinceEntry, title="Bars Since Entry", color = color.rgb(7, 232, 187, 100))
if entrySignal_s
    barCountSinceEntry_s += 1
plot(barCountSinceEntry_s, title="Bars Since Entry", color = color.rgb(7, 232, 187, 100))

//makes the red and green line plot pretty at the position opening
if long_position_size == 0
    threshold := low[1]
if short_position_size == 0
    threshold_s := high[1]

// Calculate the threshold for long and short positions
threshold := initial_order - initial_order * price_deviation * math.pow(SO_step_scale, current_so - 1)
//threshold_s := initial_order_s * (1 + price_deviation * math.pow(SO_step_scale, current_so_s - 1))

//back to old code
//threshold := initial_order - initial_order * (price_deviation * (math.pow(SO_step_scale, current_so) - 1) / (SO_step_scale - 1))

threshold_s := initial_order_s * (1 + price_deviation * (math.pow(SO_step_scale, current_so_s) - 1) / (SO_step_scale - 1))



// Execute a long safety order if conditions are met
if current_so > 0 and
   long_position_size > 0 and 
   current_so < max_SOs and 
   not(hour(time) == 0 and minute(time) < 59) and 
   (recovery_mode ? barCountSinceEntry > waitBars_recovery : true) and
   (na(last_so_bar) or bar_index > last_so_bar + min_bars_between_sos) and 
   (trendUp_triggerSO ? trendUp : true) and
   (trendingUp_filterSO ? trendingUp : true) and 
   (above_ts_htf1_filterSO ? above_ts_htf1 : true) and
   (above_ts_htf2_filterSO ? above_ts_htf2 : true) and
   (above_ts_htf3_filterSO ? above_ts_htf3 : true) and
   (above_ts_htf4_filterSO ? above_ts_htf4 : true) and
   (twoBarUp_filterSO ? twobarup : true) and
   (Uselong_SO_trigger ? SO_trigger == long_SO_triggervalue : true) and
   (UseThreshold_long_SO ? low <= threshold : true)
    _string_long_so = ""
    if webhookMessage == "fdas"
        _string_long_so := 'type=order,order-type=long,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(SO_lots * so_multiplier * math.pow(SO_volume_scale, current_so - 1)) + ',comment="' + version + '-' + test + direction_text + '",entry=false'
    else if webhookMessage == "pineconnector"
        _string_long_so := str.tostring(ID) + ',long,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(SO_lots * so_multiplier * math.pow(SO_volume_scale, current_so - 1)) + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.order(longId, strategy.long, qty=(SO_lots * 100000) * so_multiplier * math.pow(SO_volume_scale, current_so - 1), comment="#" + str.tostring(long_sequence_counter) + "L SO " + str.tostring(current_so) + '@' + str.tostring(close), alert_message=_string_long_so)
    long_position_size := long_position_size + (SO_lots * 100000) * so_multiplier * math.pow(SO_volume_scale, current_so - 1)
    last_SO_execution_price := close
    last_so_bar_index := bar_index
    total_funds_in_trade := total_funds_in_trade + last_SO_execution_price * (SO_lots * 100000) * so_multiplier * math.pow(SO_volume_scale, current_so - 1)
    total_qty_in_trade := total_qty_in_trade + (SO_lots * 100000) * so_multiplier * math.pow(SO_volume_scale, current_so - 1)
    avg_price := total_funds_in_trade / total_qty_in_trade
    current_so += 1
    tradeCount += 1
    last_so_bar := bar_index // Update the bar index when an SO is executed
    log.info("#{0}L SO: Avg price after SO #{1} updated: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Long position size: {5}, Short position size: {6}, Safe order: {7}, SO multiplier: {8}, SO volume scale: {9}, Long TP Level: {10}", long_sequence_counter, (current_so - 1), avg_price, total_funds_in_trade, total_qty_in_trade, long_position_size, short_position_size, (SO_lots * 100000), so_multiplier, SO_volume_scale, take_profit_level)


// Execute a short safety order for short positions if conditions are met
if current_so_s > 0 and
   short_position_size < 0 and 
   current_so_s < max_SOs and 
   not(hour(time) == 0 and minute(time) < 59) and 
   (recovery_mode ? barCountSinceEntry_s > waitBars_recovery : true) and 
   (na(last_so_bar_s) or bar_index > last_so_bar_s + min_bars_between_sos) and
   (trendDown_triggerSO ? trendDown : true) and
   (trendingDown_filterSO ? trendingDown : true) and 
   (below_ts_htf1_filterSO ? below_ts_htf1 : true) and
   (below_ts_htf2_filterSO ? below_ts_htf2 : true) and
   (below_ts_htf3_filterSO ? below_ts_htf3 : true) and
   (below_ts_htf4_filterSO ? below_ts_htf4 : true) and
   (twoBarDown_filterSO ? twobardown : true) and
   (Use_SO_trigger_s ? SO_trigger_s == short_SO_triggervalue_s : true) and
   (UseThreshold_short_SO ? high >= threshold : true)
    _string_short_so = ""
    if webhookMessage == "fdas"
        _string_short_so := 'type=order,order-type=short,symbol=' + str.replace(syminfo.ticker, " ", "") + '.PRO' + ',risk=' + str.tostring(SO_lots * so_multiplier_s * math.pow(SO_volume_scale, current_so_s - 1)) + ',comment="' + version + '-' + test + direction_text + '",entry=false'
    else if webhookMessage == "pineconnector"
        _string_short_so := str.tostring(ID) + ',short,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(SO_lots * so_multiplier_s * math.pow(SO_volume_scale, current_so_s - 1)) + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.order(shortId, strategy.short, qty=(SO_lots * 100000) * so_multiplier_s * math.pow(SO_volume_scale, current_so_s - 1), comment="#" + str.tostring(short_sequence_counter) + "S SO " + str.tostring(current_so_s) + '@' + str.tostring(close), alert_message=_string_short_so)
    short_position_size := short_position_size - (SO_lots * 100000) * so_multiplier_s * math.pow(SO_volume_scale, current_so_s - 1)
    last_SO_execution_price_s := close
    last_so_bar_index_s := bar_index
    //total_funds_in_trade_s := total_funds_in_trade_s + last_SO_execution_price_s * (SO_lots * 100000) * so_multiplier_s * math.pow(SO_volume_scale, current_so_s - 1)
    total_funds_in_trade_s += threshold_s * (SO_lots * 100000) * math.pow(SO_volume_scale, current_so_s - 1)
    //total_qty_in_trade_s := total_qty_in_trade_s + (SO_lots * 100000) * so_multiplier_s * math.pow(SO_volume_scale, current_so_s - 1)
    total_qty_in_trade_s += (SO_lots * 100000) * so_multiplier_s * math.pow(SO_volume_scale, current_so_s - 1)
    avg_price_s := total_funds_in_trade_s / total_qty_in_trade_s
    current_so_s += 1
    tradeCount_s += 1
    last_so_bar_s := bar_index // Update the bar index when an SO is executed
    log.info("#{0}S SO: Avg price after SO #{1} updated: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Short position size: {5}, Safe order: {6}, SO multiplier: {7}, SO volume scale: {8}, Short TP Level: {9}, Short Threshold: {10}, tp_factor: {11}, atrp: {12}, close: {13}, price_deviation: {14}, current_so_s: {15}, entrySignal_s: {16}, barCountSinceEntry_s: {17}, take_profit: {18}", short_sequence_counter, (current_so_s - 1), avg_price_s, total_funds_in_trade_s, total_qty_in_trade_s, short_position_size, (SO_lots * 100000), so_multiplier_s, SO_volume_scale, take_profit_level_s, threshold_s, tp_factor, atrp, close, price_deviation, current_so_s, entrySignal_s, barCountSinceEntry_s, take_profit)


// // long boost order
// if useBoostLong and
//    long_position_size > 0 and
//    not(hour(time) == 0 and
//    minute(time) < 59) and 
//    (twobarup_boostCondition ? twobarup : true) and
//    (threebarup_boostCondition ? threebarup : true) and
//    barCountSinceEntry > 5 and
//    current_boost < max_boosts and
//    close[0] > avg_price + (take_profit_level - avg_price) * boost_percent_to_tp
//     _string_long_boost = ""
//     if webhookMessage == "fdas"
//         _string_long_boost := 'type=order,order-type=long,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots * BoostVolumeScale) + ',comment="' + version + '-' + test + direction_text + '",entry=false'
//     else if webhookMessage == "pineconnector"
//         _string_long_boost := str.tostring(ID) + ',long,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots * BoostVolumeScale) + ',comment="' + version + '-' + test + direction_text + '"'
//     strategy.order(longId, strategy.long, qty=(base_order_lots * 100000) * BoostVolumeScale, comment="#" + str.tostring(long_sequence_counter) + "L BO " + str.tostring(current_boost) + '@' + str.tostring(close), alert_message=_string_long_boost)
//     long_position_size := long_position_size + (base_order_lots * 100000) * BoostVolumeScale
//     last_BO_execution_price := close
//     last_bo_bar_index := bar_index
//     total_funds_in_trade := total_funds_in_trade + last_BO_execution_price * (base_order_lots * 100000) * BoostVolumeScale
//     total_qty_in_trade := total_qty_in_trade + (base_order_lots * 100000) * BoostVolumeScale
//     avg_price := total_funds_in_trade / total_qty_in_trade
//     current_boost += 1
//     tradeCount += 1
//     log.info("#{0}L Boost: Boost #{1} executed: Avg price: {2}, Total funds in trade: {3}, Total qty in trade: {4}, Long position size: {5}, Short position size: {6}, Boost order size: {7}, Boost volume scale: {8}, SO volume scale: {9}, Long TP Level: {10}", long_sequence_counter, current_boost, avg_price, total_funds_in_trade, total_qty_in_trade, long_position_size, short_position_size, (base_order_lots * 100000 * BoostVolumeScale), BoostVolumeScale, SO_volume_scale, take_profit_level)


// Take Profit / Exit Long %
if long_position_size > 0 and
   not(hour(time) == 0 and minute(time) < 59) and
   (
       (waitXbarsTPcondition and waitXbarsTP) or
       (TPbyPercentCondition_long and take_profit_level <= high) or
       (ExitByTrendChange_long and trendDown) or
       (ExitByTrendChangeHTF1_long and trendChangeDownHTF1) or
       (ExitByTrendChangeHTF2_long and trendChangeDownHTF2) or
       (ExitByTrendChangeHTF3_long and trendChangeDownHTF3) or
       (ExitByTrendChangeHTF4_long and trendChangeDownHTF4)
   )
    _string_close_long = ""
    if webhookMessage == "fdas"
        _string_close_long := 'type=order,order-type=closelong,symbol=' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + direction_text + '"'
    else if webhookMessage == "pineconnector"
        _string_close_long := str.tostring(ID) + ',closelong,' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.close(longId, comment="#" + str.tostring(long_sequence_counter) + "L Close @" + str.tostring(close), alert_message=_string_close_long)
    long_position_size := 0.0
    total_funds_in_trade := 0
    total_qty_in_trade := 0
    soCount := current_so // Save the current scale-out count
    current_so := 0 // Reset the current scale-out count
    original_ttp_value := 0 // Reset the original take profit value
    price_drop := na // Reset the price drop value
    initial_price := na // Reset the initial price
    diffDays := time - firstBarTime // Calculate the difference in days
    if diffDays > maxDiffDays // If the difference in days is greater than the maximum difference in days
        maxDiffDays := diffDays // Update the maximum difference in days
        longest_trade_day := dayofmonth // Update the longest trade day
        longest_trade_month := month // Update the longest trade month
        longest_trade_month
    //i := 1 // Reset the counter
    initial_order := 0.0 // Reset the initial order
    avg_price := 0 // Reset the average price
    capital *= (1 + total_qty_in_trade * take_profit / 100) // Update the capital
    entry_bar_index := na
    entrySignal := false
    last_avg_price := na
    current_boost := 0
    last_BO_execution_price := na
    last_bo_bar_index := na
    log.info("#{0}L Close: AVG price: {1}, Total funds in trade: {2}, Total qty in trade: {3}, Long position size: {4}, Take Profit Level: {5}", long_sequence_counter, avg_price, total_funds_in_trade, total_qty_in_trade, long_position_size, take_profit_level)

// Take Profit / Exit Short %
if short_position_size < 0 and
   not(hour(time) == 0 and minute(time) < 59) and
   (
       waitXbarsTPcondition_short or
       (TPbyPercentCondition_short and take_profit_level_s >= low) or
       (ExitByTrendChange_short and trendUp) or
       (ExitByTrendChangeHTF1_short and trendChangeUpHTF1) or
       (ExitByTrendChangeHTF2_short and trendChangeUpHTF2) or
       (ExitByTrendChangeHTF3_short and trendChangeUpHTF3) or
       (ExitByTrendChangeHTF4_short and trendChangeUpHTF4)
   )
    _string_close_short = ""
    if webhookMessage == "fdas"
        _string_close_short := 'type=order,order-type=closeshort,symbol=' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + direction_text + '"'
    else if webhookMessage == "pineconnector"
        _string_close_short := str.tostring(ID) + ',closeshort,' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + direction_text + '"'
    strategy.close(shortId, comment="#" + str.tostring(short_sequence_counter) + "S Close Short @" + str.tostring(close), alert_message=_string_close_short)
    short_position_size := 0.0 
    total_funds_in_trade_s := 0
    total_qty_in_trade_s := 0
    soCount_s := current_so_s // Save the current scale-out count
    current_so_s := 0 // Reset the current scale-out count
    price_pump_s := na // Reset the price pump value
    initial_price_s := na // Reset the initial short price
    diffDays_s := time - firstBarTime_s // Calculate the difference in days
    if diffDays_s > maxDiffDays_s // If the difference in days is greater than the maximum difference in days
        maxDiffDays_s := diffDays_s // Update the maximum difference in days
        longest_trade_day_s := dayofmonth // Update the longest trade day
        longest_trade_month_s := month // Update the longest trade month
    initial_order_s := 0.0 // Reset the initial short order
    avg_price_s := 0 // Reset the average short price
    capital_s *= (1 + total_qty_in_trade_s * take_profit / 100) // Update the capital
    entry_bar_index_s := na
    entrySignal_s := false
    log.info("#{0}S Close: AVG price: {1}, Total funds in trade: {2}, Total qty in trade: {3}, Short position size: {4}, Take Profit Level: {5}", short_sequence_counter, avg_price_s, total_funds_in_trade_s, total_qty_in_trade_s, short_position_size, take_profit_level_s)


//Table building and calculations
// longs
if long_position_size == 0
    if soCount == 1
        noSO += 1
        noSO
    else if soCount == 2
        SO1 += 1
        SO1
    else if soCount == 3
        SO2 += 1
        SO2
    else if soCount == 4
        SO3 += 1
        SO3
    else if soCount == 5
        SO4 += 1
        SO4
    else if soCount == 6
        SO5 += 1
        SO5
    else if soCount == 7
        SO6 += 1
        SO6
    else if soCount == 8
        SO7 += 1
        SO7
    soCount := 0
    soCount
closedTrades := noSO + SO1 * 2 + SO2 * 3 + SO3 * 4 + SO4 * 5 + SO5 * 6 + SO6 * 7 + SO7 * 8

// shorts
if short_position_size == 0
    if soCount_s == 1
        noSO_s += 1
        noSO_s
    else if soCount_s == 2
        SO1_s += 1
        SO1_s
    else if soCount_s == 3
        SO2_s += 1
        SO2_s
    else if soCount_s == 4
        SO3_s += 1
        SO3_s
    else if soCount_s == 5
        SO4_s += 1
        SO4_s
    else if soCount_s == 6
        SO5_s += 1
        SO5_s
    else if soCount_s == 7
        SO6_s += 1
        SO6_s
    else if soCount_s == 8
        SO7_s += 1
        SO7_s
    soCount_s := 0
    soCount_s
closedTrades_s := noSO_s + SO1_s * 2 + SO2_s * 3 + SO3_s * 4 + SO4_s * 5 + SO5_s * 6 + SO6_s * 7 + SO7_s * 8

if low < price_drop and window and long_position_size > 0
    price_drop := low
    if max_drop < int((1 - price_drop / initial_price) * 10000) / 100
        max_drop := int((1 - price_drop / initial_price) * 10000) / 100
        drop_date := dayofmonth(time)
        drop_month := month(time)
        drop_month
bgcolor(max_drop[1] < max_drop ? color.new(#0b5a64, 94) : na)

if high > price_pump_s and window and short_position_size < 0
    price_pump_s := high
    if max_pump_s < int((price_pump_s / initial_price_s - 1) * 10000) / 100
        max_pump_s := int((price_pump_s / initial_price_s - 1) * 10000) / 100
        pump_date := dayofmonth(time)
        pump_month := month(time)
        pump_month
bgcolor(max_pump_s[1] < max_pump_s ? color.new(#9b27b0, 89) : na)

if take_profit_level > 0 and long_position_size > 0
    tp_plot := take_profit_level
else
    tp_plot := close

if take_profit_level_s > 0 and short_position_size < 0
    tp_plot_s := take_profit_level_s
else
    tp_plot_s := close

// net profit
net_profit_long = ((capital / initial_capital) - 1) * 100
net_profit_short = ((capital_s / initial_capital) - 1) * 100

// Calculate the number of days since the first trades
days_since_first_long_trade = na(first_long_trade_time) ? na : math.round((time - first_long_trade_time) / (24 * 60 * 60 * 1000))
days_since_first_short_trade = na(first_short_trade_time) ? na : math.round((time - first_short_trade_time) / (24 * 60 * 60 * 1000))

// Define plots with conditional series and colors based on user input
p1 = plot(ShowTPPlot ? tp_plot : na, title='tp_plot', color=(ShowTPPlot and long_position_size > 0) ? #00FFD1 : na, style = plot.style_linebr)
p2 = plot(ShowAvgEntryPlot ? avg_price : na, title='avg_price', color=(ShowAvgEntryPlot and long_position_size[1] > 0 and avg_price > 0) ? color.rgb(177, 187, 189) : na, style = plot.style_circles)
p3 = plot(ShowSOPlot ? threshold : na, title='threshold', color=(ShowSOPlot and long_position_size[1] > 0) ? color.rgb(199, 0, 230, 42) : na)
p4 = plot(ShowTPPlot ? tp_plot_s : na, title='tp_plot_s', color=(ShowTPPlot and short_position_size[1] < 0) ? #00FFD1 : na, style = plot.style_steplinebr)
p5 = plot(ShowSOPlot ? threshold_s : na, title='threshold_s', color=(ShowSOPlot and short_position_size[1] < 0) ? color.rgb(199, 0, 230, 47) : na)
p6 = plot(ShowAvgEntryPlot ? avg_price_s : na, title='avg_price_s', color=(ShowAvgEntryPlot and short_position_size[1] < 0 and avg_price_s > 0) ? color.rgb(177, 187, 189) : na, style = plot.style_circles)

// Use fill() at the global scope
// fill(p1, p2, color=(ShowTPPlot and ShowAvgEntryPlot and long_position_size > 0 and avg_price > 0) ? color.new(#00bbd4, 93) : na)
// fill(p2, p3, color=(ShowAvgEntryPlot and ShowSOPlot and long_position_size[1] > 0) ? color.new(#df40fb, 93) : na) 
// fill(p4, p6, color=(ShowTPPlot and ShowAvgEntryPlot and short_position_size[1] < 0) ? color.new(#00bbd4, 92) : na) 
// fill(p5, p6, color=(ShowSOPlot and ShowAvgEntryPlot and short_position_size[1] < 0) ? color.new(#ff5252, 94) : na) 

profit_color = strategy.openprofit < 0 ? bearish : bullish
text_size = text_size_switch ? size.small : size.normal

var tbb = TTBTableBuilder.new(position.top_right,7,2)
if barstate.isconfirmed
	header = tbb.R(0).TextColor(color.rgb(18, 247, 255)).TextSize(size.small).Font(font.family_monospace)
	header.Text("HTF2","HTF3","HTF4","ATRP","ATRP_HTF1","AVG ATR","ATR10")
    tbb.R(1).TextColor(color.white).TextSize(size.small).Text(str.tostring(trendstatusHTF2),str.tostring(trendstatusHTF3),str.tostring(trendstatusHTF4),str.tostring(atrp_htf1),str.tostring(atrp_htf2),str.tostring(atrp_htf3),str.tostring(atrp_htf4),str.tostring(avg_atr),"?").Bg(color.rgb(255, 255, 255, 74))
	// tbb.R(2).TextColor(color.white).TextSize(size.small).Text("A","B","C")

color rowBG = color.rgb(29, 29, 29, 9)
color tableText = color.rgb(223, 222, 222, 9)

if show_table
    var tbb2 = TTBTableBuilder.new(position.bottom_right, 3, 18) // Adjust position and size as needed
    if barstate.isconfirmed
        header2 = tbb2.R(0).TextColor(color.rgb(18, 247, 255)).TextSize(size.small).Font(font.family_monospace)
        header2.Text("Metric", "Longs", "Shorts") // Replace with your column headers
        tbb2.R(1).TextColor(tableText).TextSize(size.small).Text("Net Profit", str.tostring(net_profit_long) + '%', str.tostring(net_profit_short) + '%').Bg(rowBG)
        tbb2.R(2).TextColor(color.rgb(150, 152, 158)).TextSize(size.small).Text("Max Deviation", str.tostring(maxDev) + '%', str.tostring(maxDev_s) + '%').Bg(rowBG)
        tbb2.R(3).TextColor(tableText).TextSize(size.small).Text("No SO", str.tostring(noSO), str.tostring(noSO_s)).Bg(rowBG)
        tbb2.R(4).TextColor(tableText).TextSize(size.small).Text("SO 1", str.tostring(SO1), str.tostring(SO1_s)).Bg(rowBG)
        tbb2.R(5).TextColor(tableText).TextSize(size.small).Text("SO 2", str.tostring(SO2), str.tostring(SO2_s)).Bg(rowBG)
        tbb2.R(6).TextColor(tableText).TextSize(size.small).Text("SO 3", str.tostring(SO3), str.tostring(SO3_s)).Bg(rowBG)
        tbb2.R(7).TextColor(tableText).TextSize(size.small).Text("SO 4", str.tostring(SO4), str.tostring(SO4_s)).Bg(rowBG)
        tbb2.R(8).TextColor(tableText).TextSize(size.small).Text("SO 5", str.tostring(SO5), str.tostring(SO5_s)).Bg(rowBG)
        tbb2.R(9).TextColor(tableText).TextSize(size.small).Text("SO 6", str.tostring(SO6), str.tostring(SO6_s)).Bg(rowBG)
        tbb2.R(10).TextColor(tableText).TextSize(size.small).Text("SO 7", str.tostring(SO7), str.tostring(SO7_s)).Bg(rowBG)
        tbb2.R(11).TextColor(tableText).TextSize(size.small).Text("Closed/Open trades", str.tostring(closedTrades) + '/' + str.tostring(strategy.opentrades), str.tostring(closedTrades_s) + '/' + str.tostring(strategy.opentrades)).Bg(rowBG)
        tbb2.R(12).TextColor(tableText).TextSize(size.small).Text("Current Deal Time", long_position_size != 0 ? str.tostring(int((time - firstBarTime) / 8640000) / 10) + ' days' : '0', short_position_size != 0 ? str.tostring(int((time - firstBarTime) / 8640000) / 10) + ' days' : '0').Bg(rowBG)
        tbb2.R(13).TextColor(tableText).TextSize(size.small).Text("Unrealized position", str.tostring(int(strategy.openprofit / (strategy.initial_capital + strategy.netprofit) * 10000) / 100) + ' %', str.tostring(int(strategy.openprofit / (strategy.initial_capital + strategy.netprofit) * 10000) / 100) + ' %').Bg(rowBG)
        tbb2.R(14).TextColor(tableText).TextSize(size.small).Text("Longest deal:", str.tostring(int(maxDiffDays / 8640000) / 10) + ' days, ' + str.tostring(longest_trade_day) + '/' + str.tostring(longest_trade_month), str.tostring(int(maxDiffDays_s / 8640000) / 10) + ' days, ' + str.tostring(longest_trade_day_s) + '/' + str.tostring(longest_trade_month_s)).Bg(rowBG)
        tbb2.R(15).TextColor(tableText).TextSize(size.small).Text("Max price drop:", str.tostring(max_drop) + ' %, ' + str.tostring(drop_date) + '/' + str.tostring(drop_month), "na").Bg(rowBG)
        tbb2.R(16).TextColor(tableText).TextSize(size.small).Text("Max price pump:", "na", str.tostring(max_pump_s) + ' %, ' + str.tostring(pump_date_s) + '/' + str.tostring(pump_month_s)).Bg(rowBG)
