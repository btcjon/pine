[{
  "text": "Pine Script™ v5 User Manual\nTable Of Contents\nWelcome to Pine Script™ v5\nPine Script™ primer\nFirst steps\nFirst indicator\nNext steps\nLanguage\nConcepts\nWriting scripts\nFAQ\nError messages\nRelease notes\nMigration guides\nWhere can I get more information?"
},
{
  "text": "First steps¶\nIntroduction\nUsing scripts\nLoading scripts from the chart\nBrowsing Community Scripts\nChanging script settings\nReading scripts\nWriting scripts\nIntroduction¶\nWelcome to the Pine Script™ v5 User Manual, which will accompany you in your journey to learn to program your own trading tools in Pine Script™. Welcome also to the very active community of Pine Script™ programmers on TradingView.\nIn this page, we present a step-by-step approach that you can follow to gradually become more familiar with indicators and strategies (also called scripts) written in the Pine Script™ programming language on TradingView. We will get you started on your journey to:\nUse some of the tens of thousands of existing scripts on the platform.\nRead the Pine Script™ code of existing scripts.\nWrite Pine Script™ scripts.\nIf you are already familiar with the use of Pine scripts on TradingView and are now ready to learn how to write your own, then jump to the Writing scripts section of this page.\nIf you are new to our platform, then please read on!\nUsing scripts¶\nIf you are interested in using technical indicators or strategies on TradingView, you can first start exploring the thousands of indicators already available on our platform. You can access existing indicators on the platform in two different ways:\nBy using the chart’s “Indicators & Strategies” button, or\nBy browsing TradingView’s Community Scripts, the largest repository of trading scripts in the world, with more than 100,000 scripts, most of which are free and open-source, which means you can see their Pine Script™ code.\nIf you can find the tools you need already written for you, it can be a good way to get started and gradually become proficient as a script user, until you are ready to start your programming journey in Pine Script™.\nLoading scripts from the chart¶\nTo explore and load scripts from you chart, use the “Indicators & Strategies” button:\nThe dialog box presents different categories of scripts in its left pane:\nFavorites lists the scripts you have “favorited” by clicking on the star that appears to the left of its name when you mouse over it.\nMy scripts displays the scipts you have written and saved in the Pine Editor. They are saved in TradingView’s cloud.\nBuilt-ins groups all TradingVIew built-ins organized in four categories: indicators, strategies, candlestick patterns and volume profiles. Most are written in Pine Script™ and available for free.\nCommunity Scripts is where you can search from the 100,000+ published scripts written by TradingView users.\nInvite-only scripts contains the list of the invite-only scripts you have been granted access to by their authors.\nHere, the section containing the TradingView built-ins is selected:\nWhen you click on one of the indicators or strategies (the ones with the green and red arrows following their name), it loads on your chart.\nChanging script settings¶\nOnce a script is loaded on the chart, you can double-click on its name (#1) to bring up its “Settings/Inputs” tab (#2):\nThe “Inputs” tab allows you to change the settings which the script’s author has decided to make editable. You can configure some of the script’s visuals using the “Style” tab of the same dialog box, and which timeframes the script should appear on using the “Visibility” tab.\nOther settings are available to all scripts from the buttons that appear to the right of its name when you mouse over it, and from the “More” menu (the three dots):\nReading scripts¶\nReading code written by good programmers is the best way to develop your understanding of the language. This is as true for Pine Script™ as it is for all other programming languages. Finding good open-source Pine Script™ code is relatively easy. These are reliable sources of code written by good programmers on TradingView:\nThe TradingView built-in indicators\nScripts selected as Editors’ Picks\nScripts by the authors the PineCoders account follows\nMany scripts by authors with high reputation and open-source publications.\nReading code from Community Scripts is easy; if you don’t see a grey or red “lock” icon in the upper-right corner of the script’s widget, this indicates the script is open-source. By opening its script page, you will be able to see its source.\nTo see the code of TradingView built-ins, load the indicator on your chart, then hover over its name and select the “Source code” curly braces icon (if you don’t see it, it’s because the indicator’s source is unavailable). When you click on the icon, the Pine Editor will open and from there, you can see the script’s code. If you want to play with it, you will need to use the Editor’s “More” menu button at the top-right of the Editor’s pane, and select “Make a copy…”. You will then be able to modify and save the code. Because you will have created a different version of the script, you will need to use the Editor’s “Add to Chart” button to add that new copy to the chart.\nThis shows the Pine Editor having just opened after we selected the “View source” button from the indicator on our chart. We are about to make a copy of its source because it is read-only for now (indicated by the “lock” icon near its filename in the Editor):\nYou can also open TradingView built-in indicators from the Pine Editor (accessible from the “Pine Editor” tab at the bottom of the chart) by using the “Open/New default built-in script…” menu selection.\nWriting scripts¶\nWe have built Pine Script™ to empower both budding and seasoned traders to create their own trading tools. We have designed it so it is relatively easy to learn for first-time programmers — although learning a first programming language, like trading, is rarely very easy for anyone — yet powerful enough for knowledgeable programmers to build tools of moderate complexity.\nPine Script™ allows you to write three types of scripts:\nIndicators like RSI, MACD, etc.\nStrategies which include logic to issue trading orders and can be backtested and forward-tested.\nLibraries which are used by more advanced programmers to package oft-used functions that can be reused by other scripts.\nThe next step we recommend is to write your first indicator."
},
{
  "text": "Pine Script™ is TradingView’s programming language. It allows traders to create their own trading tools and run them on our servers. We designed Pine Script™ as a lightweight, yet powerful, language for developing indicators and strategies that you can then backtest. Most of TradingView’s built-in indicators are written in Pine Script™, and our thriving community of Pine Script™ programmers has published more than 100,000 Community Scripts.\nIt’s our explicit goal to keep Pine Script™ accessible and easy to understand for the broadest possible audience. Pine Script™ is cloud-based and therefore different from client-side programming languages. While we likely won’t develop Pine Script™ into a full-fledged language, we do constantly improve it and are always happy to consider requests for new features.\nBecause each script uses computational resources in the cloud, we must impose limits in order to share these resources fairly among our users. We strive to set as few limits as possible, but will of course have to implement as many as needed for the platform to run smoothly. Limitations apply to the amount of data requested from additional symbols, execution time, memory usage and script size."
},
{
  "text": "Search\nFrom here you can search these documents. Enter your search words into the box below and click \"search\". Note that the search function will automatically search for all of the words. Pages containing fewer words won't appear in the result list."
},
{
  "text": "Pine Script™ v5 User Manual\nTable Of Contents\nWelcome to Pine Script™ v5\nPine Script™ primer\nLanguage\nConcepts\nWriting scripts\nFAQ\nError messages\nRelease notes\nMigration guides\nWhere can I get more information?"
},
{
  "text": "User Manual\nIndex\nIndex\nR \nR\nright (built-in class), [1]"
},
{
  "text": "First indicator¶\nThe Pine Editor\nFirst version\nSecond version\nNext\nThe Pine Editor¶\nThe Pine Editor is where you will be working on your scripts. While you can use any text editor you want to write your Pine scripts, using our Editor has many advantages:\nIt highlights your code following Pine Script™ syntax.\nIt pops up syntax reminders for built-in and library functions when you hover over them.\nIt provides quick access to the Pine Script™ v5 Reference Manual popup when you ctrl + click / cmd + click on Pine Script™ keywords.\nIt provides an auto-complete feature that you can activate with ctrl + space / cmd + space.\nIt makes the write/compile/run cycle fast because saving a new version of a script loaded on the chart also executes it immediately.\nWhile not as feature-rich as the top editors out there, it provides key functionality such as search and replace, multi-cursor and versioning.\nTo open the Editor, click on the “Pine Editor” tab at the bottom of your TradingView chart. This will open up the Editor’s pane.\nFirst version¶\nWe will now create our first working Pine script, an implementation of the MACD indicator in Pine Script™:\n\t\n//@version=5\nindicator(\"MACD #1\")\nfast = 12\nslow = 26\nfastMA = ta.ema(close, fast)\nslowMA = ta.ema(close, slow)\nmacd = fastMA - slowMA\nsignal = ta.ema(macd, 9)\nplot(macd, color = color.blue)\nplot(signal, color = color.orange)\n\n\t\nStart by bringing up the “Open” dropdown menu at the top right of the Editor and choose “New blank indicator”.\nThen copy the example script above, taking care not to include the line numbers in your selection.\nSelect all the code already in the editor and replace it with the example script.\nClick “Save” and choose a name for your script. Your script is now saved in TradingView’s cloud, but under your account’s name. Nobody but you can use it.\nClick “Add to Chart” in the Editor’s menu bar. The MACD indicator appears in a separate Pane under your chart.\nYour first Pine script is running on your chart, which should look like this:\nLet’s look at our script’s code, line by line:\nLine 1: //@version=5 This is a compiler annotation telling the compiler the script will use version 5 of Pine Script™. Line 2: indicator(\"MACD #1\") Defines the name of the script that will appear on the chart as “MACD”. Line 3: fast = 12 Defines a fast integer variable which will be the length of the fast EMA. Line 4: slow = 26 Defines a slow integer variable which will be the length of the slow EMA. Line 5: fastMA = ta.ema(close, fast) Defines the variable fastMA, containing the result of the EMA calculation (Exponential Moving Average) with a length equal to fast (12), on the close series, i.e., the closing price of bars. Line 6: slowMA = ta.ema(close, slow) Defines the variable slowMA, containing the result of the EMA calculation with a length equal to slow (26), from close. Line 7: macd = fastMA - slowMA Defines the variable macd as the difference between the two EMAs. Line 8: signal = ta.ema(macd, 9) Defines the variable signal as a smoothed value of macd using the EMA algorithm (Exponential Moving Average) with a length of 9. Line 9: plot(macd, color = color.blue) Calls the plot function to output the variable macd using a blue line. Line 10: plot(signal, color = color.orange) Calls the plot function to output the variable signal using an orange line. \nSecond version¶\nThe first version of our script calculated MACD “manually”, but because Pine Script™ is designed to write indicators and strategies, built-in Pine Script™ functions exist for many common indicators, including one for… MACD: ta.macd().\nThis is the second version of our script:\n\t\n//@version=5\nindicator(\"MACD #2\")\nfastInput = input(12, \"Fast length\")\nslowInput = input(26, \"Slow length\")\n[macdLine, signalLine, histLine] = ta.macd(close, fastInput, slowInput, 9)\nplot(macdLine, color = color.blue)\nplot(signalLine, color = color.orange)\n\n\t\nNote that we have:\nAdded inputs so we can change the lengths for the MAs\nWe now use the ta.macd() built-in to calculate our MACD, which saves us three line and makes our code easier to read.\nLet’s repeat the same process as before to copy that code in a new indicator:\nStart by bringing up the “Open” dropdown menu at the top right of the Editor and choose “New blank indicator”.\nThen copy the example script above, again taking care not to include the line numbers in your selection.\nSelect all the code already in the editor and replace it with the second version of our script.\nClick “Save” and choose a name for your script different than the previous one.\nClick “Add to Chart” in the Editor’s menu bar. The “MACD #2” indicator appears in a separate Pane under the “MACD #1” indicator.\nYour second Pine script is running on your chart. If you double-click on the indicator’s name on your chart, you will bring up the script’s “Settings/Inputs” tab, where you can now change the slow and fast lengths:\nLet’s look at the lines that have changed in the second version of our script:\nLine 2: indicator(\"MACD #2\") We have changed #1 to #2 so the second version of our indicator displays a different name on the chart. Line 3: fastInput = input(12, \"Fast length\") Instead of assigning a constant value to a variable, we have used the input() function so we can change the value in our script’s “Settings/Inputs” tab. 12 will be the default value and the field’s label will be \"Fast length\". If the value is changed in the “Inputs” tab, the fastInput variable’s content will contain the new value and the script will re-execute on the chart with that new value. Note that, as our Pine Script™ Style Guide recommends, we add Input to the end of the variable’s name to remind us, later in the script, that its value comes from a user input. Line 4: slowInput = input(26, \"Slow length\") We do the same for the slow length, taking care to use a different variable name, default value and text string for the field’s label. Line 5: [macdLine, signalLine, histLine] = ta.macd(close, fastInput, slowInput, 9) This is where we call the ta.macd() built-in to perform all the first version’s calculations in one line only. The function requires four parameters (the values after the function name, enclosed in parentheses). It returns three values into the three variables instead of only one, like the functions we used until now, which is why we need to enclose the list of three variables receiving the function’s result in square brackets, to the left of the = sign. Note that two of the values we pass to the function are the “input” variables containing the fast and slow lengths: fastInput and slowInput. Line 6 and 7: The variable names we are plotting there have changed, but the lines are doing the same thing as in our first version. \nOur second version performs the same calculations as our first, but we can change the two lengths used to calculate it. Our code is also simpler and shorter by three lines. We have improved our script."
},
{
  "text": "Next steps¶\n“indicators” vs “strategies”\nHow scripts are executed\nTime series\nPublishing scripts\nGetting around the Pine Script™ documentation\nWhere to go from here?\nAfter your first steps and your first indicator, let us explore a bit more of the Pine Script™ landscape by sharing some pointers to guide you in your journey to learn Pine Script™.\n“indicators” vs “strategies”¶\nPine Script™ strategies are used to backtest on historical data and forward test on open markets. In addition to indicator calculations, they contain strategy.*() calls to send trade orders to Pine Script™’s broker emulator, which can then simulate their execution. Strategies display backtest results in the “Strategy Tester” tab at the bottom of the chart, next to the “Pine Editor” tab.\nPine Script™ indicators also contain calculations, but cannot be used in backtesting. Because they do not require the broker emulator, they use less resources and will run faster. It is thus advantageous to use indicators whenever you can.\nBoth indicators and strategies can run in either overlay mode (over the chart’s bars) or pane mode (in a separate section below or above the chart). Both can also plot information in their respective space, and both can generate alert events.\nHow scripts are executed¶\nA Pine script is not like programs in many programming languages that execute once and then stop. In the Pine Script™ runtime environment, a script runs in the equivalent of an invisible loop where it is executed once on each bar of whatever chart you are on, from left to right. Chart bars that have already closed when the script executes on them are called historical bars. When execution reaches the chart’s last bar and the market is open, it is on the realtime bar. The script then executes once every time a price or volume change is detected, and one last time for that realtime bar when it closes. That realtime bar then becomes an elapsed realtime bar. Note that when the script executes in realtime, it does not recalculate on all the chart’s historical bars on every price/volume update. It has already calculated once on those bars, so it does not need to recalculate them on every chart tick. See the Execution model page for more information.\nWhen a script executes on a historical bar, the close built-in variable holds the value of that bar’s close. When a script executes on the realtime bar, close returns the current price of the symbol until the bar closes.\nContrary to indicators, strategies normally execute only once on realtime bars, when they close. They can also be configured to execute on each price/volume update if that is what you need. See the page on Strategies for more information, and to understand how strategies calculate differently than indicators.\nTime series¶\nThe main data structure used in Pine Script™ is called a time series. Time series contain one value for each bar the script executes on, so they continuously expand as the script executes on more bars. Past values of the time series can be referenced using the history-referencing operator: []. close[1], for example, refers to the value of close on the bar preceding the one where the script is executing.\nWhile this indexing mechanism may remind many programmers of arrays, a time series is different and thinking in terms of arrays will be detrimental to understanding this key Pine Script™ concept. A good comprehension of both the execution model and time series is essential in understanding how Pine scripts work. If you have never worked with data organized in time series before, you will need practice to put them to work for you. Once you familiarize yourself with these key concepts, you will discover that by combining the use of time series with our built-in functions specifically designed to handle them efficiently, much can be accomplished in very few lines of code.\nPublishing scripts¶\nTradingView is home to a large community of Pine Script™ programmers and millions of traders from all around the world. Once you become proficient enough in Pine Script™, you can choose to share your scripts with other traders. Before doing so, please take the time to learn Pine Script™ well-enough to supply traders with an original and reliable tool. All publicly published scripts are analyzed by our team of moderators and must comply with our Script Publishing Rules, which require them to be original and well-documented.\nIf want to use Pine scripts for your own use, simply write them in the Pine Editor and add them to your chart from there; you don’t have to publish them to use them. If you want to share your scripts with just a few friends, you can publish them privately and send your friends the browser’s link to your private publication. See the page on Publishing for more information.\nGetting around the Pine Script™ documentation¶\nWhile reading code from published scripts is no doubt useful, spending time in our documentation will be necessary to attain any degree of proficiency in Pine Script™. Our two main sources of documentation on Pine Script™ are:\nThis Pine Script™ v5 User Manual\nOur Pine Script™ v5 Reference Manual\nThe Pine Script™ v5 User Manual is in HTML format and in English only.\nThe Pine Script™ v5 Reference Manual documents what each variable, function or keyword does. It is an essential tool for all Pine Script™ programmers; your life will be miserable if you try to write scripts of any reasonable complexity without consulting it. It exists in two formats: the HTML format we just linked to, and the popup version, which can be accessed from the Pine Editor, by either ctrl + clicking on a keyword, or by using the Editor’s “More/Pine Script™ reference (pop-up)” menu. The Reference Manual is translated in other languages.\nThere are five different versions of Pine Script™. Ensure the documentation you use corresponds to the Pine Script™ version you are coding with.\nWhere to go from here?¶\nThis Pine Script™ v5 User Manual contains numerous examples of code used to illustrate the concepts we discuss. By going through it, you will be able to both learn the foundations of Pine Script™ and study the example scripts. Reading about key concepts and trying them out right away with real code is a productive way to learn any programming language. As you hopefully have already done in the First indicator page, copy this documentation’s examples in the Editor and play with them. Explore! You won’t break anything.\nThis is how the Pine Script™ v5 User Manual you are reading is organized:\nThe Language section explains the main components of the Pine Script™ language and how scripts execute.\nThe Concepts section is more task-oriented. It explains how to do things in Pine Script™.\nThe Writing section explores tools and tricks that will help you write and publish scripts.\nThe FAQ section answers common questions from Pine Script™ programmers.\nThe Error messages page documents causes and fixes for the most common runtime and compiler errors.\nThe Release Notes page is where you can follow the frequent updates to Pine Script™.\nThe Migration guides section explains how to port between different versions of Pine Script™.\nThe Where can I get more information page lists other useful Pine Script™-related content, including where to ask questions when you are stuck on code.\nWe wish you a successful journey with Pine Script™… and trading!"
},
{
  "text": "Pine Script™ v5 User Manual\nTable Of Contents\nWelcome to Pine Script™ v5\nPine Script™ primer\nLanguage\nExecution model\nTime series\nScript structure\nIdentifiers\nOperators\nVariable declarations\nConditional structures\nLoops\nType system\nBuilt-ins\nUser-defined functions\nObjects\nMethods\nArrays\nMatrices\nMaps\nConcepts\nWriting scripts\nFAQ\nError messages\nRelease notes\nMigration guides\nWhere can I get more information?"
},
{
  "text": "Pine Script™ v5 User Manual\nTable Of Contents\nWelcome to Pine Script™ v5\nPine Script™ primer\nLanguage\nConcepts\nAlerts\nBackgrounds\nBar coloring\nBar plotting\nBar states\nChart information\nColors\nFills\nInputs\nLevels\nLibraries\nLines and boxes\nNon-standard charts data\nOther timeframes and data\nPlots\nRepainting\nSessions\nStrategies\nTables\nText and shapes\nTime\nTimeframes\nFAQ\nError messages\nRelease notes\nMigration guides\nWhere can I get more information?"
},
{
  "text": "Style guide\nDebugging\nPublishing scripts\nLimitations"
},
{
  "text": "FAQ¶\nGet real OHLC price on a Heikin Ashi chart\nGet non-standard OHLC values on a standard chart\nPlot arrows on the chart\nPlot a dynamic horizontal line\nPlot a vertical line on condition\nAccess the previous value\nGet a 5-days high\nCount bars in a dataset\nEnumerate bars in a day\nFind the highest and lowest values for the entire dataset\nQuery the last non-na value\nGet real OHLC price on a Heikin Ashi chart¶\nSuppose, we have a Heikin Ashi chart (or Renko, Kagi, PriceBreak etc) and we’ve added a Pine script on it:\n//@version=5\nindicator(\"Visible OHLC\", overlay=true)\nc = close\nplot(c)\n\nYou may see that variable c is a Heikin Ashi close price which is not the same as real OHLC price. Because close built-in variable is always a value that corresponds to a visible bar (or candle) on the chart.\nSo, how do we get the real OHLC prices in Pine Script™ code, if current chart type is non-standard? We should use request.security function in combination with ticker.new function. Here is an example:\n//@version=5\nindicator(\"Real OHLC\", overlay = true)\nt = ticker.new(syminfo.prefix, syminfo.ticker)\nrealC = request.security(t, timeframe.period, close)\nplot(realC)\n\nIn a similar way we may get other OHLC prices: open, high and low.\nGet non-standard OHLC values on a standard chart¶\nBacktesting on non-standard chart types (e.g. Heikin Ashi or Renko) is not recommended because the bars on these kinds of charts do not represent real price movement that you would encounter while trading. If you want your strategy to enter and exit on real prices but still use Heikin Ashi-based signals, you can use the same method to get Heikin Ashi values on a regular candlestick chart:\nstrategy(\"BarUpDn Strategy\", overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 10)\nmaxIdLossPcntInput = input.float(1, \"Max Intraday Loss(%)\")\nstrategy.risk.max_intraday_loss(maxIdLossPcntInput, strategy.percent_of_equity)\nneedTrade() => close > open and open > close[1] ? 1 : close < open and open < close[1] ? -1 : 0\ntrade = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, needTrade())\nif trade == 1\nstrategy.entry(\"BarUp\", strategy.long)\nif trade == -1\nstrategy.entry(\"BarDn\", strategy.short)\nPlot arrows on the chart¶\nYou may use plotshape with style shape.arrowup and shape.arrowdown:\nindicator('Ex 1', overlay = true)\ncondition = close >= open\nplotshape(condition, color = color.lime, style = shape.arrowup, text = \"Buy\")\nplotshape(not condition, color = color.red, style = shape.arrowdown, text = \"Sell\")\nYou may use the plotchar function with any unicode character:\nindicator('buy/sell arrows', overlay = true)\ncondition = close >= open\nplotchar(not condition, char='↓', color = color.lime, text = \"Buy\")\nplotchar(condition, char='↑', location = location.belowbar, color = color.red, text = \"Sell\")\nPlot a dynamic horizontal line¶\nThere is the function hline in Pine Script™, but it is limited to only plot a constant value. Here is a simple script with a workaround to plot a changing hline:\nindicator(\"Horizontal line\", overlay = true)\nplot(close[10], trackprice = true, offset = -9999)\n// `trackprice = true` plots horizontal line on close[10]\n// `offset = -9999` hides the plot\nplot(close, color = #FFFFFFFF) // forces display\nPlot a vertical line on condition¶\nindicator(\"Vertical line\", overlay = true, scale = scale.none)\n// scale.none means do not resize the chart to fit this plot\n// if the bar being evaluated is the last baron the chart (the most recent bar), then cond is true\ncond = barstate.islast\n// when cond is true, plot a histogram with a line with height value of 100,000,000,000,000,000,000.00\n// (10 to the power of 20)\n// when cond is false, plot no numeric value (nothing is plotted)\n// use the style of histogram, a vertical bar\nplot(cond ? 10e20 : na, style = plot.style_histogram)\nAccess the previous value¶\n//...\ns = 0.0\ns := nz(s[1]) // Accessing previous values\nif (condition)\ns := s + 1\nGet a 5-days high¶\nLookback 5 days from the current bar, find the highest bar, plot a star character at that price level above the current bar\nindicator(\"High of last 5 days\", overlay = true)\n// Milliseconds in 5 days: millisecs * secs * mins * hours * days\nMS_IN_5DAYS = 1000 * 60 * 60 * 24 * 5\n// The range check begins 5 days from the current time.\nleftBorder = timenow - time < MS_IN_5DAYS\n// The range ends on the last bar of the chart.\nrightBorder = barstate.islast\n// ————— Keep track of highest `high` during the range.\n// Intialize `maxHi` with `var` on bar zero only.\n// This way, its value is preserved, bar to bar.\nvar float maxHi = na\nif leftBorder\nif not leftBorder[1]\n// Range's first bar.\nmaxHi := high\nelse if not rightBorder\n// On other bars in the range, track highest `high`.\nmaxHi := math.max(maxHi, high)\n// Plot level of the highest `high` on the last bar.\nplotchar(rightBorder ? maxHi : na, \"Level\", \"—\", location.absolute, size = size.normal)\n// When in range, color the background.\nbgcolor(leftBorder and not rightBorder ? color.new(color.aqua, 70) : na)\nCount bars in a dataset¶\nGet a count of all the bars in the loaded dataset. Might be useful for calculating flexible lookback periods based on number of bars.\nindicator(\"Bar Count\", overlay = true, scale = scale.none)\nplot(bar_index + 1, style = plot.style_histogram)\nEnumerate bars in a day¶\nindicator(\"My Script\", overlay = true, scale = scale.none)\nisNewDay() =>\nd = dayofweek\nna(d[1]) or d != d[1]\nplot(ta.barssince(isNewDay()), style = plot.style_cross)\nFind the highest and lowest values for the entire dataset¶\nindicator(\"\", \"\", true)\nallTimetHi(source) =>\nvar atHi = source\natHi := math.max(atHi, source)\nallTimetLo(source) =>\nvar atLo = source\natLo := math.min(atLo, source)\nplot(allTimetHi(close), \"ATH\", color.green)\nplot(allTimetLo(close), \"ATL\", color.red)\nQuery the last non-na value¶\nYou can use the script below to avoid gaps in a series:\nindicator(\"\")\nseries = close >= open ? close : na\nvw = fixnan(series)\nplot(series, style = plot.style_linebr, color = color.red) // series has na values\nplot(vw) // all na values are replaced with the last non-empty value"
},
{
  "text": "Error messages¶\nThe if statement is too long\nScript requesting too many securities\nScript could not be translated from: null\nline 2: no viable alternative at character ‘$’\nMismatched input <…> expecting <???>\nLoop is too long (> 500 ms)\nScript has too many local variables\nPine Script™ cannot determine the referencing length of a series. Try using max_bars_back in the indicator or strategy function\nThe if statement is too long¶\nThis error occurs when the indented code inside an if statement is too large for the compiler. Because of how the compiler works, you won’t receive a message telling you exactly how many lines of code you are over the limit. The only solution now is to break up your if statement into smaller parts (functions or smaller if statements). The example below shows a reasonably lengthy if statement; theoretically, this would throw line 4: if statement is too long:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nindicator(\"My script\")\nvar e = 0\nif barstate.islast\na = 1\nb = 2\nc = 3\nd = 4\ne := a + b + c + d\nplot(e)\nTo fix this code, you could move these lines into their own function:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nindicator(\"My script\")\nvar e = 0\ndoSomeWork() =>\na = 1\nb = 2\nc = 3\nd = 4\nresult = a + b + c + d\nif barstate.islast\ne := doSomeWork()\nplot(e)\nScript requesting too many securities¶\nThe maximum number of securities in script is limited to 40. If you declare a variable as a request.security function call and then use that variable as input for other variables and calculations, it will not result in multiple request.security calls. But if you will declare a function that calls request.security — every call to this function will count as a request.security call.\nIt is not easy to say how many securities will be called looking at the source code. Following example have exactly 3 calls to request.security after compilation:\nindicator(\"Securities count\")\na = request.security(syminfo.tickerid, '42', close) // (1) first unique security call\nb = request.security(syminfo.tickerid, '42', close) // same call as above, will not produce new security call after optimizations\nplot(a)\nplot(a + 2)\nplot(b)\nsym(p) => // no security call on this line\nrequest.security(syminfo.tickerid, p, close)\nplot(sym('D')) // (2) one indirect call to security\nplot(sym('W')) // (3) another indirect call to security\nrequest.security(syminfo.tickerid, timeframe.period, open) // result of this line is never used, and will be optimized out\nScript could not be translated from: null¶\nUsually this error occurs in version 1 Pine scripts, and means that code is incorrect. Pine Script™ of version 2 (and higher) is better at explaining errors of this kind. So you can try to switch to version 2 by adding a special attribute in the first line. You’ll get line 2: no viable alternative at character '$':\nline 2: no viable alternative at character ‘$’¶\nThis error message gives a hint on what is wrong. $ stands in place of string with script title. For example:\n// @version=2\nstudy(\"title\")\nMismatched input <…> expecting <???>¶\nSame as no viable alternative, but it is known what should be at that place. Example:\nindicator(\"My Script\")\nplot(1)\nline 3: mismatched input 'plot' expecting 'end of line without line continuation'\nTo fix this you should start line with plot on a new line without an indent:\nindicator(\"My Script\")\nplot(1)\nLoop is too long (> 500 ms)¶\nWe limit the computation time of loop on every historical bar and realtime tick to protect our servers from infinite or very long loops. This limit also fail-fast indicators that will take too long to compute. For example, if you’ll have 5000 bars, and indicator takes 500 milliseconds to compute on each of bars, it would have result in more than 16 minutes of loading:\nindicator(\"Loop is too long\", max_bars_back = 101)\ns = 0\nfor i = 1 to 1e3 // to make it longer\nfor j = 0 to 100\nif timestamp(2017, 02, 23, 00, 00) <= time[j] and time[j] < timestamp(2017, 02, 23, 23, 59)\ns := s + 1\nplot(s)\nIt might be possible to optimize algorithm to overcome this error. In this case, algorithm may be optimized like this:\nindicator(\"Loop is too long\", max_bars_back = 101)\nbar_back_at(t) =>\ni = 0\nstep = 51\nfor j = 1 to 100\nif i < 0\ni := 0\nbreak\nif step == 0\nbreak\nif time[i] >= t\ni := i + step\ni\nelse\ni := i - step\ni\nstep := step / 2\nstep\ni\ns = 0\nfor i = 1 to 1e3 // to make it longer\ns := s - bar_back_at(timestamp(2017, 02, 23, 23, 59)) +\nbar_back_at(timestamp(2017, 02, 23, 00, 00))\ns\nplot(s)\nScript has too many local variables¶\nThis error appears if the script is too large to be compiled. A statement var=expression creates a local variable for var. Apart from this, it is important to note, that auxiliary variables can be implicitly created during the process of a script compilation. The limit applies to variables created both explicitly and implicitly. The limitation of 1000 variables is applied to each function individually. In fact, the code placed in a global scope of a script also implicitly wrapped up into the main function and the limit of 1000 variables becomes applicable to it. There are few refactorings you can try to avoid this issue:\nvar1 = expr1\nvar2 = expr2\nvar3 = var1 + var2\ncan be converted into:\nPine Script™ cannot determine the referencing length of a series. Try using max_bars_back in the indicator or strategy function¶\nThe error appears in cases where Pine Script™ wrongly autodetects the required maximum length of series used in a script. This happens when a script’s flow of execution does not allow Pine Script™ to inspect the use of series in branches of conditional statements (if, iff or ?), and Pine Script™ cannot automatically detect how far back the series is referenced. Here is an example of a script causing this problem:\nindicator(\"Requires max_bars_back\")\ntest = 0.0\nif bar_index > 1000\ntest := ta.roc(close, 20)\nplot(test)\nIn order to help Pine Script™ with detection, you should add the max_bars_back parameter to the script’s indicator or strategy function:\nindicator(\"Requires max_bars_back\", max_bars_back = 20)\ntest = 0.0\nif bar_index > 1000\ntest := ta.roc(close, 20)\nplot(test)\nYou may also resolve the issue by taking the problematic expression out of the conditional branch, in which case the max_bars_back parameter is not required:\nindicator(\"My Script\")\ntest = 0.0\nroc20 = ta.roc(close, 20)\nif bar_index > 1000\ntest := roc20\nplot(test)\nIn cases where the problem is caused by a variable rather than a built-in function (vwma in our example), you may use the max_bars_back function to explicitly define the referencing length for that variable only. This has the advantage of requiring less runtime resources, but entails that you identify the problematic variable, e.g., variable s in the following example:\nindicator(\"My Script\")\nf(off) =>\nt = 0.0\ns = close\nif bar_index > 242\nt := s[off]\nt\nplot(f(301))\nThis situation can be resolved using the max_bars_back function to define the referencing length of variable s only, rather than for all the script’s variables:\nf(off) =>\nt = 0.0\ns = close\nmax_bars_back(s, 301)\nif bar_index > 242\nt := s[off]\nt\nplot(f(301))\nWhen using drawings that refer to previous bars through bar_index[n] and xloc = xloc.bar_index, the time series received from this bar will be used to position the drawings on the time axis. Therefore, if it is impossible to determine the correct size of the buffer, this error may occur. To avoid this, you need to use max_bars_back(time, n). This behavior is described in more detail in the section about drawings."
},
{
  "text": "Release notes¶\n2023\nDecember 2023\nNovember 2023\nOctober 2023\nPine Script™ Polylines\nSeptember 2023\nAugust 2023\nPine Script™ Maps\nJuly 2023\nJune 2023\nMay 2023\nApril 2023\nMarch 2023\nFebruary 2023\nPine Script™ Methods\nJanuary 2023\n2022\nDecember 2022\nPine Objects\nNovember 2022\nOctober 2022\nSeptember 2022\nAugust 2022\nJuly 2022\nJune 2022\nMay 2022\nApril 2022\nMarch 2022\nTable merging and cell tooltips\nFebruary 2022\nJanuary 2022\n2021\nDecember 2021\nLinefills\nNew functions for string manipulation\nTextboxes\nNew built-in variables\nNovember 2021\nfor…in\nFunction overloads\nCurrency conversion\nOctober 2021\nNew features\nChanges\nSeptember 2021\nJuly 2021\nJune 2021\nMay 2021\nApril 2021\nMarch 2021\nFebruary 2021\nJanuary 2021\n2020\nDecember 2020\nNovember 2020\nOctober 2020\nSeptember 2020\nAugust 2020\nJuly 2020\nJune 2020\nMay 2020\nApril 2020\nMarch 2020\nFebruary 2020\nJanuary 2020\n2019\nDecember 2019\nOctober 2019\nSeptember 2019\nJuly-August 2019\nJune 2019\n2018\nOctober 2018\nApril 2018\n2017\nAugust 2017\nJune 2017\nMay 2017\nApril 2017\nMarch 2017\nFebruary 2017\n2016\nDecember 2016\nOctober 2016\nSeptember 2016\nJuly 2016\nMarch 2016\nFebruary 2016\nJanuary 2016\n2015\nOctober 2015\nSeptember 2015\nJuly 2015\nJune 2015\nApril 2015\nMarch 2015\nFebruary 2015\n2014\nAugust 2014\nJuly 2014\nJune 2014\nApril 2014\nFebruary 2014\n2013\nThis page contains release notes of notable changes in Pine Script™.\n2023¶\nDecember 2023¶\nWe’ve added format and precision parameters to all plot*() functions, allowing indicators and strategies to selectively apply formatting and decimal precision settings to plotted results in the chart pane’s y-axis, the script’s status line, and the Data Window. The arguments passed to these parameters supersede the values in the indicator() and strategy() functions. Both are optional. The defaults for these parameters are the same as the values specified in the script’s declaration statement.\nFor example:\nindicator(\"My script\", format = format.percent, precision = 4)\nplot(close, format = format.price) // Price format with 4-digit precision.\nplot(100 * bar_index / close, precision = 2) // Percent format with 2-digit precision.\nNovember 2023¶\nWe’ve added the following variables and functions to the strategy.* namespace:\nstrategy.grossloss_percent - The total gross loss value of all completed losing trades, expressed as a percentage of the initial capital.\nstrategy.grossprofit_percent - The total gross profit value of all completed winning trades, expressed as a percentage of the initial capital.\nstrategy.max_runup_percent - The maximum rise from a trough in the equity curve, expressed as a percentage of the trough value.\nstrategy.max_drawdown_percent - The maximum drop from a peak in the equity curve, expressed as a percentage of the peak value.\nstrategy.netprofit_percent - The total value of all completed trades, expressed as a percentage of the initial capital.\nstrategy.openprofit_percent - The current unrealized profit or loss for all open positions, expressed as a percentage of realized equity.\nstrategy.closedtrades.max_drawdown_percent() - Returns the maximum drawdown of the closed trade, i.e., the maximum possible loss during the trade, expressed as a percentage.\nstrategy.closedtrades.max_runup_percent() - Returns the maximum run-up of the closed trade, i.e., the maximum possible profit during the trade, expressed as a percentage.\nstrategy.closedtrades.profit_percent() - Returns the profit/loss value of the closed trade, expressed as a percentage. Losses are expressed as negative values.\nstrategy.opentrades.max_drawdown_percent() - Returns the maximum drawdown of the open trade, i.e., the maximum possible loss during the trade, expressed as a percentage.\nstrategy.opentrades.max_runup_percent() - Returns the maximum run-up of the open trade, i.e., the maximum possible profit during the trade, expressed as a percentage.\nstrategy.opentrades.profit_percent() - Returns the profit/loss of the open trade, expressed as a percentage. Losses are expressed as negative values.\nOctober 2023¶\nPine Script™ Polylines¶\nPolylines are drawings that sequentially connect the coordinates from an array of up to 10,000 chart points using straight or curved line segments, allowing scripts to draw custom formations that are difficult or impossible to achieve using line or box objects. To learn more about this new drawing type, see the Polylines section of our User Manual’s page on Lines and boxes.\nSeptember 2023¶\nNew functions were added:\nstrategy.default_entry_qty() - Calculates the default quantity, in units, of an entry order from strategy.entry() or strategy.order() if it were to fill at the specified fill_price value.\nchart.point.new() - Creates a new chart.point object with the specified time, index, and price.\nrequest.seed() - Requests data from a user-maintained GitHub repository and returns it as a series. An in-depth tutorial on how to add new data can be found here.\nticker.inherit() - Constructs a ticker ID for the specified symbol with additional parameters inherited from the ticker ID passed into the function call, allowing the script to request a symbol’s data using the same modifiers that the from_tickerid has, including extended session, dividend adjustment, currency conversion, non-standard chart types, back-adjustment, settlement-as-close, etc.\ntimeframe.from_seconds() - Converts a specified number of seconds into a valid timeframe string based on our timeframe specification format.\nThe dividends.* namespace now includes variables for retrieving future dividend information:\ndividends.future_amount - Returns the payment amount of the upcoming dividend in the currency of the current instrument, or na if this data isn’t available.\ndividends.future_ex_date - Returns the Ex-dividend date (Ex-date) of the current instrument’s next dividend payment, or na if this data isn’t available.\ndividends.future_pay_date - Returns the Payment date (Pay date) of the current instrument’s next dividend payment, or na if this data isn’t available.\nThe request.security_lower_tf() function has a new parameter:\nignore_invalid_timeframe - Determines how the function behaves when the chart’s timeframe is smaller than the timeframe value in the function call. If false, the function will raise a runtime error and halt the script’s execution. If true, the function will return na without raising an error.\nUsers can now explicitly declare variables with the const, simple, and series type qualifiers, allowing more precise control over the types of variables in their scripts. For example:\nindicator(\"My script\")\n//@variable A constant `string` used as the `title` in the `plot()` function.\nconst string plotTitle = \"My plot\"\n//@variable An `int` variable whose value is consistent after the first chart bar.\nsimple int a = 10\n//@variable An `int` variable whose value can change on every bar.\nseries int b = bar_index\nplot(b % a, title = plotTitle)\nAugust 2023¶\nAdded the following alert placeholders:\n{{syminfo.currency}} - Returns the currency code of the current symbol (“EUR”, “USD”, etc.).\n{{syminfo.basecurrency}} - Returns the base currency code of the current symbol if the symbol refers to a currency pair. Otherwise, it returns na. For example, it returns “EUR” when the symbol is “EURUSD”.\nPine Script™ Maps¶\nMaps are collections that hold elements in the form of key-value pairs. They associate unique keys of a fundamental type with values of a built-in or user-defined type. Unlike arrays and matrices, these collections are unordered and do not utilize an internal lookup index. Instead, scripts access the values of maps by referencing the keys from the key-value pairs put into them. For more information on these new collections, see our User Manual’s page on Maps.\nJuly 2023¶\nFixed an issue that caused strategies to occasionally calculate the sizes of limit orders incorrectly due to improper tick rounding of the limit price.\nAdded a new built-in variable to the strategy.* namespace:\nstrategy.margin_liquidation_price - When a strategy uses margin, returns the price value after which a margin call will occur.\nJune 2023¶\nNew syminfo.* built-in variables were added:\nsyminfo.sector - Returns the sector of the symbol.\nsyminfo.industry - Returns the industry of the symbol.\nsyminfo.country - Returns the two-letter code of the country where the symbol is traded.\nMay 2023¶\nNew parameter added to the strategy.entry(), strategy.order(), strategy.close(), strategy.close_all(), and strategy.exit() functions:\ndisable_alert - Disables order fill alerts for any orders placed by the function.\nOur “Indicator on indicator” feature, which allows a script to pass another indicator’s plot as a source value via the input.source() function, now supports multiple external inputs. Scripts can use a multitude of external inputs originating from up to 10 different indicators.\nWe’ve added the following array functions:\narray.every() - Returns true if all elements of the id array are true, false otherwise.\narray.some() - Returns true if at least one element of the id array is true, false otherwise.\nThese functions also work with arrays of int and float types, in which case zero values are considered false, and all others true.\nApril 2023¶\nFixed an issue with trailing stops in strategy.exit() being filled on high/low prices rather than on intrabar prices.\nFixed behavior of array.mode(), matrix.mode() and ta.mode(). Now these functions will return the smallest value when the data has no most frequent value.\nFebruary 2023¶\nPine Script™ Methods¶\nPine Script™ methods are specialized functions associated with specific instances of built-in or user-defined types. They offer a more convenient syntax than standard functions, as users can access methods in the same way as object fields using the handy dot notation syntax. Pine Script™ includes built-in methods for array, matrix, line, linefill, label, box, and table types and facilitates user-defined methods with the new method keyword. For more details on this new feature, see our User Manual’s page on methods.\nJanuary 2023¶\nNew array functions were added:\narray.first() - Returns the array’s first element.\narray.last() - Returns the array’s last element.\n2022¶\nDecember 2022¶\nPine Objects¶\nPine objects are instantiations of the new user-defined composite types (UDTs) declared using the type keyword. Experienced programmers can think of UDTs as method-less classes. They allow users to create custom types that organize different values under one logical entity. A detailed rundown of the new functionality can be found in our User Manual’s page on objects.\nA new function was added:\nticker.standard() - Creates a ticker to request data from a standard chart that is unaffected by modifiers like extended session, dividend adjustment, currency conversion, and the calculations of non-standard chart types: Heikin Ashi, Renko, etc.\nNew strategy.* functions were added:\nstrategy.opentrades.entry_comment() - The function returns the comment message of the open trade’s entry.\nstrategy.closedtrades.entry_comment() - The function returns the comment message of the closed trade’s entry.\nstrategy.closedtrades.exit_comment() - The function returns the comment message of the closed trade’s exit.\nOctober 2022¶\nPine Script™ now has a new, more powerful and better-integrated editor. Read our blog to find out everything to know about all the new features and upgrades.\nNew overload for the fill() function was added. Now it can create vertical gradients. More info about it in the blog post.\nA new function was added:\nstr.format_time() - Converts a timestamp to a formatted string using the specified format and time zone.\nAugust 2022¶\nA new label style label.style_text_outline was added.\nA new parameter for the ta.pivot_point_levels() function was added:\ndeveloping - If false, the values are those calculated the last time the anchor condition was true. They remain constant until the anchor condition becomes true again. If true, the pivots are developing, i.e., they constantly recalculate on the data developing between the point of the last anchor (or bar zero if the anchor condition was never true) and the current bar. Cannot be true when type is set to \"Woodie\".\nA new parameter for the box.new() function was added:\ntext_wrap - It defines whether the text is presented in a single line, extending past the width of the box if necessary, or wrapped so every line is no wider than the box itself.\nThis parameter supports two arguments:\ntext.wrap_none - Disabled wrapping mode for box.new and box.set_text_wrap functions.\ntext.wrap_auto - Automatic wrapping mode for box.new and box.set_text_wrap functions.\nNew built-in functions were added:\nta.min() - Returns the all-time low value of source from the beginning of the chart up to the current bar.\nta.max() - Returns the all-time high value of source from the beginning of the chart up to the current bar.\nA new annotation //@strategy_alert_message was added. If the annotation is added to the strategy, the text written after it will be automatically set as the default alert message in the Create Alert window.\n// @strategy_alert_message My Default Alert Message\nstrategy(\"My Strategy\")\nplot(close)\nJuly 2022¶\nIt is now possible to fine-tune where a script’s plot values are displayed through the introduction of new arguments for the display parameter of the plot(), plotchar(), plotshape(), plotarrow(), plotcandle(), and plotbar() functions.\nFour new arguments were added, complementing the previously available display.all and display.none:\ndisplay.data_window displays the plot values in the Data Window, one of the items available from the chart’s right sidebar.\ndisplay.pane displays the plot in the pane where the script resides, as defined in with the overlay parameter of the script’s indicator(), strategy(), or library() declaration statement.\ndisplay.price_scale controls the display of the plot’s label and price in the price scale, if the chart’s settings allow them.\ndisplay.status_line displays the plot values in the script’s status line, next to the script’s name on the chart, if the chart’s settings allow them.\nThe display parameter supports the addition and subtraction of its arguments:\ndisplay.all - display.status_line will display the plot’s information everywhere except in the script’s status line.\ndisplay.price_scale + display.status_line will display the plot in the price scale and status line only.\nJune 2022¶\nThe behavior of the argument used with the qty_percent parameter of strategy.exit() has changed. Previously, the percentages used on successive exit orders of the same position were calculated from the remaining position at any given time. Instead, the percentages now always apply to the initial position size. When executing the following strategy, for example:\nstrategy(\"strategy.exit() example\", overlay = true)\nstrategy.entry(\"Long\", strategy.long, qty = 100)\nstrategy.exit(\"Exit Long1\", \"Long\", trail_points = 50, trail_offset = 0, qty_percent = 20)\nstrategy.exit(\"Exit Long2\", \"Long\", trail_points = 100, trail_offset = 0, qty_percent = 20)\n20% of the initial position will be closed on each strategy.exit() call. Before, the first call would exit 20% of the initial position, and the second would exit 20% of the remaining 80% of the position, so only 16% of the initial position.\nTwo new parameters for the built-in ta.vwap() function were added:\nanchor - Specifies the condition that triggers the reset of VWAP calculations. When true, calculations reset; when false, calculations proceed using the values accumulated since the previous reset.\nstdev_mult - If specified, the ta.vwap() calculates the standard deviation bands based on the main VWAP series and returns a [vwap, upper_band, lower_band] tuple.\nNew overloaded versions of the strategy.close() and strategy.close_all() functions with the immediately parameter. When immediately is set to true, the closing order will be executed on the tick where it has been placed, ignoring the strategy parameters that restrict the order execution to the open of the next bar.\nNew built-in functions were added:\ntimeframe.change() - Returns true on the first bar of a new timeframe, false otherwise.\nta.pivot_point_levels() - Returns a float array with numerical values representing 11 pivot point levels: [P, R1, S1, R2, S2, R3, S3, R4, S4, R5, S5]. Levels absent from the specified type return na values.\nNew built-in variables were added:\nsession.isfirstbar - returns true if the current bar is the first bar of the day’s session, false otherwise.\nsession.islastbar - returns true if the current bar is the last bar of the day’s session, false otherwise.\nsession.isfirstbar_regular - returns true on the first regular session bar of the day, false otherwise.\nsession.islastbar_regular - returns true on the last regular session bar of the day, false otherwise.\nchart.left_visible_bar_time - returns the time of the leftmost bar currently visible on the chart.\nchart.right_visible_bar_time - returns the time of the rightmost bar currently visible on the chart.\nMay 2022¶\nMatrix support has been added to the request.security() function.\nThe historical states of arrays and matrices can now be referenced with the [] operator. In the example below, we reference the historic state of a matrix 10 bars ago:\nindicator(\"matrix.new<float> example\")\nm = matrix.new<float>(1, 1, close)\nfloat x = na\nif bar_index > 10\nx := matrix.get(m[10], 0, 0)\nplot(x)\nplot(close)\nThe ta.change() function now can take values of int and bool types as its source parameter and return the difference in the respective type.\nNew built-in variables were added:\nchart.bg_color - Returns the color of the chart’s background from the \"Chart settings/Appearance/Background\" field.\nchart.fg_color - Returns a color providing optimal contrast with chart.bg_color.\nchart.is_standard - Returns true if the chart type is bars, candles, hollow candles, line, area or baseline, false otherwise.\ncurrency.USDT - A constant for the Tether currency code.\nNew functions were added:\nsyminfo.prefix() - returns the exchange prefix of the symbol passed to it, e.g. “NASDAQ” for “NASDAQ:AAPL”.\nsyminfo.ticker() - returns the ticker of the symbol passed to it without the exchange prefix, e.g. “AAPL” for “NASDAQ:AAPL”.\nrequest.security_lower_tf() - requests data from a lower timeframe than the chart’s.\nAdded use_bar_magnifier parameter for the strategy() function. When true, the Broker Emulator uses lower timeframe data during history backtesting to achieve more realistic results.\nFixed behaviour of strategy.exit() function when stop loss triggered at prices outside the bars price range.\nAdded new comment and alert message parameters for the strategy.exit() function:\ncomment_profit - additional notes on the order if the exit was triggered by crossing profit or limit specifically.\ncomment_loss - additional notes on the order if the exit was triggered by crossing stop or loss specifically.\ncomment_trailing - additional notes on the order if the exit was triggered by crossing trail_offset specifically.\nalert_profit - text that will replace the '{{strategy.order.alert_message}}' placeholder if the exit was triggered by crossing profit or limit specifically.\nalert_loss - text that will replace the '{{strategy.order.alert_message}}' placeholder if the exit was triggered by crossing stop or loss specifically.\nalert_trailing - text that will replace the '{{strategy.order.alert_message}}' placeholder if the exit was triggered by crossing trail_offset specifically.\nApril 2022¶\nAdded the display parameter to the following functions: barcolor, bgcolor, fill, hline.\nA new function was added:\nrequest.economic() - Economic data includes information such as the state of a country’s economy or of a particular industry.\nNew built-in variables were added:\nstrategy.max_runup - Returns the maximum equity run-up value for the whole trading interval.\nsyminfo.volumetype - Returns the volume type of the current symbol.\nchart.is_heikinashi - Returns true if the chart type is Heikin Ashi, false otherwise.\nchart.is_kagi - Returns true if the chart type is Kagi, false otherwise.\nchart.is_linebreak - Returns true if the chart type is Line break, false otherwise.\nchart.is_pnf - Returns true if the chart type is Point & figure, false otherwise.\nchart.is_range - Returns true if the chart type is Range, false otherwise.\nchart.is_renko - Returns true if the chart type is Renko, false otherwise.\nNew matrix functions were added:\nmatrix.new<type> - Creates a new matrix object. A matrix is a two-dimensional data structure containing rows and columns. All elements in the matrix must be of the type specified in the type template (“<type>”).\nmatrix.row() - Creates a one-dimensional array from the elements of a matrix row.\nmatrix.col() - Creates a one-dimensional array from the elements of a matrix column.\nmatrix.get() - Returns the element with the specified index of the matrix.\nmatrix.set() - Assigns value to the element at the column and row index of the matrix.\nmatrix.rows() - Returns the number of rows in the matrix.\nmatrix.columns() - Returns the number of columns in the matrix.\nmatrix.elements_count() - Returns the total number of matrix elements.\nmatrix.add_row() - Adds a row to the matrix. The row can consist of na values, or an array can be used to provide values.\nmatrix.add_col() - Adds a column to the matrix. The column can consist of na values, or an array can be used to provide values.\nmatrix.remove_row() - Removes the row of the matrix and returns an array containing the removed row’s values.\nmatrix.remove_col() - Removes the column of the matrix and returns an array containing the removed column’s values.\nmatrix.swap_rows() - Swaps the rows in the matrix.\nmatrix.swap_columns() - Swaps the columns in the matrix.\nmatrix.fill() - Fills a rectangular area of the matrix defined by the indices from_column to to_column.\nmatrix.copy() - Creates a new matrix which is a copy of the original.\nmatrix.submatrix() - Extracts a submatrix within the specified indices.\nmatrix.reverse() - Reverses the order of rows and columns in the matrix. The first row and first column become the last, and the last become the first.\nmatrix.reshape() - Rebuilds the matrix to rows x cols dimensions.\nmatrix.concat() - Append one matrix to another.\nmatrix.sum() - Returns a new matrix resulting from the sum of two matrices, or of a matrix and a scalar (a numerical value).\nmatrix.diff() - Returns a new matrix resulting from the subtraction between matrices, or of matrix and a scalar (a numerical value).\nmatrix.mult() - Returns a new matrix resulting from the product between the matrices, or between a matrix and a scalar (a numerical value), or between a matrix and a vector (an array of values).\nmatrix.sort() - Rearranges the rows in the id matrix following the sorted order of the values in the column.\nmatrix.avg() - Calculates the average of all elements in the matrix.\nmatrix.max() - Returns the largest value from the matrix elements.\nmatrix.min() - Returns the smallest value from the matrix elements.\nmatrix.median() - Calculates the median (“the middle” value) of matrix elements.\nmatrix.mode() - Calculates the mode of the matrix, which is the most frequently occurring value from the matrix elements. When there are multiple values occurring equally frequently, the function returns the smallest of those values.\nmatrix.pow() - Calculates the product of the matrix by itself power times.\nmatrix.det() - Returns the determinant of a square matrix.\nmatrix.transpose() - Creates a new, transposed version of the matrix by interchanging the row and column index of each element.\nmatrix.pinv() - Returns the pseudoinverse of a matrix.\nmatrix.inv() - Returns the inverse of a square matrix.\nmatrix.rank() - Calculates the rank of the matrix.\nmatrix.trace() - Calculates the trace of a matrix (the sum of the main diagonal’s elements).\nmatrix.eigenvalues() - Returns an array containing the eigenvalues of a square matrix.\nmatrix.eigenvectors() - Returns a matrix of eigenvectors, in which each column is an eigenvector of the matrix.\nmatrix.kron() - Returns the Kronecker product for the two matrices.\nmatrix.is_zero() - Determines if all elements of the matrix are zero.\nmatrix.is_identity() - Determines if a matrix is an identity matrix (elements with ones on the main diagonal and zeros elsewhere).\nmatrix.is_binary() - Determines if the matrix is binary (when all elements of the matrix are 0 or 1).\nmatrix.is_symmetric() - Determines if a square matrix is symmetric (elements are symmetric with respect to the main diagonal).\nmatrix.is_antisymmetric() - Determines if a matrix is antisymmetric (its transpose equals its negative).\nmatrix.is_diagonal() - Determines if the matrix is diagonal (all elements outside the main diagonal are zero).\nmatrix.is_antidiagonal() - Determines if the matrix is anti-diagonal (all elements outside the secondary diagonal are zero).\nmatrix.is_triangular() - Determines if the matrix is triangular (if all elements above or below the main diagonal are zero).\nmatrix.is_stochastic() - Determines if the matrix is stochastic.\nmatrix.is_square() - Determines if the matrix is square (it has the same number of rows and columns).\nAdded a new parameter for the strategy() function:\nrisk_free_rate - The risk-free rate of return is the annual percentage change in the value of an investment with minimal or zero risk, used to calculate the Sharpe and Sortino ratios.\nMarch 2022¶\nNew array functions were added:\narray.sort_indices() - returns an array of indices which, when used to index the original array, will access its elements in their sorted order.\narray.percentrank() - returns the percentile rank of a value in the array.\narray.percentile_nearest_rank() - returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method.\narray.percentile_linear_interpolation() - returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation.\narray.abs() - returns an array containing the absolute value of each element in the original array.\narray.binary_search() - returns the index of the value, or -1 if the value is not found.\narray.binary_search_leftmost() - returns the index of the value if it is found or the index of the next smallest element to the left of where the value would lie if it was in the array.\narray.binary_search_rightmost() - returns the index of the value if it is found or the index of the element to the right of where the value would lie if it was in the array.\nAdded a new optional nth parameter for the array.min() and array.max() functions.\nAdded index in for..in operator. It tracks the current iteration’s index.\nFebruary 2022¶\nAdded templates and the ability to create arrays via templates. Instead of using one of the array.new_*() functions, a template function array.new<type> can be used. In the example below, we use this functionality to create an array filled with float values:\nindicator(\"array.new<float> example\")\nlength = 5\nvar a = array.new<float>(length, close)\nif array.size(a) == length\narray.remove(a, 0)\narray.push(a, close)\nplot(array.sum(a) / length, \"SMA\")\nNew functions were added:\ntimeframe.in_seconds(timeframe) - converts the timeframe passed to the timeframe argument into seconds.\ninput.text_area() - adds multiline text input area to the Script settings.\nstrategy.closedtrades.entry_id() - returns the id of the closed trade’s entry.\nstrategy.closedtrades.exit_id() - returns the id of the closed trade’s exit.\nstrategy.opentrades.entry_id() - returns the id of the open trade’s entry.\n2021¶\nDecember 2021¶\nNew functions for string manipulation¶\nAdded a number of new functions that provide more ways to process strings, and introduce regular expressions to Pine Script™:\nstr.contains(source, str) - Determines if the source string contains the str substring.\nstr.pos(source, str) - Returns the position of the str string in the source string.\nstr.substring(source, begin_pos, end_pos) - Extracts a substring from the source string.\nstr.replace(source, target, replacement, occurrence) - Contrary to the existing str.replace_all() function, str.replace() allows the selective replacement of a matched substring with a replacement string.\nstr.lower(source) and str.upper(source) - Convert all letters of the source string to lower or upper case:\nstr.startswith(source, str) and str.endswith(source, str) - Determine if the source string starts or ends with the str substring.\nstr.match(source, regex) - Extracts the substring matching the specified regular expression.\nTextboxes¶\nBox drawings now supports text. The box.new() function has five new parameters for text manipulation: text, text_size, text_color, text_valign, and text_halign. Additionally, five new functions to set the text properties of existing boxes were added:\nbox.set_text()\nbox.set_text_color()\nbox.set_text_size()\nbox.set_text_valign()\nbox.set_text_halign()\nNew built-in variables¶\nAdded new built-in variables that return the bar_index and time values of the last bar in the dataset. Their values are known at the beginning of the script’s calculation:\nlast_bar_index - Bar index of the last chart bar.\nlast_bar_time - UNIX time of the last chart bar.\nNew built-in source variable:\nhlcc4 - A shortcut for (high + low + close + close)/4. It averages the high and low values with the double-weighted close.\nNovember 2021¶\nfor…in¶\nAdded a new for…in operator to iterate over all elements of an array:\nint[] a1 = array.from(1, 3, 6, 3, 8, 0, -9, 5)\nhighest(array) =>\nvar int highestNum = na\nfor item in array\nif na(highestNum) or item > highestNum\nhighestNum := item\nhighestNum\nplot(highest(a1))\nFunction overloads¶\nAdded function overloads. Several functions in a script can now share the same name, as long one of the following conditions is true:\nEach overload has a different number of parameters:\nindicator(\"Function overload\")\n// Two parameters\nmult(x1, x2) =>\nx1 * x2\n// Three parameters\nmult(x1, x2, x3) =>\nx1 * x2 * x3\nplot(mult(7, 4))\nplot(mult(7, 4, 2))\nWhen overloads have the same number of parameters, all parameters in each overload must be explicitly typified, and their type combinations must be unique:\nindicator(\"Function overload\")\n// Accepts both 'int' and 'float' values - any 'int' can be automatically cast to 'float'\nmult(float x1, float x2) =>\nx1 * x2\n// Returns a 'bool' value instead of a number\nmult(bool x1, bool x2) =>\nx1 and x2 ? true : false\nmult(string x1, string x2) =>\nstr.tonumber(x1) * str.tonumber(x2)\n// Has three parameters, so explicit types are not required\nmult(x1, x2, x3) =>\nx1 * x2 * x3\nplot(mult(7, 4))\nplot(mult(7.5, 4.2))\nplot(mult(true, false) ? 1 : 0)\nplot(mult(\"5\", \"6\"))\nplot(mult(7, 4, 2))\nOctober 2021¶\nPine Script™ v5 is here! This is a list of the new features added to the language, and a few of the changes made. See the Pine Script™ v5 Migration guide for a complete list of the changes in v5.\nChanges¶\nMany built-in variables, functions and function arguments were renamed or moved to new namespaces in v5. The venerable study(), for example, is now indicator(), and security() is now request.security(). New namespaces now group related functions and variables together. This consolidation implements a more rational nomenclature and provides an orderly space to accommodate the many additions planned for Pine Script™.\nSee the Pine Script™ v5 Migration guide for a complete list of the changes made in v5.\nSeptember 2021¶\nNew parameter has been added for the dividends(), earnings(), financial(), quandl(), security(), and splits() functions:\nignore_invalid_symbol - determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue.\nJuly 2021¶\ntostring now accepts “bool” and “string” types.\nNew argument for time and time_close functions was added:\ntimezone - timezone of the session argument, can only be used when a session is specified. Can be written out in GMT notation (e.g. “GMT-5”) or as an IANA time zone database name (e.g. “America/New_York”).\nIt is now possible to place a drawing object in the future with xloc = xloc.bar_index.\nNew argument for study and strategy functions was added:\nexplicit_plot_zorder - specifies the order in which the indicator’s plots, fills, and hlines are rendered. If true, the plots will be drawn based on the order in which they appear in the indicator’s code, each newer plot being drawn above the previous ones.\nJune 2021¶\nNew variable was added:\nbarstate.islastconfirmedhistory - returns true if script is executing on the dataset’s last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise.\nNew function was added:\nround_to_mintick(x) - returns the value rounded to the symbol’s mintick, i.e. the nearest value that can be divided by syminfo.mintick, without the remainder, with ties rounding up.\nExpanded tostring() functionality. The function now accepts three new formatting arguments:\nformat.mintick to format to tick precision.\nformat.volume to abbreviate large values.\nformat.percent to format percentages.\nMay 2021¶\nImproved backtesting functionality by adding the Leverage mechanism.\nAdded support for table drawings and functions for working with them. Tables are unique objects that are not anchored to specific bars; they float in a script’s space, independently of the chart bars being viewed or the zoom factor used. For more information, see the Tables User Manual page.\nNew functions were added:\ncolor.rgb(red, green, blue, transp) - creates a new color with transparency using the RGB color model.\ncolor.from_gradient(value, bottom_value, top_value, bottom_color, top_color) - returns color calculated from the linear gradient between bottom_color to top_color.\ncolor.r(color), color.g(color), color.b(color), color.t(color) - retrieves the value of one of the color components.\narray.from() - takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table and returns an array of the corresponding type.\nA new box drawing has been added to Pine Script™, making it possible to draw rectangles on charts using the Pine Script™ syntax. For more details see the Pine Script™ reference and the Lines and boxes User Manual page.\nThe color.new function can now accept series and input arguments, in which case, the colors will be calculated at runtime. For more information about this, see our Colors User Manual page.\nApril 2021¶\nNew math constants were added:\nmath.pi - is a named constant for Archimedes’ constant. It is equal to 3.1415926535897932.\nmath.phi - is a named constant for the golden ratio. It is equal to 1.6180339887498948.\nmath.rphi - is a named constant for the golden ratio conjugate. It is equal to 0.6180339887498948.\nmath.e - is a named constant for Euler’s number. It is equal to 2.7182818284590452.\nNew math functions were added:\nround(x, precision) - returns the value of x rounded to the nearest integer, with ties rounding up. If the precision parameter is used, returns a float value rounded to that number of decimal places.\nmedian(source, length) - returns the median of the series.\nmode(source, length) - returns the mode of the series. If there are several values with the same frequency, it returns the smallest value.\nrange(source, length) - returns the difference between the min and max values in a series.\ntodegrees(radians) - returns an approximately equivalent angle in degrees from an angle measured in radians.\ntoradians(degrees) - returns an approximately equivalent angle in radians from an angle measured in degrees.\nrandom(min, max, seed) - returns a pseudo-random value. The function will generate a different sequence of values for each script execution. Using the same value for the optional seed argument will produce a repeatable sequence.\nsession.ismarket - returns true if the current bar is a part of the regular trading hours (i.e. market hours), false otherwise.\nsession.ispremarket - returns true if the current bar is a part of the pre-market, false otherwise.\nsession.ispostmarket - returns true if the current bar is a part of the post-market, false otherwise.\nstr.format - converts the values to strings based on the specified formats. Accepts certain number modifiers: integer, currency, percent.\nMarch 2021¶\nNew assignment operators were added:\n+= - addition assignment\n-= - subtraction assignment\n*= - multiplication assignment\n/= - division assignment\n%= - modulus assignment\nNew parameters for inputs customization were added:\ninline - combines all the input calls with the same inline value in one line.\ngroup - creates a header above all inputs that use the same group string value. The string is also used as the header text.\ntooltip - adds a tooltip icon to the Inputs menu. The tooltip string is shown when hovering over the tooltip icon.\nNew argument for fill function was added:\nfillgaps - controls whether fills continue on gaps when one of the plot calls returns an na value.\nA new keyword was added:\nvarip - is similar to the var keyword, but variables declared with varip retain their values between the updates of a real-time bar.\ntonumber() - converts a string value into a float.\ntime_close() - returns the UNIX timestamp of the close of the current bar, based on the resolution and session that is passed to the function.\ndividends() - requests dividends data for the specified symbol.\nearnings() - requests earnings data for the specified symbol.\nsplits() - requests splits data for the specified symbol.\nNew arguments for the study() function were added:\nresolution_gaps - fills the gaps between values fetched from higher timeframes when using resolution.\nformat.percent - formats the script output values as a percentage.\nFebruary 2021¶\nNew variable was added:\ntime_tradingday - the beginning time of the trading day the current bar belongs to.\n2020¶\nDecember 2020¶\nNew array types were added:\narray.new_line()\narray.new_label()\narray.new_string()\nstr.length() - returns number of chars in source string.\narray.join() - concatenates all of the elements in the array into a string and separates these elements with the specified separator.\nstr.split() - splits a string at a given substring separator.\nNovember 2020¶\nNew max_labels_count and max_lines_count parameters were added to the study and strategy functions. Now you can manage the number of lines and labels by setting values for these parameters from 1 to 500.\nNew function was added:\narray.range() - return the difference between the min and max values in the array.\nOctober 2020¶\nThe behavior of rising() and falling() functions have changed. For example, rising(close,3) is now calculated as following:\nclose[0] > close[1] and close[1] > close[2] and close[2] > close[3]\nSeptember 2020¶\nAdded support for input.color to the input() function. Now you can provide script users with color selection through the script’s “Settings/Inputs” tab with the same color widget used throughout the TradingView user interface. Learn more about this feature in our blog\n//@version=4\nstudy(\"My Script\", overlay = true)\ncolor c_labelColor = input(color.green, \"Main Color\", input.color)\nvar l = label.new(bar_index, close, yloc = yloc.abovebar, text = \"Colored label\")\nlabel.set_x(l, bar_index)\nlabel.set_color(l, c_labelColor)\nAdded support for arrays and functions for working with them. You can now use the powerful new array feature to build custom datasets. See our User Manual page on arrays and our blog\n//@version=4\nstudy(\"My Script\")\na = array.new_float(0)\nfor i = 0 to 5\narray.push(a, close[i] - open[i])\nplot(array.get(a, 4))\nThe following functions now accept a series length parameter. Learn more about this feature in our blog:\nalma()\nchange()\nhighest()\nhighestbars()\nlinreg()\nlowest()\nlowestbars()\nmom()\nsma()\nsum()\nvwma()\nwma()\n//@version=4\nstudy(\"My Script\", overlay = true)\nlength = input(10, \"Length\", input.integer, minval = 1, maxval = 100)\navgBar = avg(highestbars(length), lowestbars(length))\nfloat dynLen = nz(abs(avgBar) + 1, length)\ndynSma = sma(close, int(dynLen))\nplot(dynSma)\nAugust 2020¶\nOptimized script compilation time. Scripts now compile 1.5 to 2 times faster.\nJuly 2020¶\nMinor bug fixes and improvements.\nJune 2020¶\nNew resolution parameter was added to the study function. Now you can add MTF functionality to scripts and decide the timeframe you want the indicator to run on.\nPlease note that you need to reapply the indicator in order for the resolution parameter to appear.\nThe tooltip argument was added to the label.new function along with the label.set_tooltip function:\n//@version=4\nstudy(\"My Script\", overlay=true)\nvar l=label.new(bar_index, close, yloc=yloc.abovebar, text=\"Label\")\nlabel.set_x(l,bar_index)\nlabel.set_tooltip(l, \"Label Tooltip\")\nAdded an ability to create alerts on strategies.\nA new function line.get_price() can be used to determine the price level at which the line is located on a certain bar.\nNew label styles allow you to position the label pointer in any direction.\nFind and Replace was added to Pine Editor. To use this, press CTRL+F (find) or CTRL+H (find and replace).\ntimezone argument was added for time functions. Now you can specify timezone for second, minute, hour, year, month, dayofmonth, dayofweek functions:\nstudy(\"My Script\")\nplot(hour(1591012800000, \"GMT+1\"))\nsyminfo.basecurrency variable was added. Returns the base currency code of the current symbol. For EURUSD symbol returns EUR.\nMay 2020¶\nelse if statement was added\nThe behavior of security() function has changed: the expression parameter can be series or tuple.\nApril 2020¶\nNew function was added:\nquandl() - request quandl data for a symbol\nMarch 2020¶\nNew function was added:\nfinancial() - request financial data for a symbol\nNew functions for common indicators were added:\ncmo() - Chande Momentum Oscillator\nmfi() - Money Flow Index\nbb() - Bollinger Bands\nbbw() - Bollinger Bands Width\nkc() - Keltner Channels\nkcw() - Keltner Channels Width\ndmi() - DMI/ADX\nwpr() - Williams % R\nhma() - Hull Moving Average\nsupertrend() - SuperTrend\nAdded a detailed description of all the fields in the Strategy Tester Report.\nFebruary 2020¶\nNew Pine Script™ indicator VWAP Anchored was added. Now you can specify the time period: Session, Month, Week, Year.\nFixed a problem with calculating percentrank function. Now it can return a zero value, which did not happen before due to an incorrect calculation.\nThe default transparency parameter for the plot(), plotshape(), and plotchar() functions is now 0%.\nFor the functions plot(), plotshape(), plotchar(), plotbar(), plotcandle(), plotarrow(), you can set the display parameter, which controls the display of the plot. The following values can be assigned to it:\ndisplay.none - the plot is not displayed\ndisplay.all - the plot is displayed (Default)\nThe textalign argument was added to the label.new function along with the label.set_textalign function. Using those, you can control the alignment of the label’s text:\nstudy(\"My Script\", overlay = true)\nvar l = label.new(bar_index, high, text=\"Right\\n aligned\\n text\", textalign=text.align_right)\nlabel.set_xy(l, bar_index, high)\n.. image:: images/ReleaseNotes-Label_text_align.png\nJanuary 2020¶\nNew built-in variables were added:\niii - Intraday Intensity Index\nwvad - Williams Variable Accumulation/Distribution\nwad - Williams Accumulation/Distribution\nobv - On Balance Volume\npvt - Price-Volume Trend\nnvi - Negative Volume Index\npvi - Positive Volume Index\nNew parameters were added for strategy.close():\nqty - the number of contracts/shares/lots/units to exit a trade with\nqty_percent - defines the percentage of entered contracts/shares/lots/units to exit a trade with\ncomment - addtional notes on the order\nNew parameter was added for strategy.close_all:\ncomment - additional notes on the order\n2019¶\nDecember 2019¶\nWarning messages were added.\nFor example, if you don’t specify exit parameters for strategy.exit - profit, limit, loss, stop or one of the following pairs: trail_offset and trail_price / trail_points - you will see a warning message in the console in the Pine Script™ editor.\nIncreased the maximum number of arguments in max, min, avg functions. Now you can use up to ten arguments in these functions.\nOctober 2019¶\nplotchar() function now supports most of the Unicode symbols:\nstudy(\"My Script\", overlay=true)\nplotchar(open > close, char=\"🐻\")\n.. image:: images/ReleaseNotes-Bears_in_plotchar.png\nNew bordercolor argument of the plotcandle() function allows you to change the color of candles’ borders:\nstudy(\"My Script\")\nplotcandle(open, high, low, close, title='Title', color = open < close ? color.green : color.red, wickcolor=color.black, bordercolor=color.orange)\nNew variables added:\nsyminfo.description - returns a description of the current symbol\nsyminfo.currency - returns the currency code of the current symbol (EUR, USD, etc.)\nsyminfo.type - returns the type of the current symbol (stock, futures, index, etc.)\nSeptember 2019¶\nNew parameters to the strategy function were added:\nprocess_orders_on_close allows the broker emulator to try to execute orders after calculating the strategy at the bar’s close\nclose_entries_rule allows to define the sequence used for closing positions\nSome fixes were made:\nfill() function now works correctly with na as the color parameter value\nsign() function now calculates correctly for literals and constants\nstr.replace_all(source, target, replacement) function was added. It replaces each occurrence of a target string in the source string with a replacement string\nJuly-August 2019¶\nNew variables added:\ntimeframe.isseconds returns true when current resolution is in seconds\ntimeframe.isminutes returns true when current resolution is in minutes\ntime_close returns the current bar’s close time\nThe behavior of some functions, variables and operators has changed:\nThe time variable returns the correct open time of the bar for more special cases than before\nAn optional seconds parameter of the timestamp() function allows you to set the time to within seconds\nsecurity() function:\nAdded the possibility of requesting resolutions in seconds:\n1, 5, 15, 30 seconds (chart resolution should be less than or equal to the requested resolution)\nReduced the maximum value that can be requested in some of the other resolutions:\nfrom 1 to 1440 minutes\nfrom 1 to 365 days\nfrom 1 to 52 weeks\nfrom 1 to 12 months\nChanges to the evaluation of ternary operator branches:\nIn Pine Script™ v3, during the execution of a ternary operator, both its branches are calculated, so when this script is added to the chart, a long position is opened, even if the long() function is not called:\n//@version=3\nstrategy(title = \"My Strategy\")\nlong() =>\nstrategy.entry(\"long\", true, 1, when = open > high[1])\n1\nc = 0\nc := true ? 1 : long()\nplot(c)\nPine Script™ v4 contains built-in functions with side effects ( ``line.new`` and ``label.new`` ). If calls to these functions are present in both branches of a ternary operator, both function calls would be executed following v3 conventions. Thus, in Pine Script™ v4, only the branch corresponding to the evaluated condition is calculated. While this provides a viable solution in some cases, it will modify the behavior of scripts which depended on the fact that both branches of a ternary were evaluated. The solution is to pre-evaluate expressions prior to the ternary operator. The conversion utility takes this requirement into account when converting scripts from v3 to v4, so that script behavior will be identical in v3 and v4.\nJune 2019¶\nSupport for drawing objects. Added label and line drawings\nvar keyword for one time variable initialization\nType system improvements:\nseries string data type\nfunctions for explicit type casting\nsyntax for explicit variable type declaration\nnew input type forms\nRenaming of built-ins and a version 3 to 4 converter utility\nmax_bars_back function to control series variables internal history buffer sizes\nPine Script™ documentation versioning\n2018¶\nOctober 2018¶\nTo increase the number of indicators available to the whole community, Invite-Only scripts can now be published by Premium users only.\nApril 2018¶\nImproved the Strategy Tester by reworking the Maximum Drawdown calculation formula.\n2017¶\nAugust 2017¶\nWith the new argument show_last in the plot-type functions, you can restrict the number of bars that the plot is displayed on.\nJune 2017¶\nA major script publishing improvement: it is now possible to update your script without publishing a new one via the Update button in the publishing dialog.\nMay 2017¶\nExpanded the type system by adding a new type of constants that can be calculated during compilation.\nApril 2017¶\nExpanded the keyword argument functionality: it is now possible to use keyword arguments in all built-in functions.\nA new barstate.isconfirmed variable has been added to the list of variables that return bar status. It lets you create indicators that are calculated based on the closed bars only.\nThe options argument for the input() function creates an input with a set of options defined by the script’s author.\nMarch 2017¶\nPine Script™ v3 is here! Some important changes:\nChanges to the default behavior of the security() function: it can no longer access the future data by default. This can be changes with the lookahead parameter.\nAn implicit conversion of boolean values to numeric values was replaced with an implicit conversion of numeric values (integer and float) to boolean values.\nSelf-referenced and forward-referenced variables were removed. Any PineScript code that used those language constructions can be equivalently rewritten using mutable variables.\nFebruary 2017¶\nSeveral improvements to the strategy tester and the strategy report:\nNew Buy & Hold equity graph – a new graph that lets you compare performance of your strategy versus a “buy and hold”, i.e if you just bought a security and held onto it without trading.\nAdded percentage values to the absolute currency values.\nAdded Buy & Hold Return to display the final value of Buy & Hold Equity based on last price.\nAdded Sharpe Ratio – it shows the relative effectiveness of the investment portfolio (security), a measure that indicates the average return minus the risk-free return divided by the standard deviation of return on an investment.\nSlippage lets you simulate a situation when orders are filled at a worse price than expected. It can be set through the Properties dialog or through the slippage argument in the strategy() function.\nCommission allows yot to add commission for placed orders in percent of order value, fixed price or per contract. The amount of commission paid is shown in the Commission Paid field. The commission size and its type can be set through the Properties dialog or through the commission_type and commission_value arguments in the strategy() function.\n2016¶\nDecember 2016¶\nAdded invite-only scripts. The invite-only indicators are visible in the Community Scripts, but nobody can use them without explicit permission from the author, and only the author can see the source code.\nOctober 2016¶\nIntroduded indicator revisions. Each time an indicator is saved, it gets a new revision, and it is possible to easily switch to any past revision from the Pine Editor.\nSeptember 2016¶\nIt is now possible to publish indicators with protected source code. These indicators are available in the public Script Library, and any user can use them, but only the author can see the source code.\nJuly 2016¶\nImproved the behavior of the fill() function: one call can now support several different colors.\nMarch 2016¶\nColor type variables now have an additional parameter to set default transparency. The transparency can be set with the color.new() function, or by adding an alpha-channel value to a hex color code.\nFebruary 2016¶\nAdded for loops and keywords break and continue.\nPine Script™ now supports mutable variables! Use the := operator to assign a new value to a variable that has already been defined.\nMultiple improvements and bug fixes for strategies.\nJanuary 2016¶\nA new alertcondition() function allows for creating custom alert conditions in Pine Script™-based indicators.\n2015¶\nOctober 2015¶\nPine has graduated to v2! The new version of Pine Script™ added support for if statements, making it easier to write more readable and concise code.\nSeptember 2015¶\nAdded backtesting functionality to Pine Script™. It is now possible to create trading strategies, i.e. scripts that can send, modify and cancel orders to buy or sell. Strategies allow you to perform backtesting (emulation of strategy trading on historical data) and forward testing (emulation of strategy trading on real-time data) according to your algorithms. Detailed information about the strategy’s calculations and the order fills can be seen in the newly added Strategy Tester tab.\nJuly 2015¶\nA new editable parameter allows hiding the plot from the Style menu in the indicator settings so that it is not possible to edit its style. The parameter has been added to all the following functions: all plot-type functions, barcolor(), bgcolor(), hline(), and fill().\nJune 2015¶\nAdded two new functions to display custom barsets using PineScipt: plotbar() and plotcandle().\nApril 2015¶\nAdded two new shapes to the plotshape() function: shape.labelup and shape.labeldown.\nPineScipt Editor has been improved and moved to a new panel at the bottom of the page.\nAdded a new step argument for the input() function, allowing to specify the step size for the indicator’s inputs.\nMarch 2015¶\nAdded support for inputs with the source type to the input() function, allowing to select the data source for the indicator’s calculations from its settings.\nFebruary 2015¶\nAdded a new text argument to plotshape() and plotchar() functions.\nAdded four new shapes to the plotshape() function: shape.arrowup, shape.arrowdown, shape.square, shape.diamond.\n2014¶\nAugust 2014¶\nImproved the script sharing capabilities, changed the layout of the Indicators menu and separated published scripts from ideas.\nJuly 2014¶\nAdded three new plotting functions, plotshape(), plotchar(), and plotarrow() for situations when you need to highlight specific bars on a chart without drawing a line.\nIntegrated QUANDL data into Pine Script™. The data can be accessed by passing the QUANDL ticker to the security function.\nJune 2014¶\nAdded Pine Script™ sharing, enabling programmers and traders to share their scripts with the rest of the TradingView community.\nApril 2014¶\nAdded line wrapping.\nFebruary 2014¶\nAdded support for inputs, allowing users to edit the indicator inputs through the properties window, without needing to edit the Pine script.\nAdded self-referencing variables.\nAdded support for multiline functions.\nImplemented the type-casting mechanism, automatically casting constant and simple float and int values to series when it is required.\nAdded several new functions and improved the existing ones:\nbarssince() and valuewhen() allow you to check conditions on historical data easier.\nThe new barcolor() function lets you specify a color for a bar based on filling of a certain condition.\nSimilar to the barcolor() function, the bgcolor() function changes the color of the background.\nReworked the security() function, further expanding its functionality.\nImproved the fill() function, enabling it to be used more than once in one script.\nAdded the round() function to round and convert float values to integers.\n2013¶\nThe first version of Pine Script™ is introduced to all TradingView users, initially as an open beta, on December 13th."
},
{
  "text": "To Pine Script™ version 5\nTo Pine Script™ version 4\nTo Pine Script™ version 3"
},
{
  "text": "class right¶ \nclass right \nThis paragraph will be to the right.\ntest \nNote that:\nThe time and time_close variables returns a timestamp in UNIX time, which is independent of the timezone selected by the user on his chart. In this case, the chart’s time zone setting is the exchange time zone, so whatever symbol is on the chart, its exchange time zone will be used for the display of the date and time values on the chart’s cursor. The NASDAQ’s time zone is UTC-4, but this only affects the chart’s display of date/time values; it has no impact on the values plotted by the script.\nThe last time value for the plot shown in the scale is the number of milliseconds elapsed from 00:00:00 UTC, 1 January, 1970, until the bar’s opening time. It corresponds to 17:30 on the 27th of September 2021. However, because the chart is using the UTC-4 time zone (the NASDAQ’s time zone), it is displaying the 13:30 time, four hours earlier than UTC time.\nThe difference between the two values on the last bar is the number of milliseconds in one hour (1000 * 60 * 60 = 3,600,000) because we are on a 1H chart.\nNote\nThe time and time_close variables returns a timestamp in UNIX time, which is independent of the timezone selected by the user on his chart. In this case, the chart’s time zone setting is the exchange time zone, so whatever symbol is on the chart, its exchange time zone will be used for the display of the date and time values on the chart’s cursor. The NASDAQ’s time zone is UTC-4, but this only affects the chart’s display of date/time values; it has no impact on the values plotted by the script.\nThe last time value for the plot shown in the scale is the number of milliseconds elapsed from 00:00:00 UTC, 1 January, 1970, until the bar’s opening time. It corresponds to 17:30 on the 27th of September 2021. However, because the chart is using the UTC-4 time zone (the NASDAQ’s time zone), it is displaying the 13:30 time, four hours earlier than UTC time.\nThe difference between the two values on the last bar is the number of milliseconds in one hour (1000 * 60 * 60 = 3,600,000) because we are on a 1H chart.\nPine Script™ small logo with macro¶\n|TVLogoHeader|\nTests¶\nAlerts page with page reference below header: Alerts faq\nConditions page with page reference above header: Conditions faq\nTexttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext Texttext"
},
{
  "text": "Levels¶\n`hline()` levels\nFills between levels\n`hline()` levels¶\nLevels are lines plotted using the hline() function. It is designed to plot horizontal levels using a single color, i.e., it does not change on different bars. See the Levels section of the page on plot() for alternative ways to plot levels when hline() won’t do what you need.\nThe function has the following signature:\nhline(price, title, color, linestyle, linewidth, editable) → hline\nhline() has a few constraints when compared to plot():\nSince the function’s objective is to plot horizontal lines, its price parameter requires an “input int/float” argument, which means that “series float” values such as close or dynamically-calculated values cannot be used.\nIts color parameter requires an “input int” argument, which precludes the use of dynamic colors, i.e., colors calculated on each bar — or “series color” values.\nThree different line styles are supported through the linestyle parameter: hline.style_solid, hline.style_dotted and hline.style_dashed.\nLet’s see hline() in action in the “True Strength Index” indicator:\nindicator(\"TSI\")\nmyTSI = 100 * ta.tsi(close, 25, 13)\nhline( 50, \"+50\", color.lime)\nhline( 25, \"+25\", color.green)\nhline( 0, \"Zero\", color.gray, linestyle = hline.style_dotted)\nhline(-25, \"-25\", color.maroon)\nhline(-50, \"-50\", color.red)\nplot(myTSI)\nNote that:\nWe display 5 levels, each of a different color.\nWe use a different line style for the zero centerline.\nWe choose colors that will work well on both light and dark themes.\nThe usual range for the indicator’s values is +100 to -100. Since the ta.tsi() built-in returns values in the +1 to -1 range, we make the adjustment in our code.\nFills between levels¶\nThe space between two levels plotted with hline() can be colored using fill(). Keep in mind that both plots must have been plotted with hline().\nLet’s put some background colors in our TSI indicator:\nindicator(\"TSI\")\nmyTSI = 100 * ta.tsi(close, 25, 13)\nplus50Hline = hline( 50, \"+50\", color.lime)\nplus25Hline = hline( 25, \"+25\", color.green)\nzeroHline = hline( 0, \"Zero\", color.gray, linestyle = hline.style_dotted)\nminus25Hline = hline(-25, \"-25\", color.maroon)\nminus50Hline = hline(-50, \"-50\", color.red)\n// ————— Function returns a color in a light shade for use as a background.\nfillColor(color col) =>\ncolor.new(col, 90)\nfill(plus50Hline, plus25Hline, fillColor(color.lime))\nfill(plus25Hline, zeroHline, fillColor(color.teal))\nfill(zeroHline, minus25Hline, fillColor(color.maroon))\nfill(minus25Hline, minus50Hline, fillColor(color.red))\nplot(myTSI)\nNote that:\nWe have now used the return value of our hline() function calls, which is of the hline special type. We use the plus50Hline, plus25Hline, zeroHline, minus25Hline and minus50Hline variables to store those “hline” IDs because we will need them in our fill() calls later.\nTo generate lighter color shades for the background colors, we declare a fillColor() function that accepts a color and returns its 90 transparency. We use calls to that function for the color arguments in our fill() calls.\nWe make our fill() calls for each of the four different fills we want, between four different pairs of levels.\nWe use color.teal in our second fill because it produces a green that fits the color scheme better than the color.green used for the 25 level."
},
{
  "text": "External resources\nDownload this manual\nA description of all the Pine Script™ operators, variables and functions can be found in the Reference Manual.\nUse the code from one of TradingView’s built-in scripts to start from. Open a new chart and click the “Pine Editor” button on the toolbar. Once in the editor window, click the “Open” button, then select “Built-in script…” from the dropdown list to open a dialog box containing a list of TradingView’s built-in scripts.\nThere is a TradingView public chat dedicated to Pine Script™ Q&A where active developers of our community help each other out.\nInformation about major releases and modifications to Pine Script™ (as well as other features) is regularly published on TradingView’s blog.\nTradingView’s Community Scripts contain all user-published scripts. They can also be accessed from charts using the “Indicators & Strategies” button and the “Community Scripts” tab of the script searching dialog box.\nExternal resources¶\nThe PineCoders account on TradingView publishes useful information for Pine Script™ programmers. They also have content on their website.\nKodify has TradingView tutorials on various topics for beginners and more experienced programmers alike. Topics include plotting, alerts, strategy orders, and complete example indicators and strategies.\nBacktest Rookies publishes good quality blog articles focusing on realizing specific tasks in Pine Script™.\nYou can ask questions about programming in Pine Script™ in the [pine-script] tag on StackOverflow."
},
{
  "text": "Introduction¶\nPine Script™ libraries are publications containing functions that can be reused in indicators, strategies, or in other libraries. They are useful to define frequently-used functions so their source code does not have to be included in every script where they are needed.\nA library must be published (privately or publicly) before it can be used in another script. All libraries are published open-source. Public scripts can only use public libraries and they must be open-source. Private scripts or personal scripts saved in the Pine Script™ Editor can use public or private libraries. A library can use other libraries, or even previous versions of itself.\nLibrary programmers should be familiar with Pine Script™’s typing nomenclature, scopes and user-defined functions. If you need to brush up on qualified types, see the User Manual’s page on the Type system. For more information on user-defined functions and scopes, see the User-defined functions page.\nYou can browse the library scripts published publicly by members in TradingView’s Community Scripts.\nCreating a library¶\nA library is a special kind of script that begins with the library() declaration statement, rather than indicator() or strategy(). A library contains exportable function definitions, which constitute the only visible part of the library when it is used by another script. Libraries can also use other Pine Script™ code in their global scope, like a normal indicator. This code will typically serve to demonstrate how to use the library’s functions.\nA library script has the following structure, where one or more exportable functions must be defined:\n// @description <library_description>\nlibrary(title, overlay)\n<script_code>\n// @function <function_description>\n// @param <parameter> <parameter_description>\n// @returns <return_value_description>\nexport <function_name>([simple/series] <parameter_type> <parameter_name> [= <default_value>] [, ...]) =>\n<function_code>\n<script_code>\nNote that:\nThe // @description, // @function, // @param and // @returns compiler annotations are optional but we highly recommend you use them. They serve a double purpose: document the library’s code and populate the default library description which authors can use when publishing the library.\nThe export keyword is mandatory.\n<parameter_type> is mandatory, contrary to user-defined function parameter definitions in indicators or strategies, which are typeless.\n<script_code> can be any code you would normally use in an indicator, including inputs or plots.\nThis is an example library:\n// @description Provides functions calculating the all-time high/low of values.\nlibrary(\"AllTimeHighLow\", true)\n// @function Calculates the all-time high of a series.\n// @param val Series to use (`high` is used if no argument is supplied).\n// @returns The all-time high for the series.\nexport hi(float val = high) =>\nvar float ath = val\nath := math.max(ath, val)\n// @function Calculates the all-time low of a series.\n// @param val Series to use (`low` is used if no argument is supplied).\n// @returns The all-time low for the series.\nexport lo(float val = low) =>\nvar float atl = val\natl := math.min(atl, val)\nplot(hi())\nplot(lo())\nLibrary functions¶\nFunction definitions in libraries are slightly different than those of user-defined functions in indicators and strategies. There are constraints as to what can be included in the body of library functions.\nIn library function signatures (their first line):\nThe export keyword is mandatory.\nThe type of argument expected for each parameter must be explicitly mentioned.\nA simple or series keyword can restrict the allowable qualified types of arguments (the next section explains their use).\nThese are the constraints imposed on library functions:\nThey cannot use variables from the library’s global scope unless they are qualified as “const”. This means you cannot use global variables initialized from script inputs, for example, or globally declared arrays.\nrequest.*() calls are not allowed.\ninput.*() calls are not allowed.\nplot*(), fill() and bgcolor() calls are not allowed.\nLibrary functions always return a result that is qualified as “simple” or “series”. You cannot use them where “const” or “input” qualified values are required, as is the case with some built-in functions. For example, a library function cannot be used to calculate an argument for the show_last parameter in a plot() call because it requires an “input int” value.\nQualified type control¶\nThe qualified types of arguments supplied in calls to library functions are autodetected based on how each argument is used inside the function. If the argument can be used as a “series”, it is qualified as such. If it cannot, an attempt is made with the “simple” type qualifier. This explains why this code:\nexport myEma(int x) =>\nta.ema(close, x)\nwill work when called using myCustomLibrary.myEma(20), even though ta.ema()’s length parameter requires a “simple int” argument. When the Pine Script™ compiler detects that a “series” length cannot be used with ta.ema(), it tries the “simple” qualifier, which in this case is allowed.\nWhile library functions cannot return “const” or “input” values, they can be written to produce “simple” results. This makes them useful in more contexts than functions returning “series” results, as some built-in functions do not allow “series” arguments. For example, request.security() requires a “simple string” for its symbol parameter. If we wrote a library function to assemble the argument to symbol in the following way, the function’s result would not work because it is of the “series string” qualified type:\nexport makeTickerid(string prefix, string ticker) =>\nprefix + \":\" + ticker\nHowever, by restricting the parameter qualifiers to “simple”, we can force the function to yield a “simple” result. We can achieve this by prefixing the parameters’ type with the simple keyword:\nexport makeTickerid(simple string prefix, simple string ticker) =>\nprefix + \":\" + ticker\nNote that for the function to return a “simple” value, no “series” values can be used in its calculation; otherwise the result will be a “series” value.\nOne can also use the series keyword to prefix the type of a library function parameter. However, because arguments are qualified as “series” by default, using the series modifier is redundant.\nUser-defined types and objects¶\nYou can export user-defined types (UDTs) from libraries, and library functions can return objects.\nTo export a UDT, prefix its definition with the export keyword just as you would export a function:\nlibrary(\"Point\")\nexport type point\nint x\nfloat y\nbool isHi\nbool wasBreached = false\nA script importing that library and creating an object from its point UDT would look somewhat like this:\nindicator(\"\")\nimport userName/Point/1 as pt\nnewPoint = pt.point.new()\nThis code won’t compile because no “Point” library is published, and the script doesn’t display anything.\nuserName would need to be replaced by the TradingView user name of the library’s publisher.\nWe use the built-in new() method to create an object from the point UDT.\nWe prefix the reference to the library’s point UDT with the pt alias defined in the import statement, just like we would when using a function from an imported library.\nUDTs used in a library must be exported if any of its exported functions use a parameter or returns a result of that user-defined type.\nWhen a library only uses a UDT internally, it does not have to be exported. The following library uses the point UDT internally, but only its drawPivots() function is exported, which does not use a parameter nor return a result of point type:\nlibrary(\"PivotLabels\", true)\n// We use this `point` UDT in the library, but it does NOT require exporting because:\n// 1. The exported function's parameters do not use the UDT.\n// 2. The exported function does not return a UDT result.\ntype point\nint x\nfloat y\nbool isHi\nbool wasBreached = false\nfillPivotsArray(qtyLabels, leftLegs, rightLegs) =>\n// Create an array of the specified qty of pivots to maintain.\nvar pivotsArray = array.new<point>(math.max(qtyLabels, 0))\n// Detect pivots.\nfloat pivotHi = ta.pivothigh(leftLegs, rightLegs)\nfloat pivotLo = ta.pivotlow(leftLegs, rightLegs)\n// Create a new `point` object when a pivot is found.\npoint foundPoint = switch\npivotHi => point.new(time[rightLegs], pivotHi, true)\npivotLo => point.new(time[rightLegs], pivotLo, false)\n=> na\n// Add new pivot info to the array and remove the oldest pivot.\nif not na(foundPoint)\narray.push(pivotsArray, foundPoint)\narray.shift(pivotsArray)\narray<point> result = pivotsArray\ndetectBreaches(pivotsArray) =>\n// Detect breaches.\nfor [i, eachPoint] in pivotsArray\nif not na(eachPoint)\nif not eachPoint.wasBreached\nbool hiWasBreached = eachPoint.isHi and high[1] <= eachPoint.y and high > eachPoint.y\nbool loWasBreached = not eachPoint.isHi and low[1] >= eachPoint.y and low < eachPoint.y\nif hiWasBreached or loWasBreached\n// This pivot was breached; change its `wasBreached` field.\npoint p = array.get(pivotsArray, i)\np.wasBreached := true\narray.set(pivotsArray, i, p)\ndrawLabels(pivotsArray) =>\nfor eachPoint in pivotsArray\nif not na(eachPoint)\nlabel.new(\neachPoint.x,\neachPoint.y,\nstr.tostring(eachPoint.y, format.mintick),\nxloc.bar_time,\ncolor = eachPoint.wasBreached ? color.gray : eachPoint.isHi ? color.teal : color.red,\nstyle = eachPoint.isHi ? label.style_label_down: label.style_label_up,\ntextcolor = eachPoint.wasBreached ? color.silver : color.white)\n// @function Displays a label for each of the last `qtyLabels` pivots.\n// Colors high pivots in green, low pivots in red, and breached pivots in gray.\n// @param qtyLabels (simple int) Quantity of last labels to display.\n// @param leftLegs (simple int) Left pivot legs.\n// @param rightLegs (simple int) Right pivot legs.\n// @returns Nothing.\nexport drawPivots(int qtyLabels, int leftLegs, int rightLegs) =>\n// Gather pivots as they occur.\npointsArray = fillPivotsArray(qtyLabels, leftLegs, rightLegs)\n// Mark breached pivots.\ndetectBreaches(pointsArray)\n// Draw labels once.\nif barstate.islastconfirmedhistory\ndrawLabels(pointsArray)\n// Example use of the function.\ndrawPivots(20, 10, 5)\nIf the TradingView user published the above library, it could be used like this:\nindicator(\"\")\nimport TradingView/PivotLabels/1 as dpl\ndpl.drawPivots(20, 10, 10)\nPublishing a library¶\nBefore you or other Pine Script™ programmers can reuse any library, it must be published. If you want to share your library with all TradingViewers, publish it publicly. To use it privately, use a private publication. As with indicators or strategies, the active chart when you publish a library will appear in both its widget (the small placeholder denoting libraries in the TradingView scripts stream) and script page (the page users see when they click on the widget).\nPrivate libraries can be used in public Protected or Invite-only scripts.\nAfter adding our example library to the chart and setting up a clean chart showing our library plots the way we want them, we use the Pine Editor’s “Publish Script” button. The “Publish Library” window comes up:\nWe leave the library’s title as is (the title argument in our library() declaration statement is used as the default). While you can change the publication’s title, it is preferable to keep its default value because the title argument is used to reference imported libraries in the import statement. It makes life easier for library users when your publication’s title matches the actual name of the library.\nA default description is built from the compiler annotations we used in our library. We will publish the library wihout retouching it.\nWe chose to publish our library publicly, so it will be visible to all TradingViewers.\nWe do not have the possibility of selecting a visibility type other than “Open” because libraries are always open-source.\nThe list of categories for libraries is different than for indicators and strategies. We have selected the “Statistics and Metrics” category.\nWe have added some custom tags: “all-time”, “high” and “low”.\nThe intended users of public libraries being other Pine programmers; the better you explain and document your library’s functions, the more chances others will use them. Providing examples demonstrating how to use your library’s functions in your publication’s code will also help.\nHouse Rules¶\nPine libraries are considered “public domain” code in our House Rules on Script Publishing, which entails that permission is not required from their author if you call their functions or reuse their code in your open-source scripts. However, if you intend to reuse code from a Pine Script™ library’s functions in a public protected or invite-only publication, explicit permission for reuse in that form is required from its author.\nWhether using a library’s functions or reusing its code, you must credit the author in your publication’s description. It is also good form to credit in open-source comments.\nUsing a library¶\nUsing a library from another script (which can be an indicator, a strategy or another library), is done through the import statement:\nimport <username>/<libraryName>/<libraryVersion> [as <alias>]\nwhere:\nThe <username>/<libraryName>/<libraryVersion> path will uniquely identify the library.\nThe <libraryVersion> must be specified explicitly. To ensure the reliability of scripts using libraries, there is no way to automatically use the latest version of a library. Every time a library update is published by its author, the library’s version number increases. If you intend to use the latest version of the library, the <libraryVersion> value will require updating in the import statement.\nThe as <alias> part is optional. When used, it defines the namespace that will refer to the library’s functions. For example, if you import a library using the allTime alias as we do in the example below, you will refer to that library’s functions as allTime.<function_mame>(). When no alias is defined, the library’s name becomes its namespace.\nTo use the library we published in the previous section, our next script will require an import statement:\nimport PineCoders/AllTimeHighLow/1 as allTime\nAs you type the user name of the library’s author, you can use the Editor’s ctrl + space / cmd + space “Auto-complete” command to display a popup providing selections that match the available libraries:\nThis is an indicator that reuses our library:\nindicator(\"Using AllTimeHighLow library\", \"\", true)\nimport PineCoders/AllTimeHighLow/1 as allTime\nplot(allTime.hi())\nplot(allTime.lo())\nplot(allTime.hi(close))\nWe have chosen to use the “allTime” alias for the library’s instance in our script. When typing that alias in the Editor, a popup will appear to help you select the particular function you want to use from the library.\nWe use the library’s hi() and lo() functions without an argument, so the default high and low built-in variables will be used for their series, respectively.\nWe use a second call to allTime.hi(), but this time using close as its argument, to plot the highest close in the chart’s history."
},
{
  "text": "Lines and boxes¶\nIntroduction\nLines\nCreating lines\nModifying lines\nLine styles\nReading line values\nCloning lines\nDeleting lines\nBoxes\nCreating boxes\nModifying boxes\nBox styles\nReading box values\nCloning boxes\nDeleting boxes\nPolylines\nCreating polylines\nCurved drawings\nClosed shapes\nDeleting polylines\nRedrawing polylines\nRealtime behavior\nLimitations\nTotal number of objects\nFuture references with `xloc.bar_index`\nOther contexts\nHistorical buffer and `max_bars_back`\nIntroduction¶\nPine Script™ facilitates drawing lines, boxes, and other geometric formations from code using the line, box, and polyline types. These types provide utility for programmatically drawing support and resistance levels, trend lines, price ranges, and other custom formations on a chart.\nUnlike plots, the flexibility of these types makes them particularly well-suited for visualizing current calculated data at virtually any available point on the chart, irrespective of the chart bar the script executes on.\nLines, boxes, and polylines are objects, like labels, tables, and other special types. Scripts reference objects of these types using IDs, which act like pointers. As with other objects, line, box, and polyline IDs are qualified as “series” values, and all functions that manage these objects accept “series” arguments.\nNote\nUsing the types we discuss on this page often involves arrays, especially when working with polylines, which require an array of chart.point instances. We therefore recommend you become familiar with arrays to make the most of these drawing types in your scripts.\nLines drawn by a script may be vertical, horizontal, or angled. Boxes are always rectangular. Polylines sequentially connect multiple vertical, horizontal, angled, or curved line segments. Although all of these drawing types have different characteristics, they do have some things in common:\nLines, boxes, and polylines can have coordinates at any available location on the chart, including ones at future times beyond the last chart bar.\nObjects of these types can use chart.point instances to set their coordinates.\nThe x-coordinates of each object can be bar index or time values, depending on their specified xloc property.\nEach object can have one of multiple predefined line styles.\nScripts can call the functions that manage these objects from within the scopes of loops and conditional structures, allowing iterative and conditional control of their drawings.\nThere are limits on the number of these objects that a script can reference and display on the chart. A single script instance can display up to 500 lines, 500 boxes, and 100 polylines. Users can specify the maximum number allowed for each type via the max_lines_count, max_boxes_count, and max_polylines_count parameters of the script’s indicator() or strategy() declaration statement. If unspecified, the default is ~50. As with label and table types, lines, boxes, and polylines utilize a garbage collection mechanism that deletes the oldest objects on the chart when the total number of drawings exceeds the script’s limit.\nNote\nOn TradingView charts, a complete set of Drawing Tools allows users to create and modify drawings using mouse actions. While they may sometimes resemble drawing objects created with Pine Script™ code, they are unrelated entities. Pine scripts cannot interact with drawing tools from the chart user interface, and mouse actions do not directly affect Pine drawing objects.\nLines¶\nThe built-ins in the line.* namespace control the creation and management of line objects:\nThe line.new() function creates a new line.\nThe line.set_*() functions modify line properties.\nThe line.get_*() functions retrieve values from a line instance.\nThe line.copy() function clones a line instance.\nThe line.delete() function deletes an existing line instance.\nThe line.all variable references a read-only array containing the IDs of all lines displayed by the script. The array’s size depends on the max_lines_count of the indicator() or strategy() declaration statement and the number of lines the script has drawn.\nScripts can call line.set_*(), line.get_*(), line.copy(), and line.delete() built-ins as functions or methods.\nCreating lines¶\nThe line.new() function creates a new line instance to display on the chart. It has the following signatures:\nline.new(first_point, second_point, xloc, extend, color, style, width) → series line\nline.new(x1, y1, x2, y2, xloc, extend, color, style, width) → series line\nThe first overload of this function contains the first_point and second_point parameters. The first_point is a chart.point representing the start of the line, and the second_point is a chart.point representing the line’s end. The function copies the information from these chart points to determine the line’s coordinates. Whether it uses the index or time fields from the first_point and second_point as x-coordinates depends on the function’s xloc value.\nThe second overload specifies x1, y1, x2, and y2 values independently, where x1 and x2 are int values representing the starting and ending x-coordinates of the line, and y1 and y2 are float values representing the y-coordinates. Whether the line considers the x values as bar indices or timestamps depends on the xloc value in the function call.\nBoth overloads share the same additional parameters:\nxloc \nControls whether the x-coordinates of the new line use bar index or time values. Its default value is xloc.bar_index.\nWhen calling the first overload, using an xloc value of xloc.bar_index tells the function to use the index fields of the first_point and second_point, and a value of xloc.bar_time tells the function to use the time fields of the points.\nWhen calling the second overload, an xloc value of xloc.bar_index prompts the function to treat the x1 and x2 arguments as bar index values. When using xloc.bar_time, the function will treat x1 and x2 as time values.\nWhen the specified x-coordinates represent bar index values, it’s important to note that the minimum x-coordinate allowed is bar_index - 9999. For larger offsets, one can use xloc.bar_time.\nextend Determines whether the drawn line will infinitely extend beyond its defined start and end coordinates. It accepts one of the following values: extend.left, extend.right, extend.both, or extend.none (default). color Specifies the color of the line drawing. The default is color.blue. style Specifies the line’s style, which can be any of the options listed in this page’s Line styles section. The default value is line.style_solid. width Controls the width of the line, in pixels. The default value is 1. \nThe example below demonstrates how one can draw lines in their simplest form. This script draws a new vertical line connecting the open and close prices at the horizontal center of each chart bar:\nindicator(\"Creating lines demo\", overlay = true)\n//@variable The `chart.point` for the start of the line. Contains `index` and `time` information.\nfirstPoint = chart.point.now(open)\n//@variable The `chart.point` for the end of the line. Contains `index` and `time` information.\nsecondPoint = chart.point.now(close)\n// Draw a basic line with a `width` of 5 connecting the `firstPoint` to the `secondPoint`.\n// This line uses the `index` field from each point for its x-coordinates.\nline.new(firstPoint, secondPoint, width = 5)\n// Color the background on the unconfirmed bar.\nbgcolor(barstate.isconfirmed ? na : color.new(color.orange, 70), title = \"Unconfirmed bar highlight\")\nNote that: \nIf the firstPoint and secondPoint reference identical coordinates, the script will not display a line since there is no distance between them to draw. However, the line ID will still exist.\nThe script will only display approximately the last 50 lines on the chart, as it does not have a specified max_lines_count in the indicator() function call. Line drawings persist on the chart until deleted using line.delete() or removed by the garbage collector.\nThe script redraws the line on the open chart bar (i.e., the bar with an orange background highlight) until it closes. After the bar closes, it will no longer update the drawing.\nLet’s look at a more involved example. This script uses the previous bar’s hl2 price and the current bar’s high and low prices to draw a fan with a user-specified number of lines projecting a range of hypothetical price values for the following chart bar. It calls line.new() within a for loop to create linesPerBar lines on each bar:\nindicator(\"Creating lines demo\", \"Simple projection fan\", true, max_lines_count = 500)\n//@variable The number of fan lines drawn on each chart bar.\nint linesPerBar = input.int(20, \"Line drawings per bar\", 2, 100)\n//@variable The distance between each y point on the current bar.\nfloat step = (high - low) / (linesPerBar - 1)\n//@variable The `chart.point` for the start of each line. Does not contain `time` information.\nfirstPoint = chart.point.from_index(bar_index - 1, hl2[1])\n//@variable The `chart.point` for the end of each line. Does not contain `time` information.\nsecondPoint = chart.point.from_index(bar_index + 1, float(na))\n//@variable The stepped y value on the current bar for `secondPoint.price` calculation, starting from the `low`.\nfloat barValue = low\n// Loop to draw the fan.\nfor i = 1 to linesPerBar\n// Update the `price` of the `secondPoint` using the difference between the `barValue` and `firstPoint.price`.\nsecondPoint.price := 2.0 * barValue - firstPoint.price\n//@variable Is `color.aqua` when the line's slope is positive, `color.fuchsia` otherwise.\ncolor lineColor = secondPoint.price > firstPoint.price ? color.aqua : color.fuchsia\n// Draw a new `lineColor` line connecting the `firstPoint` and `secondPoint` coordinates.\n// This line uses the `index` field from each point for its x-coordinates.\nline.new(firstPoint, secondPoint, color = lineColor)\n// Add the `step` to the `barValue`.\nbarValue += step\n// Color the background on the unconfirmed bar.\nbgcolor(barstate.isconfirmed ? na : color.new(color.orange, 70), title = \"Unconfirmed bar highlight\")\nNote that: \nWe’ve included max_lines_count = 500 in the indicator() function call, meaning the script preserves up to 500 lines on the chart.\nEach line.new() call copies the information from the chart.point referenced by the firstPoint and secondPoint variables. As such, the script can change the price field of the secondPoint on each loop iteration without affecting the y-coordinates in other lines.\nModifying lines¶\nThe line.* namespace contains multiple setter functions that modify the properties of line instances:\nline.set_first_point() and line.set_second_point() respectively update the start and end points of the id line using information from the specified point.\nline.set_x1() and line.set_x2() set one of the x-coordinates of the id line to a new x value, which can represent a bar index or time value depending on the line’s xloc property.\nline.set_y1() and line.set_y2() set one of the y-coordinates of the id line to a new y value.\nline.set_xy1() and line.set_xy2() update one of the id line’s points with new x and y values.\nline.set_xloc() sets the xloc of the id line and updates both of its x-coordinates with new x1 and x2 values.\nline.set_extend() sets the extend property of the id line.\nline.set_color() updates the id line’s color value.\nline.set_style() changes the style of the id line.\nline.set_width() sets the width of the id line.\nAll setter functions directly modify the id line passed into the call and do not return any value. Each setter function accepts “series” arguments, as a script can change a line’s properties throughout its execution.\nThe following example draws lines connecting the opening price of a timeframe to its closing price. The script uses the var keyword to declare the periodLine and the variables that reference chart.point values (openPoint and closePoint) only on the first chart bar, and it assigns new values to these variables over its execution. After detecting a change on the timeframe, it sets the color of the existing periodLine using line.set_color(), creates new values for the openPoint and closePoint using chart.point.now(), then assigns a new line using those points to the periodLine.\nOn other bars where the periodLine value is not na, the script assigns a new chart.point to the closePoint, then uses line.set_second_point() and line.set_color() as methods to update the line’s properties:\nindicator(\"Modifying lines demo\", overlay = true)\n//@variable The size of each period.\nstring timeframe = input.timeframe(\"D\", \"Timeframe\")\n//@variable A line connecting the period's opening and closing prices.\nvar line periodLine = na\n//@variable The first point of the line. Contains `time` and `index` information.\nvar chart.point openPoint = chart.point.now(open)\n//@variable The closing point of the line. Contains `time` and `index` information.\nvar chart.point closePoint = chart.point.now(close)\nif timeframe.change(timeframe)\n//@variable The final color of the `periodLine`.\ncolor finalColor = switch\nclosePoint.price > openPoint.price => color.green\nclosePoint.price < openPoint.price => color.red\n=> color.gray\n// Update the color of the current `periodLine` to the `finalColor`.\nline.set_color(periodLine, finalColor)\n// Assign new points to the `openPoint` and `closePoint`.\nopenPoint := chart.point.now(open)\nclosePoint := chart.point.now(close)\n// Assign a new line to the `periodLine`. Uses `time` fields from the `openPoint` and `closePoint` as x-coordinates.\nperiodLine := line.new(openPoint, closePoint, xloc.bar_time, style = line.style_arrow_right, width = 3)\nelse if not na(periodLine)\n// Assign a new point to the `closePoint`.\nclosePoint := chart.point.now(close)\n//@variable The color of the developing `periodLine`.\ncolor developingColor = switch\nclosePoint.price > openPoint.price => color.aqua\nclosePoint.price < openPoint.price => color.fuchsia\n=> color.gray\n// Update the coordinates of the line's second point using the new `closePoint`.\n// It uses the `time` field from the point for its new x-coordinate.\nperiodLine.set_second_point(closePoint)\n// Update the color of the line using the `developingColor`.\nperiodLine.set_color(developingColor)\nNote that: \nEach line drawing in this example uses the line.style_arrow_right style. See the Line styles section below for an overview of all available style settings.\nLine styles¶\nUsers can control the style of their scripts’ line drawings by passing one of the following variables as the style argument in their line.new() or line.set_style() function calls:\nNote that: \nPolylines can also use any of these variables as their line_style value. See the Creating polylines section of this page.\nReading line values¶\nThe line.* namespace includes getter functions, which allow a script to retrieve values from a line object for further use:\nline.get_x1() and line.get_x2() respectively get the first and second x-coordinate from the id line. Whether the value returned represents a bar index or time value depends on the line’s xloc property.\nline.get_y1() and line.get_y2() respectively get the id line’s first and second y-coordinate.\nline.get_price() retrieves the price (y-coordinate) from a line id at a specified x value, including at bar indices outside the line’s start and end points. This function is only compatible with lines that use xloc.bar_index as the xloc value.\nThe script below draws a new line upon the onset of a rising or falling price pattern forming over length bars. It uses the var keyword to declare the directionLine variable on the first chart bar. The ID assigned to the directionLine persists over subsequent bars until the newDirection condition occurs, in which case the script assigns a new line to the variable.\nOn every bar, the script calls the line.get_y2(), line.get_y1(), line.get_x2(), and line.get_x1() getters as methods to retrieve values from the current directionLine and calculate its slope, which it uses to determine the color of each drawing and plot. It retrieves extended values of the directionLine from beyond its second point using line.get_price() and plots them on the chart:\nindicator(\"Reading line values demo\", overlay = true)\n//@variable The number of bars for rising and falling calculations.\nint length = input.int(2, \"Length\", 2)\n//@variable A line that's drawn whenever `hlc3` starts rising or falling over `length` bars.\nvar line directionLine = na\n//@variable Is `true` when `hlc3` is rising over `length` bars, `false` otherwise.\nbool rising = ta.rising(hlc3, length)\n//@variable Is `true` when `hlc3` is falling over `length` bars, `false` otherwise.\nbool falling = ta.falling(hlc3, length)\n//@variable Is `true` when a rising or falling pattern begins, `false` otherwise.\nbool newDirection = (rising and not rising[1]) or (falling and not falling[1])\n// Update the `directionLine` when `newDirection` is `true`. The line uses the default `xloc.bar_index`.\nif newDirection\ndirectionLine := line.new(bar_index - length, hlc3[length], bar_index, hlc3, width = 3)\n//@variable The slope of the `directionLine`.\nfloat slope = (directionLine.get_y2() - directionLine.get_y1()) / (directionLine.get_x2() - directionLine.get_x1())\n//@variable The value extrapolated from the `directionLine` at the `bar_index`.\nfloat lineValue = line.get_price(directionLine, bar_index)\n//@variable Is `color.green` when the `slope` is positive, `color.red` otherwise.\ncolor slopeColor = slope > 0 ? color.green : color.red\n// Update the color of the `directionLine`.\ndirectionLine.set_color(slopeColor)\n// Plot the `lineValue`.\nplot(lineValue, \"Extrapolated value\", slopeColor, 3, plot.style_circles)\nThis example calls the second overload of the line.new() function, which uses x1, y1, x2, and y2 parameters to define the start and end points of the line. The x1 value is length bars behind the current bar_index, and the y1 value is the hlc3 value at that index. The x2 and y2 in the function call use the current bar’s bar_index and hlc3 values.\nThe line.get_price() function call treats the directionLine as though it extends infinitely, regardless of its extend property.\nThe script only displays approximately the last 50 lines on the chart, but the plot of extrapolated values spans throughout the chart’s history.\nCloning lines¶\nScripts can clone a line id and all its properties with the line.copy() function. Any changes to the copied line instance do not affect the original.\nFor example, this script creates a horizontal line at the the bar’s open price once every length bars, which it assigns to a mainLine variable. On all other bars, it creates a copiedLine using line.copy() and calls line.set_*() functions to modify its properties. As we see below, altering the copiedLine does not affect the mainLine in any way:\nindicator(\"Cloning lines demo\", overlay = true, max_lines_count = 500)\n//@variable The number of bars between each new mainLine assignment.\nint length = input.int(20, \"Length\", 2, 500)\n//@variable The first `chart.point` used by the `mainLine`. Contains `index` and `time` information.\nfirstPoint = chart.point.now(open)\n//@variable The second `chart.point` used by the `mainLine`. Does not contain `time` information.\nsecondPoint = chart.point.from_index(bar_index + length, open)\n//@variable A horizontal line drawn at the `open` price once every `length` bars.\nvar line mainLine = na\nif bar_index % length == 0\n// Assign a new line to the `mainLine` that connects the `firstPoint` to the `secondPoint`.\n// This line uses the `index` fields from both points as x-coordinates.\nmainLine := line.new(firstPoint, secondPoint, color = color.purple, width = 2)\n//@variable A copy of the `mainLine`. Changes to this line do not affect the original.\nline copiedLine = line.copy(mainLine)\n// Update the color, style, and second point of the `copiedLine`.\nline.set_color(copiedLine, color.orange)\nline.set_style(copiedLine, line.style_dotted)\nline.set_second_point(copiedLine, chart.point.now(close))\nThe index field of the secondPoint is length bars beyond the current bar_index. Since the maximum x-coordinate allowed with xloc.bar_index is bar_index + 500, we’ve set the maxval of the length input to 500.\nDeleting lines¶\nTo delete a line id drawn by a script, use the line.delete() function. This function removes the line instance from the script and its drawing on the chart.\nDeleting line instances is often handy when one wants to only keep a specific number of lines on the chart at any given time or conditionally remove drawings as a chart progresses.\nFor example, this script draws a horizontal line with the extend.right property whenever an RSI crosses its EMA.\nThe script stores all line IDs in a lines array that it uses as a queue to only display the last numberOfLines on the chart. When the size of the array exceeds the specified numberOfLines, the script removes the array’s oldest line ID using array.shift() and deletes it with line.delete():\n//@variable The maximum number of lines allowed on the chart.\nconst int MAX_LINES_COUNT = 500\nindicator(\"Deleting lines demo\", \"RSI cross levels\", max_lines_count = MAX_LINES_COUNT)\n//@variable The length of the RSI.\nint rsiLength = input.int(14, \"RSI length\", 2)\n//@variable The length of the RSI's EMA.\nint emaLength = input.int(28, \"RSI average length\", 2)\n//@variable The maximum number of lines to keep on the chart.\nint numberOfLines = input.int(20, \"Lines on the chart\", 0, MAX_LINES_COUNT)\n//@variable An array containing the IDs of lines on the chart.\nvar array<line> lines = array.new<line>()\n//@variable An `rsiLength` RSI of `close`.\nfloat rsi = ta.rsi(close, rsiLength)\n//@variable A `maLength` EMA of the `rsi`.\nfloat rsiMA = ta.ema(rsi, emaLength)\nif ta.cross(rsi, rsiMA)\n//@variable The color of the horizontal line.\ncolor lineColor = rsi > rsiMA ? color.green : color.red\n// Draw a new horizontal line. Uses the default `xloc.bar_index`.\nnewLine = line.new(bar_index, rsiMA, bar_index + 1, rsiMA, extend = extend.right, color = lineColor, width = 2)\n// Push the `newLine` into the `lines` array.\nlines.push(newLine)\n// Delete the oldest line when the size of the array exceeds the specified `numberOfLines`.\nif array.size(lines) > numberOfLines\nline.delete(lines.shift())\n// Plot the `rsi` and `rsiMA`.\nplot(rsi, \"RSI\", color.new(color.blue, 40))\nplot(rsiMA, \"EMA of RSI\", color.new(color.gray, 30))\nWe declared a MAX_LINES_COUNT variable with the “const int” qualified type, which the script uses as the max_lines_count in the indicator() function and the maxval of the input.int() assigned to the numberOfLines variable.\nThis example uses the second overload of the line.new() function, which specifies x1, y1, x2, and y2 coordinates independently.\nBoxes¶\nThe built-ins in the box.* namespace create and manage box objects:\nThe box.new() function creates a new box.\nThe box.set_*() functions modify box properties.\nThe box.get_*() functions retrieve values from a box instance.\nThe box.copy() function clones a box instance.\nThe box.delete() function deletes a box instance.\nThe box.all variable references a read-only array containing the IDs of all boxes displayed by the script. The array’s size depends on the max_boxes_count of the indicator() or strategy() declaration statement and the number of boxes the script has drawn.\nAs with lines, users can call box.set_*(), box.get_*(), box.copy(), and box.delete() built-ins as functions or methods.\nCreating boxes¶\nThe box.new() function creates a new box object to display on the chart. It has the following signatures:\nbox.new(top_left, bottom_right, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family) → series box\nbox.new(left, top, right, bottom, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family) → series box\nThis function’s first overload includes the top_left and bottom_right parameters, which accept chart.point objects representing the top-left and bottom-right corners of the box, respectively. The function copies the information from these chart points to set the coordinates of the box’s corners. Whether it uses the index or time fields of the top_left and bottom_right points as x-coordinates depends on the function’s xloc value.\nThe second overload specifies left, top, right, and bottom edges of the box. The left and right parameters accept int values specifying the box’s left and right x-coordinates, which can be bar index or time values depending on the xloc value in the function call. The top and bottom parameters accept float values representing the box’s top and bottom y-coordinates.\nThe function’s additional parameters are identical in both overloads:\nborder_color Specifies the color of all four of the box’s borders. The default is color.blue. border_width Specifies the width of the borders, in pixels. Its default value is 1. border_style Specifies the style of the borders, which can be any of the options in the Box styles section of this page. extend Determines whether the box’s borders extend infinitely beyond the left or right x-coordinates. It accepts one of the following values: extend.left, extend.right, extend.both, or extend.none (default). xloc \nDetermines whether the left and right edges of the box use bar index or time values as x-coordinates. The default is xloc.bar_index.\nIn the first overload, an xloc value of xloc.bar_index means that the function will use the index fields of the top_left and bottom_right chart points, and an xloc value of xloc.bar_time means that it will use their time fields.\nIn the second overload, using an xloc value of xloc.bar_index means the function treats the left and right values as bar indices, and xloc.bar_time means it will treat them as timestamps.\nWhen the specified x-coordinates represent bar index values, it’s important to note that the minimum x-coordinate allowed is bar_index - 9999. For larger offsets, one can use xloc.bar_time.\nbgcolor Specifies the background color of the space inside the box. The default value is color.blue. text The text to display inside the box. By default, its value is an empty string. text_size Specifies the size of the text within the box. It accepts one of the following values: size.tiny, size.small, size.normal, size.large, size.huge, or size.auto (default). text_color Controls the color of the text. Its default is color.black. text_halign Specifies the horizontal alignment of the text within the box’s boundaries. It accepts one of the following: text.align_left, text.align_right, or text.align_center (default). text_valign Specifies the vertical alignment of the text within the box’s boundaries. It accepts one of the following: text.align_top, text.align_bottom, or text.align_center (default). text_wrap Determines whether the box will wrap the text within it. If its value is text.wrap_auto, the box wraps the text to ensure it does not span past its vertical borders. It also clips the wrapped text when it extends past the bottom. If the value is text.wrap_none, the box displays the text on a single line that can extend beyond its borders. The default is text.wrap_none. text_font_family Defines the font family of the box’s text. Using font.family_default displays the box’s text with the system’s default font. The font.family_monospace displays the text in a monospace format. The default value is font.family_default. \nLet’s write a simple script to display boxes on a chart. The example below draws a box projecting each bar’s high and low values from the horizontal center of the current bar to the center of the next available bar.\nOn each bar, the script creates topLeft and bottomRight points via chart.point.now() and chart.point_from_index(), then calls box.new() to construct a new box and display it on the chart. It also highlights the background on the unconfirmed chart bar using bgcolor() to indicate that it redraws that box until the bar’s last update:\nindicator(\"Creating boxes demo\", overlay = true)\n//@variable The `chart.point` for the top-left corner of the box. Contains `index` and `time` information.\ntopLeft = chart.point.now(high)\n//@variable The `chart.point` for the bottom-right corner of the box. Does not contain `time` information.\nbottomRight = chart.point.from_index(bar_index + 1, low)\n// Draw a box using the `topLeft` and `bottomRight` corner points. Uses the `index` fields as x-coordinates.\nbox.new(topLeft, bottomRight, color.purple, 2, bgcolor = color.new(color.gray, 70))\n// Color the background on the unconfirmed bar.\nbgcolor(barstate.isconfirmed ? na : color.new(color.orange, 70), title = \"Unconfirmed bar highlight\")\nThe bottomRight point’s index field is one bar greater than the index in the topLeft. If the x-coordinates of the corners were equal, the script would draw a vertical line at the horizontal center of each bar, resembling the example in this page’s Creating lines section.\nSimilar to lines, if the topLeft and bottomRight contained identical coordinates, the box wouldn’t display on the chart since there would be no space between them to draw. However, its ID would still exist.\nThis script only displays approximately the last 50 boxes on the chart, as we have not specified a max_boxes_count in the indicator() function call.\nModifying boxes¶\nMultiple setter functions exist in the box.* namespace, allowing scripts to modify the properties of box objects:\nbox.set_top_left_point() and box.set_bottom_right_point() respectively update the top-left and bottom-right coordinates of the id box using information from the specified point.\nbox.set_left() and box.set_right() set the left or right x-coordinate of the id box to a new left/right value, which can be a bar index or time value depending on the box’s xloc property.\nbox.set_top() and box.set_bottom() set the top or bottom y-coordinate of the id box to a new top/bottom value.\nbox.set_lefttop() sets the left and top coordinates of the id box, and box.set_rightbottom() sets its right and bottom coordinates.\nbox.set_border_color(), box.set_border_width() and box.set_border_style() respectively update the color, width, and style of the id box’s border.\nbox.set_extend() sets the horizontal extend property of the id box.\nbox.set_bgcolor() sets the color of the space inside the id box to a new color.\nbox.set_text(), box.set_text_size(), box.set_text_color(), box.set_text_halign(), box.set_text_valign(), box.set_text_wrap(), and box.set_text_font_family() update the id box’s text-related properties.\nAs with setter functions in the line.* namespace, all box setters modify the id box directly without returning a value, and each setter function accepts “series” arguments.\nNote that, unlike lines, the box.* namespace does not contain a setter function to modify a box’s xloc. Users must create a new box with the desired xloc setting for such cases.\nThis example uses boxes to visualize the ranges of upward and downward bars with the highest volume over a user-defined timeframe. When the script detects a change in the timeframe, it assigns new boxes to its upBox and downBox variables, resets its upVolume and downVolume values, and highlights the chart background.\nWhen an upward or downward bar’s volume exceeds the upVolume or downVolume, the script updates the volume-tracking variables and calls box.set_top_left_point() and box.set_bottom_right_point() to update the upBox or downBox coordinates. The setters use the information from the chart points created with chart.point.now() and chart.point.from_time() to project that bar’s high and low values from the current time to the closing time of the timeframe:\nindicator(\"Modifying boxes demo\", \"High volume boxes\", true, max_boxes_count = 100)\n//@variable The timeframe of the calculation.\nstring timeframe = input.timeframe(\"D\", \"Timeframe\")\n//@variable A box projecting the range of the upward bar with the highest `volume` over the `timeframe`.\nvar box upBox = na\n//@variable A box projecting the range of the downward bar with the lowest `volume` over the `timeframe`.\nvar box downBox = na\n//@variable The highest volume of upward bars over the `timeframe`.\nvar float upVolume = na\n//@variable The highest volume of downward bars over the `timeframe`.\nvar float downVolume = na\n// Color variables.\nvar color upBorder = color.teal\nvar color upFill = color.new(color.teal, 90)\nvar color downBorder = color.maroon\nvar color downFill = color.new(color.maroon, 90)\n//@variable The closing time of the `timeframe`.\nint closeTime = time_close(timeframe)\n//@variable Is `true` when a new bar starts on the `timeframe`.\nbool changeTF = timeframe.change(timeframe)\n//@variable The `chart.point` for the top-left corner of the boxes. Contains `index` and `time` information.\ntopLeft = chart.point.now(high)\n//@variable The `chart.point` for the bottom-right corner of the boxes. Does not contain `index` information.\nbottomRight = chart.point.from_time(closeTime, low)\nif changeTF and not na(volume)\nif close > open\n// Update `upVolume` and `downVolume` values.\nupVolume := volume\ndownVolume := 0.0\n// Draw a new `upBox` using `time` and `price` info from the `topLeft` and `bottomRight` points.\nupBox := box.new(topLeft, bottomRight, upBorder, 3, xloc = xloc.bar_time, bgcolor = upFill)\n// Draw a new `downBox` with `na` coordinates.\ndownBox := box.new(na, na, na, na, downBorder, 3, xloc = xloc.bar_time, bgcolor = downFill)\nelse\n// Update `upVolume` and `downVolume` values.\nupVolume := 0.0\ndownVolume := volume\n// Draw a new `upBox` with `na` coordinates.\nupBox := box.new(na, na, na, na, upBorder, 3, xloc = xloc.bar_time, bgcolor = upFill)\n// Draw a new `downBox` using `time` and `price` info from the `topLeft` and `bottomRight` points.\ndownBox := box.new(topLeft, bottomRight, downBorder, 3, xloc = xloc.bar_time, bgcolor = downFill)\n// Update the ``upVolume`` and change the ``upBox`` coordinates when volume increases on an upward bar.\nelse if close > open and volume > upVolume\nupVolume := volume\nbox.set_top_left_point(upBox, topLeft)\nbox.set_bottom_right_point(upBox, bottomRight)\n// Update the ``downVolume`` and change the ``downBox`` coordinates when volume increases on a downward bar.\nelse if close <= open and volume > downVolume\ndownVolume := volume\nbox.set_top_left_point(downBox, topLeft)\nbox.set_bottom_right_point(downBox, bottomRight)\n// Highlight the background when a new `timeframe` bar starts.\nbgcolor(changeTF ? color.new(color.orange, 70) : na, title = \"Timeframe change highlight\")\nThe indicator() function call contains max_boxes_count = 100, meaning the script will preserve the last 100 boxes on the chart.\nWe utilized both overloads of box.new() in this example. On the first bar of the timeframe, the script calls the first overload for the upBox when the bar is rising, and it calls that overload for the downBox when the bar is falling. It uses the second overload to assign a new box with na values to the other box variable on that bar.\nBox styles¶\nUsers can include one of the following line.style_* variables in their box.new() or box.set_border_style() function calls to set the border styles of boxes drawn by their scripts:\nReading box values¶\nThe box.* namespace features getter functions that allow scripts to retrieve coordinate values from a box instance:\nbox.get_left() and box.get_right() respectively get the x-coordinates of the left and right edges of the id box. Whether the value returned represents a bar index or time value depends on the box’s xloc property.\nbox.get_top() and box.get_bottom() respectively get the top and bottom y-coordinates of the id box.\nThe example below draws boxes to visualize hypothetical price ranges over a period of length bars. At the start of each new period, it uses the average candle range multiplied by the scaleFactor input to calculate the corner points of a box centered at the hl2 price with an initialRange height. After drawing the first box, it creates numberOfBoxes - 1 new boxes inside a for loop.\nWithin each loop iteration, the script gets the lastBoxDrawn by retrieving the last element from the read-only box.all array, then calls box.get_top() and box.get_bottom() to get its y-coordinates. It uses these values to calculate the coordinates for a new box that’s scaleFactor times taller than the previous:\nindicator(\"Reading box values demo\", \"Nested boxes\", overlay = true, max_boxes_count = 500)\n//@variable The number of bars in the range calculation.\nint length = input.int(10, \"Length\", 2, 500)\n//@variable The number of nested boxes drawn on each period.\nint numberOfBoxes = input.int(5, \"Nested box count\", 1)\n//@variable The scale factor applied to each box.\nfloat scaleFactor = input.float(1.6, \"Scale factor\", 1)\n//@variable The initial box range.\nfloat initialRange = scaleFactor * ta.sma(high - low, length)\nif bar_index % length == 0\n//@variable The top-left `chart.point` for the initial box. Does not contain `time` information.\ntopLeft = chart.point.from_index(bar_index, hl2 + initialRange / 2)\n//@variable The bottom-right `chart.point` for the initial box. Does not contain `time` information.\nbottomRight = chart.point.from_index(bar_index + length, hl2 - initialRange / 2)\n// Calculate border and fill colors of the boxes.\nborderColor = color.rgb(math.random(100, 255), math.random(0, 100), math.random(100, 255))\nbgColor = color.new(borderColor, math.max(100 * (1 - 1/numberOfBoxes), 90))\n// Draw a new box using the `topLeft` and `bottomRight` points. Uses their `index` fields as x-coordinates.\nbox.new(topLeft, bottomRight, borderColor, 2, bgcolor = bgColor)\nif numberOfBoxes > 1\n// Loop to create additional boxes.\nfor i = 1 to numberOfBoxes - 1\n//@variable The last box drawn by the script.\nbox lastBoxDrawn = box.all.last()\n//@variable The top price of the last box.\nfloat top = box.get_top(lastBoxDrawn)\n//@variable The bottom price of the last box.\nfloat bottom = box.get_bottom(lastBoxDrawn)\n//@variable The scaled range of the new box.\nfloat newRange = scaleFactor * (top - bottom) * 0.5\n//@variable The midpoint between the `bottom` and `top`.\nfloat middle = 0.5 * (top + bottom)\n// Update the `price` fields of the `topLeft` and `bottomRight` points.\n// This does not affect the coordinates of previous boxes.\ntopLeft.price := hl2 + newRange\nbottomRight.price := hl2 - newRange\n// Draw a new box using the updated `topLeft` and `bottomRight` points.\nbox.new(topLeft, bottomRight, borderColor, 2, bgcolor = bgColor)\nThe indicator() function call uses max_boxes_count = 500, meaning the script can display up to 500 boxes on the chart.\nEach drawing has a right index length bars beyond the left index. Since the x-coordinates of these drawings can be up to 500 bars into the future, we’ve set the maxval of the length input to 500.\nOn each new period, the script uses randomized color.rgb() values for the border_color and bgcolor of the boxes.\nEach box.new() call copies the coordinates from the chart.point objects assigned to the topLeft and bottomRight variables, which is why the script can modify their price fields on each loop iteration without affecting the other boxes.\nCloning boxes¶\nTo clone a specific box id, use box.copy(). This function copies the box and its properties. Any changes to the copied box do not affect the original.\nFor example, this script declares an originalBox variable on the first bar and assigns a new box to it once every length bars. On other bars, it uses box.copy() to create a copiedBox and calls box.set_*() functions to modify its properties. As shown on the chart below, these changes do not modify the originalBox:\nindicator(\"Cloning boxes demo\", overlay = true, max_boxes_count = 500)\n//@variable The number of bars between each new mainLine assignment.\nint length = input.int(20, \"Length\", 2)\n//@variable The `chart.point` for the top-left of the `originalBox`. Contains `time` and `index` information.\ntopLeft = chart.point.now(high)\n//@variable The `chart.point` for the bottom-right of the `originalBox`. Does not contain `time` information.\nbottomRight = chart.point.from_index(bar_index + 1, low)\n//@variable A new box with `topLeft` and `bottomRight` corners on every `length` bars.\nvar box originalBox = na\n//@variable Is teal when the bar is rising, maroon when it's falling.\ncolor originalColor = close > open ? color.teal : color.maroon\nif bar_index % length == 0\n// Assign a new box using the `topLeft` and `bottomRight` info to the `originalBox`.\n// This box uses the `index` fields from the points as x-coordinates.\noriginalBox := box.new(topLeft, bottomRight, originalColor, 2, bgcolor = color.new(originalColor, 60))\nelse\n//@variable A clone of the `originalBox`.\nbox copiedBox = box.copy(originalBox)\n// Modify the `copiedBox`. These changes do not affect the `originalBox`.\nbox.set_top(copiedBox, high)\nbox.set_bottom_right_point(copiedBox, bottomRight)\nbox.set_border_color(copiedBox, color.gray)\nbox.set_border_width(copiedBox, 1)\nbox.set_bgcolor(copiedBox, na)\nDeleting boxes¶\nTo delete boxes drawn by a script, use box.delete(). As with *.delete() functions in other drawing namespaces, this function is handy for conditionally removing boxes or maintaining a specific number of boxes on the chart.\nThis example displays boxes representing periodic cumulative volume values. The script creates a new box ID and stores it in a boxes array once every length bars. If the array’s size exceeds the specified numberOfBoxes, the script removes the oldest box from the array using array.shift() and deletes it using box.delete().\nOn other bars, it accumulates volume over each period by modifying the top of the last box in the boxes array. The script then uses for loops to find the highestTop of all the array’s boxes and set the bgcolor of each box with a gradient color based on its box.get_top() value relative to the highestTop:\n//@variable The maximum number of boxes to show on the chart.\nconst int MAX_BOXES_COUNT = 500\nindicator(\"Deleting boxes demo\", \"Cumulative volume boxes\", format = format.volume, max_boxes_count = MAX_BOXES_COUNT)\n//@variable The number of bars in each period.\nint length = input.int(20, \"Length\", 1)\n//@variable The maximum number of volume boxes in the calculation.\nint numberOfBoxes = input.int(10, \"Number of boxes\", 1, MAX_BOXES_COUNT)\n//@variable An array containing the ID of each box displayed by the script.\nvar boxes = array.new<box>()\nif bar_index % length == 0\n// Push a new box into the `boxes` array. The box has the default `xloc.bar_index` property.\nboxes.push(box.new(bar_index, 0, bar_index + 1, 0, #000000, 2, text_color = #000000))\n// Shift the oldest box out of the array and delete it when the array's size exceeds the `numberOfBoxes`.\nif boxes.size() > numberOfBoxes\nbox.delete(boxes.shift())\n//@variable The last box drawn by the script as of the current chart bar.\nbox lastBox = boxes.last()\n// Add the current bar's volume to the top of the `lastBox` and update the `right` index.\nlastBox.set_top(lastBox.get_top() + volume)\nlastBox.set_right(bar_index + 1)\n// Display the top of the `lastBox` as volume-formatted text.\nlastBox.set_text(str.tostring(lastBox.get_top(), format.volume))\n//@variable The highest `top` of all boxes in the `boxes` array.\nfloat highestTop = 0.0\nfor id in boxes\nhighestTop := math.max(id.get_top(), highestTop)\n// Set the `bgcolor` of each `id` in `boxes` with a gradient based on the ratio of its `top` to the `highestTop`.\nfor id in boxes\nid.set_bgcolor(color.from_gradient(id.get_top() / highestTop, 0, 1, color.purple, color.orange))\nAt the top of the code, we’ve declared a MAX_BOXES_COUNT variable with the “const int” qualified type. We use this value as the max_boxes_count in the indicator() function and the maximum possible value of the numberOfBoxes input.\nThis script uses the second overload of the box.new() function, which specifies the box’s left, top, right, and bottom coordinates separately.\nWe’ve included format.volume as the format argument in the indicator() call, which tells the script that the y-axis of the chart pane represents volume values. Each box also displays its top value as volume-formatted text.\nPolylines¶\nPine Script™ polylines are advanced drawings that sequentially connect the coordinates from an array of chart.point instances using straight or curved line segments.\nThese powerful drawings can connect up to 10,000 points at any available location on the chart, allowing scripts to draw custom series, polygons, and other complex geometric formations that are otherwise difficult or impossible to draw using line or box objects.\nThe polyline.* namespace features the following built-ins for creating and managing polyline objects:\nThe polyline.new() function creates a new polyline instance.\nThe polyline.delete() function deletes an existing polyline instance.\nThe polyline.all variable references a read-only array containing the IDs of all polylines displayed by the script. The array’s size depends on the max_polylines_count of the indicator() or strategy() declaration statement and the number of polylines drawn by the script.\nUnlike lines or boxes, polylines do not have functions for modification or reading their properties. To redraw a polyline on the chart, one can delete the existing instance and create a new polyline with the desired changes.\nCreating polylines¶\nThe polyline.new() function creates a new polyline instance to display on the chart. It has the following signature:\npolyline.new(points, curved, closed, xloc, line_color, fill_color, line_style, line_width) → series polyline\nThe following eight parameters affect the behavior of a polyline drawing:\npoints Accepts an array of chart.point objects that determine the coordinates of each point in the polyline. The drawing connects the coordinates from each element in the array sequentially, starting from the first. Whether the polyline uses the index or time field from each chart point for its x-coordinates depends on the xloc value in the function call. curved Specifies whether the drawing uses curved line segments to connect each chart.point in the points array. The default value is false, meaning it uses straight line segments. closed Controls whether the polyline will connect the last chart.point in the points array to the first, forming a closed polyline. The default value is false. xloc Specifies which field from each chart.point in the points array the polyline uses for its x-coordinates. When its value is xloc.bar_index, the function uses the index fields to create the polyline. When its value is xloc.bar_time, the function uses the time fields. The default value is xloc.bar_index. line_color Specifies the color of all line segments in the polyline drawing. The default is color.blue. fill_color Controls the color of the closed space filled by the polyline drawing. Its default value is na. line_style Specifies the style of the polyline, which can be any of the available options in the Line styles section of this page. The default is line.style_solid. line_width Specifies the width of the polyline, in pixels. The default value is 1. \nThis script demonstrates a simple example of drawing a polyline on the chart. It pushes a new chart.point with an alternating price value into a points array and colors the background with bgcolor() once every length bars.\nOn the last confirmed historical bar, the script draws a new polyline on the chart, connecting the coordinates from each chart point in the array, starting from the first:\nindicator(\"Creating polylines demo\", \"Oscillating polyline\")\n//@variable The number of bars between each point in the drawing.\nint length = input.int(20, \"Length between points\", 2)\n//@variable An array of `chart.point` objects to sequentially connect with a polyline.\nvar points = array.new<chart.point>()\n//@variable The y-coordinate of each point in the `points`. Alternates between 1 and -1 on each `newPoint`.\nvar int yValue = 1\n//@variable Is `true` once every `length` bars, `false` otherwise.\nbool newPoint = bar_index % length == 0\nif newPoint\n// Push a new `chart.point` into the `points`. The new point contains `time` and `index` info.\npoints.push(chart.point.now(yValue))\n// Change the sign of the `yValue`.\nyValue *= -1\n// Draw a new `polyline` on the last confirmed historical chart bar.\n// The polyline uses the `time` field from each `chart.point` in the `points` array as x-coordinates.\nif barstate.islastconfirmedhistory\npolyline.new(points, xloc = xloc.bar_time, line_color = #9151A6, line_width = 3)\n// Highlight the chart background on every `newPoint` condition.\nbgcolor(newPoint ? color.new(color.gray, 70) : na, title = \"New point highlight\")\nThis script uses only one polyline to connect each chart point from the array with straight line segments, and this drawing spans throughout the available chart data, starting from the first bar.\nWhile one can achieve a similar effect using lines, doing so would require a new line instance on each occurrence of the newPoint condition, and such a drawing would be limited to a maximum of 500 line segments. This single unclosed polyline drawing, on the other hand, can contain up to 9,999 line segments.\nCurved drawings¶\nPolylines can draw curves that are otherwise impossible to produce with lines or boxes. When enabling the curved parameter of the polyline.new() function, the resulting polyline interpolates nonlinear values between the coordinates from each chart.point in its array of points to generate a curvy effect.\nFor instance, the “Oscillating polyline” script in our previous example uses straight line segments to produce a drawing resembling a triangle wave, meaning a waveform that zig-zags between its peaks and valleys. If we set the curved parameter in the polyline.new() call from that example to true, the resulting drawing would connect the points using curved segments, producing a smooth, nonlinear shape similar to a sine wave:\nindicator(\"Curved drawings demo\", \"Smooth oscillating polyline\")\n//@variable The number of bars between each point in the drawing.\nint length = input.int(20, \"Length between points\", 2)\n//@variable An array of `chart.point` objects to sequentially connect with a polyline.\nvar points = array.new<chart.point>()\n//@variable The y-coordinate of each point in the `points`. Alternates between 1 and -1 on each `newPoint`.\nvar int yValue = 1\n//@variable Is `true` once every `length` bars, `false` otherwise.\nbool newPoint = bar_index % length == 0\nif newPoint\n// Push a new `chart.point` into the `points`. The new point contains `time` and `index` info.\npoints.push(chart.point.now(yValue))\n// Change the sign of the `yValue`.\nyValue *= -1\n// Draw a new curved `polyline` on the last confirmed historical chart bar.\n// The polyline uses the `time` field from each `chart.point` in the `points` array as x-coordinates.\nif barstate.islastconfirmedhistory\npolyline.new(points, curved = true, xloc = xloc.bar_time, line_color = #9151A6, line_width = 3)\n// Highlight the chart background on every `newPoint` condition.\nbgcolor(newPoint ? color.new(color.gray, 70) : na, title = \"New point highlight\")\nNotice that in this example, the smooth curves have relatively consistent behavior, and no portion of the drawing extends past its defined coordinates, which is not always the case when drawing curved polylines. The data used to construct a polyline heavily impacts the smooth, piecewise function it interpolates between its points. In some cases, the interpolated curve can reach beyond its actual coordinates.\nLet’s add some variation to the chart points in our example’s points array to demonstrate this behavior. In the version below, the script multiplies the yValue by a random value in the chart.point.now() calls.\nTo visualize the behavior, this script also creates a horizontal line at the price value from each chart.point in the points array, and it displays another polyline connecting the same points with straight line segments. As we see on the chart, both polylines pass through all coordinates from the points array. However, the curvy polyline occasionally reaches beyond the vertical boundaries indicated by the horizontal lines, whereas the polyline drawn using straight segments does not:\nindicator(\"Curved drawings demo\", \"Random oscillating polylines\")\n//@variable The number of bars between each point in the drawing.\nint length = input.int(20, \"Length between points\", 2)\n//@variable An array of `chart.point` objects to sequentially connect with a polyline.\nvar points = array.new<chart.point>()\n//@variable The sign of each `price` in the `points`. Alternates between 1 and -1 on each `newPoint`.\nvar int yValue = 1\n//@variable Is `true` once every `length` bars.\nbool newPoint = bar_index % length == 0\nif newPoint\n// Push a new `chart.point` with a randomized `price` into the `points`.\n// The new point contains `time` and `index` info.\npoints.push(chart.point.now(yValue * math.random()))\n// Change the sign of the `yValue`.\nyValue *= -1\n//@variable The newest `chart.point`.\nlastPoint = points.last()\n// Draw a horizontal line at the `lastPoint.price`. This line uses the default `xloc.bar_index`.\nline.new(lastPoint.index - length, lastPoint.price, lastPoint.index + length, lastPoint.price, color = color.red)\n// Draw two `polyline` instances on the last confirmed chart bar.\n// Both polylines use the `time` field from each `chart.point` in the `points` array as x-coordinates.\nif barstate.islastconfirmedhistory\npolyline.new(points, curved = false, xloc = xloc.bar_time, line_color = #EB8A3B, line_width = 2)\npolyline.new(points, curved = true, xloc = xloc.bar_time, line_color = #9151A6, line_width = 3)\n// Highlight the chart background on every `newPoint` condition.\nbgcolor(newPoint ? color.new(color.gray, 70) : na, title = \"New point highlight\")\nClosed shapes¶\nSince a single polyline can contain numerous straight or curved line segments, and the closed parameter allows the drawing to connect the coordinates from the first and last chart.point in its array of points, we can use polylines to draw many different types of closed polygonal shapes.\nLet’s draw some polygons in Pine. The following script periodically draws randomized polygons centered at hl2 price values.\nOn each occurrence of the newPolygon condition, it clears the points array, calculates the numberOfSides and rotationOffset of the new polygon drawing based on math.random() values, then uses a for loop to push numberOfSides new chart points into the array that contain stepped coordinates from an elliptical path with xScale and yScale semi-axes. The script draws the polygon by connecting each chart.point from the points array using a closed polyline with straight line segments:\nindicator(\"Closed shapes demo\", \"N-sided polygons\", true)\n//@variable The size of the horizontal semi-axis.\nfloat xScale = input.float(3.0, \"X scale\", 1.0)\n//@variable The size of the vertical semi-axis.\nfloat yScale = input.float(1.0, \"Y scale\") * ta.atr(2)\n//@variable An array of `chart.point` objects containing vertex coordinates.\nvar points = array.new<chart.point>()\n//@variable The condition that triggers a new polygon drawing. Based on the horizontal axis to prevent overlaps.\nbool newPolygon = bar_index % int(math.round(2 * xScale)) == 0 and barstate.isconfirmed\nif newPolygon\n// Clear the `points` array.\npoints.clear()\n//@variable The number of sides and vertices in the new polygon.\nint numberOfSides = int(math.random(3, 7))\n//@variable A random rotation offset applied to the new polygon, in radians.\nfloat rotationOffset = math.random(0.0, 2.0) * math.pi\n//@variable The size of the angle between each vertex, in radians.\nfloat step = 2 * math.pi / numberOfSides\n//@variable The counter-clockwise rotation angle of each vertex.\nfloat angle = rotationOffset\nfor i = 1 to numberOfSides\n//@variable The approximate x-coordinate from an ellipse at the `angle`, rounded to the nearest integer.\nint xValue = int(math.round(xScale * math.cos(angle))) + bar_index\n//@variable The y-coordinate from an ellipse at the `angle`.\nfloat yValue = yScale * math.sin(angle) + hl2\n// Push a new `chart.point` containing the `xValue` and `yValue` into the `points` array.\n// The new point does not contain `time` information.\npoints.push(chart.point.from_index(xValue, yValue))\n// Add the `step` to the `angle`.\nangle += step\n// Draw a closed polyline connecting the `points`.\n// The polyline uses the `index` field from each `chart.point` in the `points` array.\npolyline.new(\npoints, closed = true, line_color = color.navy, fill_color = color.new(color.orange, 50), line_width = 3\n)\nThis example shows the last ~50 polylines on the chart, as we have not specified a max_polylines_count value in the indicator() function call.\nThe yScale calculation multiplies an input.float() by ta.atr(2) to adapt the vertical scale of the drawings to recent price ranges.\nThe resulting polygons have a maximum width of twice the horizontal semi-axis (2 * xScale), rounded to the nearest integer. The newPolygon condition uses this value to prevent the polygon drawings from overlapping.\nThe script rounds the xValue calculation to the nearest integer because the index field of a chart.point only accepts an int value, as the x-axis of the chart does not include fractional bar indices.\nDeleting polylines¶\nTo delete a specific polyline id, use polyline.delete(). This function removes the polyline object from the script and its drawing on the chart.\nAs with other drawing objects, we can use polyline.delete() to maintain a specific number of polyline drawings or conditionally remove drawings from a chart.\nFor example, the script below periodically draws approximate arithmetic spirals and stores their polyline IDs in an array, which it uses as a queue to manage the number of drawings it displays.\nWhen the newSpiral condition occurs, the script creates a points array and adds chart points within a for loop. On each loop iteration, it calls the spiralPoint() user-defined function to create a new chart.point containing stepped values from an elliptical path that grows with respect to the angle. The script then creates a randomly colored curved polyline connecting the coordinates from the points and pushes its ID into the polylines array.\nWhen the array’s size exceeds the specified numberOfSpirals, the script removes the oldest polyline using array.shift() and deletes the object using polyline.delete():\n//@variable The maximum number of polylines allowed on the chart.\nconst int MAX_POLYLINES_COUNT = 100\nindicator(\"Deleting polylines example\", \"Spirals\", true, max_polylines_count = MAX_POLYLINES_COUNT)\n//@variable The number of spiral drawings on the chart.\nint numberOfSpirals = input.int(10, \"Spirals shown\", 1, MAX_POLYLINES_COUNT)\n//@variable The number of full spiral rotations to draw.\nint rotations = input.int(5, \"Rotations\", 1)\n//@variable The scale of the horizontal semi-axis.\nfloat xScale = input.float(1.0, \"X scale\")\n//@variable The scale of the vertical semi-axis.\nfloat yScale = input.float(0.2, \"Y scale\") * ta.atr(2)\n//@function Calculates an approximate point from an elliptically-scaled arithmetic spiral.\n//@returns A `chart.point` with `index` and `price` information.\nspiralPoint(float angle, int xOffset, float yOffset) =>\nresult = chart.point.from_index(\nint(math.round(angle * xScale * math.cos(angle))) + xOffset,\nangle * yScale * math.sin(angle) + yOffset\n)\n//@variable An array of polylines.\nvar polylines = array.new<polyline>()\n//@variable The condition to create a new spiral.\nbool newSpiral = bar_index % int(math.round(4 * math.pi * rotations * xScale)) == 0\nif newSpiral\n//@variable An array of `chart.point` objects for the `spiral` drawing.\npoints = array.new<chart.point>()\n//@variable The counter-clockwise angle between calculated points, in radians.\nfloat step = math.pi / 2\n//@variable The rotation angle of each calculated point on the spiral, in radians.\nfloat theta = 0.0\n// Loop to create the spiral's points. Creates 4 points per full rotation.\nfor i = 0 to rotations * 4\n//@variable A new point on the calculated spiral.\nchart.point newPoint = spiralPoint(theta, bar_index, ohlc4)\n// Add the `newPoint` to the `points` array.\npoints.push(newPoint)\n// Add the `step` to the `theta` angle.\ntheta += step\n//@variable A random color for the new `spiral` drawing.\ncolor spiralColor = color.rgb(math.random(150, 255), math.random(0, 100), math.random(150, 255))\n//@variable A new polyline connecting the spiral points. Uses the `index` field from each point as x-coordinates.\npolyline spiral = polyline.new(points, true, line_color = spiralColor, line_width = 3)\n// Push the new `spiral` into the `polylines` array.\npolylines.push(spiral)\n// Shift the first polyline out of the array and delete it when the array's size exceeds the `numberOfSpirals`.\nif polylines.size() > numberOfSpirals\npolyline.delete(polylines.shift())\n// Highlight the background when `newSpiral` is `true`.\nbgcolor(newSpiral ? color.new(color.blue, 70) : na, title = \"New drawing highlight\")\nWe declared a MAX_POLYLINES_COUNT global variable with a constant value of 100. The script uses this constant as the max_polylines_count value in the indicator() function and the maxval of the numberOfSpirals input.\nAs with our “N-sided polygons” example in the previous section, we round the calculation of x-coordinates to the nearest integer since the index field of a chart.point can only accept an int value.\nDespite the smooth appearance of the drawings, each polyline’s points array only contains four chart.point objects per spiral rotation. Since the polyline.new() call includes curved = true, each polyline uses smooth curves to connect their points, producing a visual approximation of the spiral’s actual curvature.\nThe width of each spiral is approximately 4 * math.pi * rotations * xScale, rounded to the nearest integer. We use this value in the newSpiral condition to space each drawing and prevent overlaps.\nRedrawing polylines¶\nIt may be desirable in some cases to change a polyline drawing throughout a script’s execution. While the polyline.* namespace does not contain built-in setter functions, we can redraw polylines referenced by variables or collections by deleting the existing polylines and assigning new instances with the desired changes.\nThe following example uses polyline.delete() and polyline.new() calls to update the value of a polyline variable.\nThis script draws closed polylines that connect the open, high, low, and close points of periods containing length bars. It creates a currentDrawing variable on the first bar and assigns a polyline ID to it on every chart bar. It uses the openPoint, highPoint, lowPoint, and closePoint variables to reference chart points that track the period’s developing OHLC values. As new values emerge, the script assigns new chart.point objects to the variables, collects them in an array using array.from, then creates a new polyline connecting the coordinates from the array’s points and assigns it to the currentDrawing.\nWhen the newPeriod condition is false (i.e., the current period is not complete), the script deletes the polyline referenced by the currentDrawing before creating a new one, resulting in a dynamic drawing that changes over the developing period:\nindicator(\"Redrawing polylines demo\", \"OHLC polygons\", true, max_polylines_count = 100)\n//@variable The length of the period.\nint length = input.int(100, \"Length\", 1)\n//@variable A `chart.point` representing the start of each period.\nvar chart.point openPoint = na\n//@variable A `chart.point` representing the highest point of each period.\nvar chart.point highPoint = na\n//@variable A `chart.point` representing the lowest point of each period.\nvar chart.point lowPoint = na\n//@variable A `chart.point` representing the current bar's closing point.\nclosePoint = chart.point.now(close)\n//@variable The current period's polyline drawing.\nvar polyline currentDrawing = na\n//@variable Is `true` once every `length` bars.\nbool newPeriod = bar_index % length == 0\nif newPeriod\n// Assign new chart points to the `openPoint`, `highPoint`, and `closePoint`.\nopenPoint := chart.point.now(open)\nhighPoint := chart.point.now(high)\nlowPoint := chart.point.now(low)\nelse\n// Assign a new `chart.point` to the `highPoint` when the `high` is greater than its `price`.\nif high > highPoint.price\nhighPoint := chart.point.now(high)\n// Assign a new `chart.point` to the `lowPoint` when the `low` is less than its `price`.\nif low < lowPoint.price\nlowPoint := chart.point.now(low)\n//@variable Is teal when the `closePoint.price` is greater than the `openPoint.price`, maroon otherwise.\ncolor drawingColor = closePoint.price > openPoint.price ? color.teal : color.maroon\n// Delete the polyline assigned to the `currentDrawing` if it's not a `newPeriod`.\nif not newPeriod\npolyline.delete(currentDrawing)\n// Assign a new polyline to the `currentDrawing`.\n// Uses the `index` field from each `chart.point` in its array as x-coordinates.\ncurrentDrawing := polyline.new(\narray.from(openPoint, highPoint, closePoint, lowPoint), closed = true,\nline_color = drawingColor, fill_color = color.new(drawingColor, 60)\n)\nRealtime behavior¶\nLines, boxes, and polylines are subject to both commit and rollback actions, which affect the behavior of a script when it executes on a realtime bar. See the page on Pine Script™’s Execution model.\nThis script demonstrates the effect of rollback when it executes on the realtime, unconfirmed chart bar:\nindicator(\"Realtime behavior demo\", overlay = true)\n//@variable Is orange when the `line` is subject to rollback and gray after the `line` is committed.\ncolor lineColor = barstate.isconfirmed ? color.gray : color.orange\nline.new(bar_index, hl2, bar_index + 1, hl2, color = lineColor, width = 4)\nThe line.new() call in this example creates a new line ID on each iteration when values change on the unconfirmed bar. The script automatically deletes the objects created on each change in that bar because of the rollback before each iteration. It only commits the last line created before the bar closes, and that line instance is the one that persists on the confirmed bar.\nLimitations¶\nTotal number of objects¶\nLines, boxes, and polylines consume server resources, which is why there are limits on the total number of drawings per script. When a script creates more drawing objects than the allowed limit, the Pine Script™ runtime automatically deletes the oldest ones in a process referred to as garbage collection.\nA single script can contain up to 500 lines, 500 boxes, and 100 polylines. Users can control the garbage collection limits by specifying the max_lines_count, max_boxes_count, and max_polylines_count values in their script’s indicator() or strategy() declaration statement.\nThis script demonstrates how garbage collection works in Pine. It creates a new line, box, and polyline on each chart bar. We haven’t specified values for the max_lines_count, max_boxes_count, or max_polylines_count parameters in the indicator() function call, so the script will maintain the most recent ~50 lines, boxes, and polylines on the chart, as this is the default setting for each parameter:\nindicator(\"Garbage collection demo\", overlay = true)\n//@variable A new `chart.point` at the current `bar_index` and `high`.\nfirstPoint = chart.point.now(high)\n//@variable A new `chart.point` one bar into the future at the current `low`.\nsecondPoint = chart.point.from_index(bar_index + 1, low)\n//@variable A new `chart.point` one bar into the future at the current `high`.\nthirdPoint = chart.point.from_index(bar_index + 1, high)\n// Draw a new `line` connecting the `firstPoint` to the `secondPoint`.\nline.new(firstPoint, secondPoint, color = color.red, width = 2)\n// Draw a new `box` with the `firstPoint` top-left corner and `secondPoint` bottom-right corner.\nbox.new(firstPoint, secondPoint, color.purple, 2, bgcolor = na)\n// Draw a new `polyline` connecting the `firstPoint`, `secondPoint`, and `thirdPoint` sequentially.\npolyline.new(array.from(firstPoint, secondPoint, thirdPoint), true, line_width = 2)\nWe’ve used TradingView’s “Measure” drawing tool to measure the number of bars covered by the script’s drawing objects.\nFuture references with `xloc.bar_index`¶\nObjects positioned using xloc.bar_index can contain x-coordinates no further than 500 bars into the future.\nOther contexts¶\nScripts cannot use lines, boxes, or polylines in request.*() functions. Instances of these types can use the values from request.*() calls, but scripts can only create and draw them in the chart’s context.\nThis limitation is also why drawing objects will not work when using the timeframe parameter in the indicator() declaration statement.\nHistorical buffer and `max_bars_back`¶\nUsing barstate.isrealtime in combination with drawings may sometimes produce unexpected results. For example, the intention of this script is to ignore all historical bars and draw horizontal lines spanning 300 bars back on realtime bars:\nindicator(\"Historical buffer demo\", overlay = true)\n//@variable A `chart.point` at the `bar_index` from 300 bars ago and current `close`.\nfirstPoint = chart.point.from_index(bar_index[300], close)\n//@variable The current bar's `chart.point` containing the current `close`.\nsecondPoint = chart.point.now(close)\n// Draw a new line on realtime bars.\nif barstate.isrealtime\nline.new(firstPoint, secondPoint)\nHowever, it will fail at runtime and raise an error. The script fails because it cannot determine the buffer size for historical values of the underlying time series. Although the code doesn’t contain the built-in time variable, the built-in bar_index uses the time series in its inner workings. Therefore, accessing the value of the bar_index from 300 bars back requires the history buffer of the time series to be at least 300 bars.\nPine Script™ includes a mechanism that detects the required historical buffer size automatically in most cases. It works by letting the script access historical values any number of bars back for a limited duration. In this script’s case, using barstate.isrealtime to control the drawing of lines prevents it from accessing the historical series, so it cannot infer the required historical buffer size, and the script fails.\nThe simple solution to this issue is to use the max_bars_back() function to explicitly define the historical buffer of the time series before evaluating the conditional structure:\nindicator(\"Historical buffer demo\", overlay = true)\n//@variable A `chart.point` at the `bar_index` from 300 bars ago and current `close.\nfirstPoint = chart.point.from_index(bar_index[300], close)\n//@variable The current bar's `chart.point` containing the current `close`.\nsecondPoint = chart.point.now(close)\n// Explicitly set the historical buffer of the `time` series to 300 bars.\nmax_bars_back(time, 300)\n// Draw a new line on realtime bars.\nif barstate.isrealtime\nline.new(firstPoint, secondPoint)\nSuch issues can be confusing, but they’re quite rare. The Pine Script™ team hopes to eliminate them over time."
},
{
  "text": "Non-standard charts data¶\nIntroduction\n`ticker.heikinashi()`\n`ticker.renko()`\n`ticker.linebreak()`\n`ticker.kagi()`\n`ticker.pointfigure()`\n`ticker.heikinashi()`¶\nHeikin-Ashi means average bar in Japanese. The open/high/low/close values of Heikin-Ashi candlesticks are synthetic; they are not actual market prices. They are calculated by averaging combinations of real OHLC values from the current and previous bar. The calculations used make Heikin-Ashi bars less noisy than normal candlesticks. They can be useful to make visual assessments, but are unsuited to backtesting or automated trading, as orders execute on market prices — not Heikin-Ashi prices.\nThe ticker.heikinashi() function creates a special ticker identifier for requesting Heikin-Ashi data with the request.security() function.\nThis script requests the close value of Heikin-Ashi bars and plots them on top of the normal candlesticks:\nindicator(\"HA Close\", \"\", true)\nhaTicker = ticker.heikinashi(syminfo.tickerid)\nhaClose = request.security(haTicker, timeframe.period, close)\nplot(haClose, \"HA Close\", color.black, 3)\nThe close values for Heikin-Ashi bars plotted as the black line are very different from those of real candles using market prices. They act more like a moving average.\nThe black line appears over the chart bars because we have selected “Visual Order/Bring to Front” from the script’s “More” menu.\nIf you wanted to omit values for extended hours in the last example, an intermediary ticker without extended session information would need to be created first:\nindicator(\"HA Close\", \"\", true)\nregularSessionTicker = ticker.new(syminfo.prefix, syminfo.ticker, session.regular)\nhaTicker = ticker.heikinashi(regularSessionTicker)\nhaClose = request.security(haTicker, timeframe.period, close, gaps = barmerge.gaps_on)\nplot(haClose, \"HA Close\", color.black, 3, plot.style_linebr)\nWe use the ticker.new() function first, to create a ticker without extended session information.\nWe use that ticker instead of syminfo.tickerid in our ticker.heikinashi() call.\nIn our request.security() call, we set the gaps parameter’s value to barmerge.gaps_on. This instructs the function not to use previous values to fill slots where data is absent. This makes it possible for it to return na values outside of regular sessions.\nTo be able to see this on the chart, we also need to use a special plot.style_linebr style, which breaks the plots on na values.\nThis script plots Heikin-Ashi candles under the chart:\nindicator(\"Heikin-Ashi candles\")\nCANDLE_GREEN = #26A69A\nCANDLE_RED = #EF5350\nhaTicker = ticker.heikinashi(syminfo.tickerid)\n[haO, haH, haL, haC] = request.security(haTicker, timeframe.period, [open, high, low, close])\ncandleColor = haC >= haO ? CANDLE_GREEN : CANDLE_RED\nplotcandle(haO, haH, haL, haC, color = candleColor)\nWe use a tuple with request.security() to fetch four values with the same call.\nWe use plotcandle() to plot our candles. See the Bar plotting page for more information.\n`ticker.renko()`¶\nRenko bars only plot price movements, without taking time or volume into consideration. They look like bricks stacked in adjacent columns [1]. A new brick is only drawn after the price passes the top or bottom by a predetermined amount. The ticker.renko() function creates a ticker id which can be used with request.security() to fetch Renko values, but there is no Pine Script™ function to draw Renko bars on the chart:\nindicator(\"\", \"\", true)\nrenkoTicker = ticker.renko(syminfo.tickerid, \"ATR\", 10)\nrenkoLow = request.security(renkoTicker, timeframe.period, low)\nplot(renkoLow)\n`ticker.linebreak()`¶\nThe Line Break chart type displays a series of vertical boxes that are based on price changes [1]. The ticker.linebreak() function creates a ticker id which can be used with request.security() to fetch “Line Break” values, but there is no Pine Script™ function to draw such bars on the chart:\nindicator(\"\", \"\", true)\nlineBreakTicker = ticker.linebreak(syminfo.tickerid, 3)\nlineBreakClose = request.security(lineBreakTicker, timeframe.period, close)\nplot(lineBreakClose)\n`ticker.kagi()`¶\nKagi charts are made of a continuous line that changes directions. The direction changes when the price changes [1] beyond a predetermined amount. The ticker.kagi() function creates a ticker id which can be used with request.security() to fetch “Kagi” values, but there is no Pine Script™ function to draw such bars on the chart:\nindicator(\"\", \"\", true)\nkagiBreakTicker = ticker.linebreak(syminfo.tickerid, 3)\nkagiBreakClose = request.security(kagiBreakTicker, timeframe.period, close)\nplot(kagiBreakClose)\n`ticker.pointfigure()`¶\nPoint and Figure (PnF) charts only plot price movements [1], without taking time into consideration. A column of X’s is plotted as the price rises, and O’s are plotted when price drops. The ticker.pointfigure() function creates a ticker id which can be used with request.security() to fetch “PnF” values, but there is no Pine Script™ function to draw such bars on the chart. Every column of X’s or O’s is represented with four numbers. You may think of them as synthetic OHLC PnF values:\npnfTicker = ticker.pointfigure(syminfo.tickerid, \"hl\", \"ATR\", 14, 3)\n[pnfO, pnfC] = request.security(pnfTicker, timeframe.period, [open, close], barmerge.gaps_on)\nplot(pnfO, \"PnF Open\", color.green, 4, plot.style_linebr)\nplot(pnfC, \"PnF Close\", color.red, 4, plot.style_linebr)\nFootnotes"
},
{
  "text": "Other timeframes and data¶\nIntroduction\nCommon characteristics\nUsage\n`gaps`\n`ignore_invalid_symbol`\n`currency`\n`lookahead`\nData feeds\n`request.security()`\nTimeframes\nHigher timeframes\nLower timeframes\nRequestable data\nBuilt-in variables and functions\nCalculated variables\nTuples\nUser-defined functions\nChart points\nCollections\nUser-defined types\n`request.security_lower_tf()`\nRequesting intrabar data\nIntrabar data arrays\nTuples of intrabar data\nRequesting collections\nCustom contexts\nHistorical and realtime behavior\nAvoiding Repainting\nHigher-timeframe data\nLower-timeframe data\n`request.currency_rate()`\n`request.dividends()`, `request.splits()`, and `request.earnings()`\n`request.quandl()`\n`request.financial()`\nCalculating financial metrics\nFinancial IDs\nIncome statements\nBalance sheet\nCash flow\nStatistics\n`request.economic()`\nCountry/region codes\nField codes\n`request.seed()`\nIntroduction¶\nPine Script™ allows users to request data from sources and contexts other than those their charts use. The functions we present on this page can fetch data from a variety of alternative sources:\nrequest.security() retrieves data from another symbol, timeframe, or other context.\nrequest.security_lower_tf() retrieves intrabar data, i.e., data from a timeframe lower than the chart timeframe.\nrequest.currency_rate() requests a daily rate to convert a value expressed in one currency to another.\nrequest.dividends(), request.splits(), and request.earnings() respectively retrieve information about an issuing company’s dividends, splits, and earnings.\nrequest.quandl() retrieves information from NASDAQ Data Link (formerly Quandl).\nrequest.financial() retrieves financial data from FactSet.\nrequest.economic() retrieves economic and industry data.\nrequest.seed() retrieves data from a user-maintained GitHub repository.\nNote\nThroughout this page, and in other parts of our documentation that discuss request.*() functions, we often use the term “context” to describe the ticker ID, timeframe, and any modifications (price adjustments, session settings, non-standard chart types, etc.) that apply to a chart or the data retrieved by a script.\nThese are the signatures of the functions in the request.* namespace:\nrequest.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency) → series <type>\nrequest.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency, ignore_invalid_timeframe) → array<type>\nrequest.currency_rate(from, to, ignore_invalid_currency) → series float\nrequest.dividends(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float\nrequest.splits(ticker, field, gaps, lookahead, ignore_invalid_symbol) → series float\nrequest.earnings(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float\nrequest.quandl(ticker, gaps, index, ignore_invalid_symbol) → series float\nrequest.financial(symbol, financial_id, period, gaps, ignore_invalid_symbol, currency) → series float\nrequest.economic(country_code, field, gaps, ignore_invalid_symbol) → series float\nrequest.seed(source, symbol, expression, ignore_invalid_symbol) → series <type>\nThe request.*() family of functions has numerous potential applications. Throughout this page, we will discuss in detail these functions and some of their typical use cases.\nUsers can also allow compatible scripts to evaluate their scopes in other contexts without requiring request.*() functions by using the timeframe parameter of the indicator() declaration statement.\nCommon characteristics¶\nMany functions in the request.*() namespace share some common properties and parameters. Before we explore each function in depth, let’s familiarize ourselves with these characteristics.\nUsage¶\nAll request.*() functions return “series” results, which means they can produce different values on every bar. However, most request.*() function parameters require “const”, “input”, or “simple” arguments.\nIn essence, Pine Script™ must determine the values of most arguments passed into a request.*() function upon compilation of the script or on the first chart bar, depending on the qualified type that each parameter accepts, and these values cannot change throughout the execution of the script. The only exception is the expression parameter in request.security(), request.security_lower_tf(), and request.seed(), which accepts “series” arguments.\nCalls to request.*() functions execute on every chart bar, and scripts cannot selectively deactivate them throughout their execution. Scripts cannot call request.*() functions within the local scopes of conditional structures, loops, or functions and methods exported by Libraries, but they can use such function calls within the bodies of non-exported user-defined functions and methods.\nWhen using any request.*() functions within a script, runtime performance is an important consideration. These functions can have a sizable impact on script performance. While scripts can contain a maximum of 40 calls to the request.*() namespace, users should strive to minimize the number of calls in their scripts to keep resource consumption as low as possible. For more information on the limitations of these functions, see this section of our User Manual’s page on Pine’s limitations.\n`gaps`¶\nWhen using a request.*() function to retrieve data from another context, the data may not come in on each new bar as it would with the current chart. The gaps parameter of a request.*() function allows users to control how the function responds to nonexistent values in the requested series.\nWhen using the indicator() function to evaluate a script in another context, the timeframe_gaps parameter specifies how it handles nonexistent values. The parameter is similar to the gaps parameter for request.*() functions.\nSuppose we have a script that requests hourly data for the chart’s symbol with request.security() executing on an 1-minute chart. In this case, the function call will only return new values on the 1-minute bars that cover the opening/closing times of the symbol’s hourly bars. On other chart bars, we can decide whether the function will return na values or the last available values via the gaps parameter.\nWhen the gaps parameter uses barmerge.gaps_on, the function will return na results on all chart bars where new data isn’t yet confirmed from the requested context. Otherwise, when the parameter uses barmerge.gaps_off, the function will fill the gaps in the requested data with the last confirmed values on historical bars and the most recent developing values on realtime bars.\nThe script below demonstrates the difference in behavior by plotting the results from two request.security() calls that fetch the close price of the current symbol from the hourly timeframe on a 1-minute chart. The first call uses gaps = barmerge.gaps_off and the second uses gaps = barmerge.gaps_on:\nindicator(\"gaps demo\", overlay = true)\n//@variable The `close` requested from the hourly timeframe without gaps.\nfloat dataWithoutGaps = request.security(syminfo.tickerid, \"60\", close, gaps = barmerge.gaps_off)\n//@variable The `close` requested from the hourly timeframe with gaps.\nfloat dataWithGaps = request.security(syminfo.tickerid, \"60\", close, gaps = barmerge.gaps_on)\n// Plot the requested data.\nplot(dataWithoutGaps, \"Data without gaps\", color.blue, 3, plot.style_linebr)\nplot(dataWithGaps, \"Data with gaps\", color.purple, 15, plot.style_linebr)\n// Highlight the background for realtime bars.\nbgcolor(barstate.isrealtime ? color.new(color.aqua, 70) : na, title = \"Realtime bar highlight\")\nbarmerge.gaps_off is the default value for the gaps parameter in all applicable request.*() functions.\nThe script plots the requested series as lines with breaks (plot.style_linebr), which don’t bridge over na values as the default style (plot.style_line) does.\nWhen using barmerge.gaps_off, the request.security() function returns the last confirmed close from the hourly timeframe on all historical bars. When running on realtime bars (the bars with the color.aqua background in this example), it returns the symbol’s current close value, regardless of confirmation. For more information, see the Historical and realtime behavior section of this page.\n`ignore_invalid_symbol`¶\nThe ignore_invalid_symbol parameter of request.*() functions determines how a function will handle invalid data requests, e.g.:\nUsing a request.*() function with a nonexistent ticker ID as the symbol/ticker parameter.\nUsing request.financial() to retrieve information that does not exist for the specified symbol or period.\nUsing request.economic() to request a field that doesn’t exist for a country_code.\nA request.*() function call will produce a runtime error and halt the execution of the script when making an erroneous request if its ignore_invalid_symbol parameter is false. When this parameter’s value is true, the function will return na values in such a case instead of raising an error.\nThis example uses request.*() calls within a user-defined function to retrieve data for estimating an instrument’s market capitalization (market cap). The user-defined calcMarketCap() function calls request.financial() to retrieve the total shares outstanding for a symbol and request.security() to retrieve a tuple containing the symbol’s close price and currency. We’ve included ignore_invalid_symbol = true in both of these request.*() calls to prevent runtime errors for invalid requests.\nThe script displays a formatted string representing the symbol’s estimated market cap value and currency in a table on the chart and uses a plot to visualize the marketCap history:\nindicator(\"ignore_invalid_symbol demo\", \"Market cap estimate\", format = format.volume)\n//@variable The symbol to request data from.\nstring symbol = input.symbol(\"TSX:SHOP\", \"Symbol\")\n//@function Estimates the market capitalization of the specified `tickerID` if the data exists.\ncalcMarketCap(simple string tickerID) =>\n//@variable The quarterly total shares outstanding for the `tickerID`. Returns `na` when the data isn't available.\nfloat tso = request.financial(tickerID, \"TOTAL_SHARES_OUTSTANDING\", \"FQ\", ignore_invalid_symbol = true)\n//@variable The `close` price and currency for the `tickerID`. Returns `[na, na]` when the `tickerID` is invalid.\n[price, currency] = request.security(\ntickerID, timeframe.period, [close, syminfo.currency], ignore_invalid_symbol = true\n)\n// Return a tuple containing the market cap estimate and the quote currency.\n[tso * price, currency]\n//@variable A `table` object with a single cell that displays the `marketCap` and `quoteCurrency`.\nvar table infoTable = table.new(position.top_right, 1, 1)\n// Initialize the table's cell on the first bar.\nif barstate.isfirst\ntable.cell(infoTable, 0, 0, \"\", text_color = color.white, text_size = size.huge, bgcolor = color.teal)\n// Get the market cap estimate and quote currency for the `symbol`.\n[marketCap, quoteCurrency] = calcMarketCap(symbol)\n//@variable The formatted text displayed inside the `infoTable`.\nstring tableText = str.format(\"Market cap:\\n{0} {1}\", str.tostring(marketCap, format.volume), quoteCurrency)\n// Update the `infoTable`.\ntable.cell_set_text(infoTable, 0, 0, tableText)\n// Plot the `marketCap` value.\nplot(marketCap, \"Market cap\", color.new(color.purple, 60), style = plot.style_area)\nThe calcMarketCap() function will only return values on valid instruments with total shares outstanding data, such as the one we’ve selected for this example. It will return a market cap value of na on others that don’t have financial data, including forex, crypto, and derivatives.\nNot all issuing companies publish quarterly financial reports. If the symbol’s issuing company doesn’t report on a quarterly basis, change the “FQ” value in this script to the company’s minimum reporting period. See the request.financial() section for more information.\nWe’ve used format.volume in the indicator() and str.tostring() calls, which specify that the y-axis of the chart pane represents volume-formatted values and the “string” representation of the marketCap value shows as volume-formatted text.\nThis script creates a table and initializes its cell on the first chart bar, then updates the cell’s text on subsequent bars. To learn more about working with tables, see the Tables page of our User Manual.\n`currency`¶\nThe currency parameter of a request.*() function allows users to specify the currency of the requested data. When this parameter’s value differs from the syminfo.currency of the requested context, the function will convert the requested values to express them in the specified currency. This parameter can accept a built-in variable from the currency.* namespace, such as currency.JPY, or a “string” representing the ISO 4217 currency code (e.g., “JPY”).\nThe conversion rate between the syminfo.currency of the requested data and the specified currency depends on the corresponding “FX_IDC” daily rate from the previous day. If no available instrument provides the conversion rate directly, the function will use the value from a spread symbol to derive the rate.\nNot all request.*() function calls return values expressed as a currency amount. Therefore, currency conversion is not always necessary. For example, some series returned by request.financial() are expressed in units other than currency, such as the “PIOTROSKI_F_SCORE” and “NUMBER_OF_EMPLOYEES” metrics. It is up to programmers to determine when currency conversion is appropriate in their data requests.\n`lookahead`¶\nThe lookahead parameter in request.security(), request.dividends(), request.splits(), and request.earnings() specifies the lookahead behavior of the function call. Its default value is barmerge.lookahead_off.\nWhen requesting data from a higher-timeframe (HTF) context, the lookahead value determines whether the function can request values from times beyond those of the historical bars it executes on. In other words, the lookahead value determines whether the requested data may contain lookahead bias on historical bars.\nWhen requesting data from a lower-timeframe (LTF) context, the lookahead parameter determines whether the function requests values from the first or last intrabar (LTF bar) on each chart bar.\nProgrammers should exercise extreme caution when using lookahead in their scripts, namely when requesting data from higher timeframes. When using barmerge.lookahead_on as the lookahead value, ensure that it does not compromise the integrity of the script’s logic by leaking future data into historical chart bars.\nThe following scenarios are cases where enabling lookahead is acceptable in a request.*() call:\nThe expression in request.security() references a series with a historical offset (e.g., close[1]), which prevents the function from requesting future values that it would not have access to on a realtime basis.\nThe specified timeframe in the call is the same as the chart the script executes on, i.e., timeframe.period.\nThe function call requests data from an intrabar timeframe, i.e., a timeframe smaller than the timeframe.period. See this section for more information.\nUsing request.security() to leak future data into the past is misleading and not allowed in script publications. While your script’s results on historical bars may look great due to its seemingly “magical” acquisition of prescience (which it will not be able to reproduce on realtime bars), you will be misleading yourself and the users of your script. If you publish your script to share it with others, ensure you do not mislead users by accessing future information on historical bars.\nThis example demonstrates how the lookahead parameter affects the behavior of higher-timeframe data requests and why enabling lookahead in request.security() without offsetting the expression is misleading. The script calls request.security() to get the HTF high price for the current chart’s symbol in three different ways and plots the resulting series on the chart for comparison.\nThe first call uses barmerge.lookahead_off (default), and the others use barmerge.lookahead_on. However, the third request.security() call also offsets its expression using the history-referencing operator [] to avoid leaking future data into the past.\nAs we see on the chart, the plot of the series requested using barmerge.lookahead_on without an offset (fuchsia line) shows final HTF high prices before they’re actually available on historical bars, whereas the other two calls do not:\nindicator(\"lookahead demo\", overlay = true)\n//@variable The timeframe to request the data from.\nstring timeframe = input.timeframe(\"30\", \"Timeframe\")\n//@variable The requested `high` price from the current symbol on the `timeframe` without lookahead bias.\n// On realtime bars, it returns the current `high` of the `timeframe`.\nfloat lookaheadOff = request.security(syminfo.tickerid, timeframe, high, lookahead = barmerge.lookahead_off)\n//@variable The requested `high` price from the current symbol on the `timeframe` with lookahead bias.\n// Returns values that should NOT be accessible yet on historical bars.\nfloat lookaheadOn = request.security(syminfo.tickerid, timeframe, high, lookahead = barmerge.lookahead_on)\n//@variable The requested `high` price from the current symbol on the `timeframe` without lookahead bias or repainting.\n// Behaves the same on historical and realtime bars.\nfloat lookaheadOnOffset = request.security(syminfo.tickerid, timeframe, high[1], lookahead = barmerge.lookahead_on)\n// Plot the values.\nplot(lookaheadOff, \"High, no lookahead bias\", color.new(color.blue, 40), 5)\nplot(lookaheadOn, \"High with lookahead bias\", color.fuchsia, 3)\nplot(lookaheadOnOffset, \"High, no lookahead bias or repaint\", color.aqua, 3)\n// Highlight the background on realtime bars.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 60) : na, title = \"Realtime bar highlight\")\nThe series requested using barmerge.lookahead_off has a new historical value at the end of each HTF period, and both series requested using barmerge.lookahead_on have new historical data at the start of each period.\nOn realtime bars, the plot of the series without lookahead (blue) and the series with lookahead and no historical offset (fuchsia) show the same value (i.e., the HTF period’s unconfirmed high price), as no data exists beyond those points to leak into the past. Both of these plots will repaint their results after restarting the script’s execution, as realtime bars will become historical bars.\nThe series that uses lookahead and a historical offset (aqua) does not repaint its values, as it always references the last confirmed value from the higher timeframe. See the Avoiding repainting section of this page for more information.\nIn Pine Script™ v1 and v2, the security() function did not include a lookahead parameter, but it behaved as it does in later versions of Pine with lookahead = barmerge.lookahead_on, meaning that it systematically used data from the future HTF context on historical bars. Therefore, users should exercise caution with Pine v1 or v2 scripts that use HTF security() calls unless the function calls contain historical offsets.\nData feeds¶\nTradingView’s data providers supply different data feeds that scripts can access to retrieve information about an instrument, including:\nIntraday historical data (for timeframes < 1D)\nEnd-of-day (EOD) historical data (for timeframes >= 1D)\nRealtime data (which may be delayed, depending on your account type and extra data services)\nExtended hours data\nNot all of these data feed types exist for every instrument. For example, the symbol “BNC:BLX” only has EOD data available.\nFor some instruments with intraday and EOD historical feeds, volume data may not be the same since some trades (block trades, OTC trades, etc.) may only be available at the end of the trading day. Consequently, the EOD feed will include this volume data, but the intraday feed will not. Differences between EOD and intraday volume feeds are almost nonexistent for instruments such as cryptocurrencies, but they are commonplace in stocks.\nSlight price discrepancies may also occur between EOD and intraday feeds. For example, the high value on one EOD bar may not match any intraday high values supplied by the data provider for that day.\nAnother distinction between EOD and intraday data feeds is that EOD feeds do not contain information from extended hours.\nWhen retrieving information on realtime bars with request.*() functions, it’s important to note that historical and realtime data reported for an instrument often rely on different data feeds. A broker/exchange may retroactively modify values reported on realtime bars, which the data will only reflect after refreshing the chart or restarting the execution of the script.\nAnother important consideration is that the chart’s data feeds and feeds requested from providers by the script are managed by independent, concurrent processes. Consequently, in some rare cases, it’s possible for races to occur where requested results temporarily fall out of synch with the chart on a realtime bar, which a script retroactively adjusts after restarting its execution.\nThese points may account for variations in the values retrieved by request.*() functions when requesting data from other contexts. They may also result in discrepancies between data received on realtime bars and historical bars. There are no steadfast rules about the variations one may encounter in their requested data feeds.\nAs a rule, TradingView does not generate data; it relies on its data providers for the information displayed on charts and accessed by scripts.\nWhen using data feeds requested from other contexts, it’s also crucial to consider the time axis differences between the chart the script executes on and the requested feeds since request.*() functions adapt the returned series to the chart’s time axis. For example, requesting “BTCUSD” data on the “SPY” chart with request.security() will only show new values when the “SPY” chart has new data as well. Since “SPY” is not a 24-hour symbol, the “BTCUSD” data returned will contain gaps that are otherwise not present when viewing its chart directly.\n`request.security()`¶\nThe request.security() function allows scripts to request data from other contexts than the chart the script executes on, such as:\nOther symbols, including spread symbols\nOther timeframes (see our User Manual’s page on Timeframes to learn about timeframe specifications in Pine Script™)\nCustom contexts, including alternative sessions, price adjustments, chart types, etc. using ticker.*() functions\nThis is the function’s signature:\nrequest.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency) → series <type>\nThe symbol value is the ticker identifier representing the symbol to fetch data from. This parameter accepts values in any of the following formats:\nA “string” representing a symbol (e.g., “IBM” or “EURUSD”) or an “Exchange:Symbol” pair (e.g., “NYSE:IBM” or “OANDA:EURUSD”). When the value does not contain an exchange prefix, the function selects the exchange automatically. We recommend specifying the exchange prefix when possible for consistent results. Users can also pass an empty string to this parameter, which prompts the function to use the current chart’s symbol.\nA “string” representing a spread symbol (e.g., “AMD/INTC”). Note that “Bar Replay” mode does not work with these symbols.\nThe syminfo.ticker or syminfo.tickerid built-in variables, which return the symbol or the “Exchange:Symbol” pair that the current chart references. We recommend using syminfo.tickerid to avoid ambiguity unless the exchange information does not matter in the data request. For more information on syminfo.* variables, see this section of our Chart information page.\nA custom ticker identifier created using ticker.*() functions. Ticker IDs constructed from these functions may contain additional settings for requesting data using non-standard chart calculations, alternative sessions, and other contexts. See the Custom contexts section for more information.\nThe timeframe value specifies the timeframe of the requested data. This parameter accepts “string” values in our timeframe specification format (e.g., a value of “1D” represents the daily timeframe). To request data from the same timeframe as the chart the script executes on, use the timeframe.period variable or an empty string.\nThe expression parameter of the request.security() function determines the data it retrieves from the specified context. This versatile parameter accepts “series” values of int, float, bool, color, string, and chart.point types. It can also accept tuples, collections, user-defined types, and the outputs of function and method calls. For more details on the data one can retrieve, see the Requestable data section below.\nWhen using the value from an input.source() call in the expression argument and the input references a series from another indicator, request.*() functions calculate that value’s results using the chart’s symbol, regardless of the symbol argument supplied, since they cannot evaluate the scopes required by an external series. We therefore do not recommend attempting to request external source input data from other contexts.\nTimeframes¶\nThe request.security() function can request data from any available timeframe, regardless of the chart the script executes on. The timeframe of the data retrieved depends on the timeframe argument in the function call, which may represent a higher timeframe (e.g., using “1D” as the timeframe value while running the script on an intraday chart) or the chart’s timeframe (i.e., using timeframe.period or an empty string as the timeframe argument).\nScripts can also request limited data from lower timeframes with request.security() (e.g., using “1” as the timeframe argument while running the script on a 60-minute chart). However, we don’t typically recommend using this function for LTF data requests. The request.security_lower_tf() function is more optimal for such cases.\nHigher timeframes¶\nMost use cases of request.security() involve requesting data from a timeframe higher than or the same as the chart timeframe. For example, this script retrieves the hl2 price from a requested higherTimeframe. It plots the resulting series on the chart alongside the current chart’s hl2 for comparison:\nindicator(\"Higher timeframe security demo\", overlay = true)\n//@variable The higher timeframe to request data from.\nstring higherTimeframe = input.timeframe(\"240\", \"Higher timeframe\")\n//@variable The `hl2` value from the `higherTimeframe`. Combines lookahead with an offset to avoid repainting.\nfloat htfPrice = request.security(syminfo.tickerid, higherTimeframe, hl2[1], lookahead = barmerge.lookahead_on)\n// Plot the `hl2` from the chart timeframe and the `higherTimeframe`.\nplot(hl2, \"Current timeframe HL2\", color.teal, 2)\nplot(htfPrice, \"Higher timeframe HL2\", color.purple, 3)\nWe’ve included an offset to the expression argument and used barmerge.lookahead_on in request.security() to ensure the series returned behaves the same on historical and realtime bars. See the Avoiding repainting section for more information.\nNotice that in the above example, it is possible to select a higherTimeframe value that actually represents a lower timeframe than the one the chart uses, as the code does not prevent it. When designing a script to work specifically with higher timeframes, we recommend including conditions to prevent it from accessing lower timeframes, especially if you intend to publish it.\nBelow, we’ve added an if structure to our previous example that raises a runtime error when the higherTimeframe input represents a timeframe smaller than the chart timeframe, effectively preventing the script from requesting LTF data:\nindicator(\"Higher timeframe security demo\", overlay = true)\n//@variable The higher timeframe to request data from.\nstring higherTimeframe = input.timeframe(\"240\", \"Higher timeframe\")\n// Raise a runtime error when the `higherTimeframe` is smaller than the chart's timeframe.\nif timeframe.in_seconds() > timeframe.in_seconds(higherTimeframe)\nruntime.error(\"The requested timeframe is smaller than the chart's timeframe. Select a higher timeframe.\")\n//@variable The `hl2` value from the `higherTimeframe`. Combines lookahead with an offset to avoid repainting.\nfloat htfPrice = request.security(syminfo.tickerid, higherTimeframe, hl2[1], lookahead = barmerge.lookahead_on)\n// Plot the `hl2` from the chart timeframe and the `higherTimeframe`.\nplot(hl2, \"Current timeframe HL2\", color.teal, 2)\nplot(htfPrice, \"Higher timeframe HL2\", color.purple, 3)\nLower timeframes¶\nAlthough the request.security() function is intended to operate on timeframes greater than or equal to the chart timeframe, it can request data from lower timeframes as well, with limitations. When calling this function to access a lower timeframe, it will evaluate the expression from the LTF context. However, it can only return the results from a single intrabar (LTF bar) on each chart bar.\nThe intrabar that the function returns data from on each historical chart bar depends on the lookahead value in the function call. When using barmerge.lookahead_on, it will return the first available intrabar from the chart period. When using barmerge.lookahead_off, it will return the last intrabar from the chart period. On realtime bars, it returns the last available value of the expression from the timeframe, regardless of the lookahead value, as the realtime intrabar information retrieved by the function is not yet sorted.\nThis script retrieves close data from the valid timeframe closest to a fourth of the size of the chart timeframe. It makes two calls to request.security() with different lookahead values. The first call uses barmerge.lookahead_on to access the first intrabar value in each chart bar. The second uses the default lookahead value (barmerge.lookahead_off), which requests the last intrabar value assigned to each chart bar. The script plots the outputs of both calls on the chart to compare the difference:\nindicator(\"Lower timeframe security demo\", overlay = true)\n//@variable The valid timeframe closest to 1/4 the size of the chart timeframe.\nstring lowerTimeframe = timeframe.from_seconds(int(timeframe.in_seconds() / 4))\n//@variable The `close` value on the `lowerTimeframe`. Represents the first intrabar value on each chart bar.\nfloat firstLTFClose = request.security(syminfo.tickerid, lowerTimeframe, close, lookahead = barmerge.lookahead_on)\n//@variable The `close` value on the `lowerTimeframe`. Represents the last intrabar value on each chart bar.\nfloat lastLTFClose = request.security(syminfo.tickerid, lowerTimeframe, close)\n// Plot the values.\nplot(firstLTFClose, \"First intrabar close\", color.teal, 3)\nplot(lastLTFClose, \"Last intrabar close\", color.purple, 3)\n// Highlight the background on realtime bars.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime background highlight\")\nThe script determines the value of the lowerTimeframe by calculating the number of seconds in the chart timeframe with timeframe.in_seconds(), then dividing by four and converting the result to a valid timeframe string via timeframe.from_seconds().\nThe plot of the series without lookahead (purple) aligns with the close value on the chart timeframe, as this is the last intrabar value in the chart bar.\nBoth request.security() calls return the same value (the current close) on each realtime bar, as shown on the bars with the orange background.\nScripts can retrieve up to 100,000 intrabars from a lower-timeframe context. See this section of the Limitations page.\nWhile scripts can use request.security() to retrieve the values from a single intrabar on each chart bar, which might provide utility in some unique cases, we recommend using the request.security_lower_tf() function for intrabar analysis when possible, as it returns an array containing data from all available intrabars within a chart bar. See this section to learn more.\nRequestable data¶\nThe request.security() function is quite versatile, as it can retrieve values of any fundamental type (int, float, bool, color, or string). It can also request the IDs of data structures and built-in or user-defined types that reference fundamental types. The data this function requests depends on its expression parameter, which accepts any of the following arguments:\nBuilt-in variables and function calls\nVariables calculated by the script\nTuples\nCalls to user-defined functions\nChart points\nCollections\nUser-defined types\nThe request.security() function duplicates the scopes and operations required by the expression to calculate its requested values in another context, which elevates runtime memory consumption. Additionally, the extra scopes produced by each call to request.security() count toward the script’s compilation limits. See the Scope count section of the Limitations page for more information.\nBuilt-in variables and functions¶\nA frequent use case of request.security() is requesting the output of a built-in variable or function/method call from another symbol or timeframe.\nFor example, suppose we want to calculate the 20-bar SMA of a symbol’s ohlc4 price from the daily timeframe while on an intraday chart. We can accomplish this with a single line of code:\nfloat ma = request.security(syminfo.tickerid, \"1D\", ta.sma(ohlc4, 20))\nThe above line calculates the value of ta.sma(ohlc4, 20) on the current symbol from the daily timeframe.\nIt’s important to note that newcomers to Pine may sometimes confuse the above line of code as being equivalent to the following:\nfloat ma = ta.sma(request.security(syminfo.tickerid, \"1D\", ohlc4), 20)\nHowever, this line will return an entirely different result. Rather than requesting a 20-bar SMA from the daily timeframe, it requests the ohlc4 price from the daily timeframe and calclates the ta.sma() of the results over 20 chart bars.\nIn essence, when the intention is to request the results of an expression from other contexts, pass the expression directly to the expression parameter in the request.security() call, as demonstrated in the initial example.\nLet’s expand on this concept. The script below calculates a multi-timeframe (MTF) ribbon of moving averages, where each moving average in the ribbon calculates over the same number of bars on its respective timeframe. Each request.security() call uses ta.sma(close, length) as its expression argument to return a length-bar SMA from the specified timeframe:\nindicator(\"Requesting built-ins demo\", \"MTF Ribbon\", true)\n//@variable The length of each moving average.\nint length = input.int(20, \"Length\", 1)\n//@variable The number of seconds in the chart timeframe.\nint chartSeconds = timeframe.in_seconds()\n// Calculate the higher timeframes closest to 2, 3, and 4 times the size of the chart timeframe.\nstring htf1 = timeframe.from_seconds(chartSeconds * 2)\nstring htf2 = timeframe.from_seconds(chartSeconds * 3)\nstring htf3 = timeframe.from_seconds(chartSeconds * 4)\n// Calculate the `length`-bar moving averages from each timeframe.\nfloat chartAvg = ta.sma(ohlc4, length)\nfloat htfAvg1 = request.security(syminfo.tickerid, htf1, ta.sma(ohlc4, length))\nfloat htfAvg2 = request.security(syminfo.tickerid, htf2, ta.sma(ohlc4, length))\nfloat htfAvg3 = request.security(syminfo.tickerid, htf3, ta.sma(ohlc4, length))\n// Plot the results.\nplot(chartAvg, \"Chart timeframe SMA\", color.red, 3)\nplot(htfAvg1, \"Double timeframe SMA\", color.orange, 3)\nplot(htfAvg2, \"Triple timeframe SMA\", color.green, 3)\nplot(htfAvg3, \"Quadruple timeframe SMA\", color.blue, 3)\n// Highlight the background on realtime bars.\nbgcolor(barstate.isrealtime ? color.new(color.aqua, 70) : na, title = \"Realtime highlight\")\nThe script calculates the ribbon’s higher timeframes by multiplying the chart’s timeframe.in_seconds() value by 2, 3, and 4, then converting each result into a valid timeframe string using timeframe.from_seconds().\nInstead of calling ta.sma() within each request.security() call, one could use the chartAvg variable as the expression in each call to achieve the same result. See the next section for more information.\nOn realtime bars, this script also tracks unconfirmed SMA values from each higher timeframe. See the Historical and realtime behavior section to learn more.\nCalculated variables¶\nThe expression parameter of request.security() accepts variables declared in the global scope, allowing scripts to evaluate their variables’ calculations from other contexts without redundantly listing the operations in each function call.\nFor example, one can declare the following variable:\npriceReturn = (close - close[1]) / close[1]\nand execute the variable’s calculation from another context with request.security():\nrequestedReturn = request.security(symbol, timeframe.period, priceReturn)\nThe function call in the line above will return the result of the priceReturn calculation on another symbol’s data as a series adapted to the current chart, which the script can display directly on the chart or utilize in additional operations.\nThe following example compares the price returns of the current chart’s symbol and another specified symbol. The script declares the priceReturn variable from the chart’s context, then uses that variable in request.security() to evaluate its calculation on another symbol. It then calculates the correlation between the priceReturn and requestedReturn and plots the result on the chart:\nindicator(\"Requesting calculated variables demo\", \"Price return correlation\")\n//@variable The symbol to compare to the chart symbol.\nstring symbol = input.symbol(\"SPY\", \"Symbol to compare\")\n//@variable The number of bars in the calculation window.\nint length = input.int(60, \"Length\", 1)\n//@variable The close-to-close price return.\nfloat priceReturn = (close - close[1]) / close[1]\n//@variable The close-to-close price return calculated on another `symbol`.\nfloat requestedReturn = request.security(symbol, timeframe.period, priceReturn)\n//@variable The correlation between the `priceReturn` and `requestedReturn` over `length` bars.\nfloat correlation = ta.correlation(priceReturn, requestedReturn, length)\n//@variable The color of the correlation plot.\ncolor plotColor = color.from_gradient(correlation, -1, 1, color.purple, color.orange)\n// Plot the correlation value.\nplot(correlation, \"Correlation\", plotColor, style = plot.style_area)\nThe request.security() call executes the same calculation used in the priceReturn declaration, except it uses the close values fetched from the input symbol.\nThe script colors the plot with a gradient based on the correlation value. To learn more about color gradients in Pine, see this section of our User Manual’s page on colors.\nTuples¶\nTuples in Pine Script™ are comma-separated sets of expressions enclosed in brackets that can hold multiple values of any available type. We use tuples when creating functions or other local blocks that return more than one value.\nThe request.security() function can accept a tuple as its expression argument, allowing scripts to request multiple series of different types using a single function call. The expressions within requested tuples can be of any type outlined throughout the Requestable data section of this page, excluding other tuples.\nThe combined size of all tuples returned by request.*() calls in a script cannot exceed 127 elements. See this section of the Limitations page for more information.\nTuples are particularly handy when a script needs to retrieve more than one value from a specific context.\nFor example, this script calculates the percent rank of the close price over length bars and assigns the expression to the rank variable. It then calls request.security() to request a tuple containing the rank, ta.crossover(rank, 50), and ta.crossunder(rank, 50) values from the specified timeframe. The script plots the requestedRank and uses the crossOver and crossUnder “bool” values within bgcolor() to conditionally highlight the chart pane’s background:\nindicator(\"Requesting tuples demo\", \"Percent rank cross\")\n//@variable The timeframe of the request.\nstring timeframe = input.timeframe(\"240\", \"Timeframe\")\n//@variable The number of bars in the calculation.\nint length = input.int(20, \"Length\")\n//@variable The previous bar's percent rank of the `close` price over `length` bars.\nfloat rank = ta.percentrank(close, length)[1]\n// Request the `rank` value from another `timeframe`, and two \"bool\" values indicating the `rank` from the `timeframe`\n// crossed over or under 50.\n[requestedRank, crossOver, crossUnder] = request.security(\nsyminfo.tickerid, timeframe, [rank, ta.crossover(rank, 50), ta.crossunder(rank, 50)],\nlookahead = barmerge.lookahead_on\n// Plot the `requestedRank` and create a horizontal line at 50.\nplot(requestedRank, \"Percent Rank\", linewidth = 3)\nhline(50, \"Cross line\", linewidth = 2)\n// Highlight the background of all bars where the `timeframe`'s `crossOver` or `crossUnder` value is `true`.\nbgcolor(crossOver ? color.new(color.green, 50) : crossUnder ? color.new(color.red, 50) : na)\nWe’ve offset the rank variable’s expression by one bar using the history-referencing operator [] and included barmerge.lookahead_on in the request.security() call to ensure the values on realtime bars do not repaint after becoming historical bars. See the Avoiding repainting section for more information.\nThe request.security() call returns a tuple, so we use a tuple declaration to declare the requestedRank, crossOver, and crossUnder variables. To learn more about using tuples, see this section of our User Manual’s Type system page.\nUser-defined functions¶\nUser-defined functions and methods are custom functions written by users. They allow users to define sequences of operations associated with an identifier that scripts can conveniently call throughout their execution (e.g., myUDF()).\nThe request.security() function can request the results of user-defined functions and methods whose scopes consist of any types outlined throughout this page’s Requestable data section.\nFor example, this script contains a user-defined weightedBB() function that calculates Bollinger Bands with the basis average weighted by a specified weight series. The function returns a tuple of custom band values. The script calls the weightedBB() as the expression argument in request.security() to retrieve a tuple of band values calculated on the specified timeframe and plots the results on the chart:\nindicator(\"Requesting user-defined functions demo\", \"Weighted Bollinger Bands\", true)\n//@variable The timeframe of the request.\nstring timeframe = input.timeframe(\"480\", \"Timeframe\")\n//@function Calculates Bollinger Bands with a custom weighted basis.\n//@param source The series of values to process.\n//@param length The number of bars in the calculation.\n//@param mult The standard deviation multiplier.\n//@param weight The series of weights corresponding to each `source` value.\n//@returns A tuple containing the basis, upper band, and lower band respectively.\nweightedBB(float source, int length, float mult = 2.0, float weight = 1.0) =>\n//@variable The basis of the bands.\nfloat ma = math.sum(source * weight, length) / math.sum(weight, length)\n//@variable The standard deviation from the `ma`.\nfloat dev = 0.0\n// Loop to accumulate squared error.\nfor i = 0 to length - 1\ndifference = source[i] - ma\ndev += difference * difference\n// Divide `dev` by the `length`, take the square root, and multiply by the `mult`.\ndev := math.sqrt(dev / length) * mult\n// Return the bands.\n[ma, ma + dev, ma - dev]\n// Request weighted bands calculated on the chart symbol's prices over 20 bars from the\n// last confirmed bar on the `timeframe`.\n[basis, highBand, lowBand] = request.security(\nsyminfo.tickerid, timeframe, weightedBB(close[1], 20, 2.0, (high - low)[1]), lookahead = barmerge.lookahead_on\n// Plot the values.\nbasisPlot = plot(basis, \"Basis\", color.orange, 2)\nupperPlot = plot(highBand, \"Upper\", color.teal, 2)\nlowerPlot = plot(lowBand, \"Lower\", color.maroon, 2)\nfill(upperPlot, lowerPlot, color.new(color.gray, 90), \"Background\")\nWe offset the source and weight arguments in the weightedBB() call used as the expression in request.security() and used barmerge.lookahead_on to ensure the requested results reflect the last confirmed values from the timeframe on realtime bars. See this section to learn more.\nChart points¶\nChart points are reference types that represent coordinates on the chart. Lines, boxes, polylines, and labels use chart.point objects to set their display locations.\nThe request.security() function can use the ID of a chart.point instance in its expression argument, allowing scripts to retrieve chart coordinates from other contexts.\nThe example below requests a tuple of historical chart points from a higher timeframe and uses them to draw boxes on the chart. The script declares the topLeft and bottomRight variables that reference chart.point IDs from the last confirmed bar. It then uses request.security() to request a tuple containing the IDs of chart points representing the topLeft and bottomRight from a higherTimeframe.\nWhen a new bar starts on the higherTimeframe, the script draws a new box using the time and price coordinates from the requestedTopLeft and requestedBottomRight chart points:\nindicator(\"Requesting chart points demo\", \"HTF Boxes\", true, max_boxes_count = 500)\n//@variable The timeframe to request data from.\nstring higherTimeframe = input.timeframe(\"1D\", \"Timeframe\")\n// Raise a runtime error if the `higherTimeframe` is smaller than the chart's timeframe.\nif timeframe.in_seconds(higherTimeframe) < timeframe.in_seconds(timeframe.period)\nruntime.error(\"The selected timeframe is too small. Choose a higher timeframe.\")\n//@variable A `chart.point` containing top-left coordinates from the last confirmed bar.\ntopLeft = chart.point.now(high)[1]\n//@variable A `chart.point` containing bottom-right coordinates from the last confirmed bar.\nbottomRight = chart.point.from_time(time_close, low)[1]\n// Request the last confirmed `topLeft` and `bottomRight` chart points from the `higherTimeframe`.\n[requestedTopLeft, requestedBottomRight] = request.security(\nsyminfo.tickerid, higherTimeframe, [topLeft, bottomRight], lookahead = barmerge.lookahead_on\n// Draw a new box when a new `higherTimeframe` bar starts.\n// The box uses the `time` fields from the `requestedTopLeft` and `requestedBottomRight` as x-coordinates.\nif timeframe.change(higherTimeframe)\nbox.new(\nrequestedTopLeft, requestedBottomRight, color.purple, 3,\nxloc = xloc.bar_time, bgcolor = color.new(color.purple, 90)\nSince this example is designed specifically for higher timeframes, we’ve included a custom runtime error that the script raises when the timeframe.in_seconds() of the higherTimeframe is smaller than that of the chart’s timeframe.\nCollections¶\nPine Script™ collections (arrays, matrices, and maps) are data structures that contain an arbitrary number of elements with specified types. The request.security() function can retrieve the IDs of collections whose elements consist of:\nFundamental types\nChart points\nUser-defined types that satisfy the criteria listed in the section below\nThis example calculates the ratio of a confirmed bar’s high-low range to the range between the highest and lowest values over 10 bars from a specified symbol and timeframe. It uses maps to hold the values used in the calculations.\nThe script creates a data map with “string” keys and “float” values to hold high, low, highest, and lowest price values on each bar, which it uses as the expression in request.security() to calculate an otherData map representing the data from the specified context. It uses the values associated with the “High”, “Low”, “Highest”, and “Lowest” keys of the otherData map to calculate the ratio that it plots in the chart pane:\nindicator(\"Requesting collections demo\", \"Bar range ratio\")\n//@variable The ticker ID to request data from.\nstring symbol = input.symbol(\"\", \"Symbol\")\n//@variable The timeframe of the request.\nstring timeframe = input.timeframe(\"30\", \"Timeframe\")\n//@variable A map with \"string\" keys and \"float\" values.\nvar map<string, float> data = map.new<string, float>()\n// Put key-value pairs into the `data` map.\nmap.put(data, \"High\", high)\nmap.put(data, \"Low\", low)\nmap.put(data, \"Highest\", ta.highest(10))\nmap.put(data, \"Lowest\", ta.lowest(10))\n//@variable A new `map` whose data is calculated from the last confirmed bar of the requested context.\nmap<string, float> otherData = request.security(symbol, timeframe, data[1], lookahead = barmerge.lookahead_on)\n//@variable The ratio of the context's bar range to the max range over 10 bars. Returns `na` if no data is available.\nfloat ratio = na\nif not na(otherData)\nratio := (otherData.get(\"High\") - otherData.get(\"Low\")) / (otherData.get(\"Highest\") - otherData.get(\"Lowest\"))\n//@variable A gradient color for the plot of the `ratio`.\ncolor ratioColor = color.from_gradient(ratio, 0, 1, color.purple, color.orange)\n// Plot the `ratio`.\nplot(ratio, \"Range Ratio\", ratioColor, 3, plot.style_area)\nThe request.security() call in this script can return na if no data is available from the specified context. Since one cannot call methods on a map variable when its value is na, we’ve added an if structure to only calculate a new ratio value when otherData references a valid map ID.\nUser-defined types¶\nUser-defined types (UDTs) are composite types containing an arbitrary number of fields, which can be of any available type, including other user-defined types.\nThe request.security() function can retrieve the IDs of objects produced by UDTs from other contexts if their fields consist of:\nFundamental types\nChart points\nCollections that satisfy the criteria listed in the section above\nOther UDTs whose fields consist of any of these types\nThe following example requests an object ID using a specified symbol and displays its field values on a chart pane.\nThe script contains a TickerInfo UDT with “string” fields for syminfo.* values, an array field to store recent “float” price data, and an “int” field to hold the requested ticker’s bar_index value. It assigns a new TickerInfo ID to an info variable on every bar and uses the variable as the expression in request.security() to retrieve the ID of an object representing the calculated info from the specified symbol.\nThe script displays the requestedInfo object’s description, tickerType, currency, and barIndex values in a label and uses plotcandle() to display the values from its prices array:\nindicator(\"Requesting user-defined types demo\", \"Ticker info\")\n//@variable The symbol to request information from.\nstring symbol = input.symbol(\"NASDAQ:AAPL\", \"Symbol\")\n//@type A custom type containing information about a ticker.\n//@field description The symbol's description.\n//@field tickerType The type of ticker.\n//@field currency The symbol's currency.\n//@field prices An array of the symbol's current prices.\n//@field barIndex The ticker's `bar_index`.\ntype TickerInfo\nstring description\nstring tickerType\nstring currency\narray<float> prices\nint barIndex\n//@variable A `TickerInfo` object containing current data.\ninfo = TickerInfo.new(\nsyminfo.description, syminfo.type, syminfo.currency, array.from(open, high, low, close), bar_index\n//@variable The `info` requested from the specified `symbol`.\nTickerInfo requestedInfo = request.security(symbol, timeframe.period, info)\n// Assign a new `TickerInfo` instance to `requestedInfo` if one wasn't retrieved.\nif na(requestedInfo)\nrequestedInfo := TickerInfo.new(prices = array.new<float>(4))\n//@variable A label displaying information from the `requestedInfo` object.\nvar infoLabel = label.new(\nna, na, \"\", color = color.purple, style = label.style_label_left, textcolor = color.white, size = size.large\n//@variable The text to display inside the `infoLabel`.\nstring infoText = na(requestedInfo) ? \"\" : str.format(\n\"{0}\\nType: {1}\\nCurrency: {2}\\nBar Index: {3}\",\nrequestedInfo.description, requestedInfo.tickerType, requestedInfo.currency, requestedInfo.barIndex\n// Set the `point` and `text` of the `infoLabel`.\nlabel.set_point(infoLabel, chart.point.now(array.last(requestedInfo.prices)))\nlabel.set_text(infoLabel, infoText)\n// Plot candles using the values from the `prices` array of the `requestedInfo`.\nplotcandle(\nrequestedInfo.prices.get(0), requestedInfo.prices.get(1), requestedInfo.prices.get(2), requestedInfo.prices.get(3),\n\"Requested Prices\"\nThe syminfo.* variables used in this script all return “simple string” qualified types. However, objects in Pine are always qualified as “series”. Consequently, all values assigned to the info object’s fields automatically adopt the “series” qualifier.\nIt is possible for the request.security() call to return na due to differences between the data requested from the symbol and the main chart. This script assigns a new TickerInfo object to the requestedInfo in that case to prevent runtime errors.\n`request.security_lower_tf()`¶\nThe request.security_lower_tf() function is an alternative to request.security() designed for reliably requesting information from lower-timeframe (LTF) contexts.\nWhile request.security() can retrieve data from a single intrabar (LTF bar) in each chart bar, request.security_lower_tf() retrieves data from all available intrabars in each chart bar, which the script can access and use in additional calculations. Each request.security_lower_tf() call can retrieve up to 100,000 intrabars from a lower timeframe. See this section of our Limitations page for more information.\nWorking with request.security_lower_tf() involves frequent usage of arrays since it always returns array results. We therefore recommend you familiarize yourself with arrays to make the most of this function in your scripts.\nBelow is the function’s signature, which is similar to request.security():\nrequest.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency, ignore_invalid_timeframe) → array<type>\nThis function only requests data from timeframes less than or equal to the chart’s timeframe. If the timeframe of the request represents a higher timeframe than the chart’s timeframe, the function will either raise a runtime error or return na values depending on the ignore_invalid_timeframe argument in the call. The default value for this parameter is false, meaning it will raise an error and halt the script’s execution when attempting to request HTF data.\nRequesting intrabar data¶\nIntrabar data can provide a script with additional information that may not be obvious or accessible from solely analyzing data sampled on the chart’s timerframe. The request.security_lower_tf() function can retrieve many data types from an intrabar context.\nBefore you venture further in this section, we recommend exploring the Requestable data portion of the request.security() section above, which provides foundational information about the types of data one can request. The expression parameter in request.security_lower_tf() accepts most of the same arguments discussed in that section, excluding direct references to collections and mutable variables declared in the script’s main scope. Although it accepts many of the same types of arguments, this function returns array results, which comes with some differences in interpretation and handling, as explained below.\nIntrabar data arrays¶\nLower timeframes contain more data points than higher timeframes, as new values come in at a higher frequency. For example, when comparing a 1-minute chart to an hourly chart, the 1-minute chart will have up to 60 times the number of bars per hour, depending on the available data.\nTo address the fact that multiple intrabars exist within a chart bar, request.security_lower_tf() always returns its results as arrays. The elements in the returned arrays represent the expression values retrieved from the lower timeframe sorted in ascending order based on each intrabar’s timestamp.\nThe type template assigned to the returned arrays corresponds to the value types passed in the request.security_lower_tf() call. For example, using an “int” as the expression will produce an array<int> instance, a “bool” as the expression will produce an array<bool> instance, etc.\nThe following script uses intrabar information to decompose the chart’s close-to-close price changes into positive and negative parts. It calls request.security_lower_tf() to fetch a “float” array of ta.change(close) values from the lowerTimeframe on each chart bar, then accesses all the array’s elements using a for…in loop to accumulate positiveChange and negativeChange sums. The script adds the accumulated values to calculate the netChange, then plots the results on the chart alongside the priceChange for comparison:\nindicator(\"Intrabar arrays demo\", \"Intrabar price changes\")\n//@variable The lower timeframe of the requested data.\nstring lowerTimeframe = input.timeframe(\"1\", \"Timeframe\")\n//@variable The close-to-close price change.\nfloat priceChange = ta.change(close)\n//@variable An array of `close` values from available intrabars on the `lowerTimeframe`.\narray<float> intrabarChanges = request.security_lower_tf(syminfo.tickerid, lowerTimeframe, priceChange)\n//@variable The total positive intrabar `close` movement on the chart bar.\nfloat positiveChange = 0.0\n//@variable The total negative intrabar `close` movement on the chart bar.\nfloat negativeChange = 0.0\n// Loop to calculate totals, starting from the chart bar's first available intrabar.\nfor change in intrabarChanges\n// Add the `change` to `positiveChange` if its sign is 1, and add to `negativeChange` if its sign is -1.\nswitch math.sign(change)\n1 => positiveChange += change\n-1 => negativeChange += change\n//@variable The sum of `positiveChange` and `negativeChange`. Equals the `priceChange` on bars with available intrabars.\nfloat netChange = positiveChange + negativeChange\n// Plot the `positiveChange`, `negativeChange`, and `netChange`.\nplot(positiveChange, \"Positive intrabar change\", color.teal, style = plot.style_area)\nplot(negativeChange, \"Negative intrabar change\", color.maroon, style = plot.style_area)\nplot(netChange, \"Net intrabar change\", color.yellow, 5)\n// Plot the `priceChange` to compare.\nplot(priceChange, \"Chart price change\", color.orange, 2)\nThe plots based on intrabar data may not appear on all available chart bars, as request.security_lower_tf() can only access up to the most recent 100,000 intrabars available from the requested context. When executing this function on a chart bar that doesn’t have accessible intrabar data, it will return an empty array.\nThe number of intrabars per chart bar may vary depending on the data available from the context and the chart the script executes on. For example, a provider’s 1-minute data feed may not include data for every minute within the 60-minute timeframe due to a lack of trading activity over some 1-minute intervals. To check the number of intrabars retrieved for a chart bar, one can use array.size() on the resulting array.\nIf the lowerTimeframe value is greater than the chart’s timeframe, the script will raise a runtime error, as we have not supplied an ignore_invalid_timeframe argument in the request.security_lower_tf() call.\nTuples of intrabar data¶\nWhen passing a tuple or a function call that returns a tuple as the expression argument in request.security_lower_tf(), the result is a tuple of arrays with type templates corresponding to the types within the argument. For example, using a [float, string, color] tuple as the expression will result in [array<float>, array<string>, array<color>] data returned by the function. Using a tuple expression allows a script to fetch several arrays of intrabar data with a single request.security_lower_tf() function call.\nThe combined size of all tuples returned by request.*() calls in a script is limited to 127 elements. See this section of the Limitations page for more information.\nThe following example requests OHLC data from a lower timeframe and visualizes the current bar’s intrabars on the chart using lines and boxes. The script calls request.security_lower_tf() with the [open, high, low, close] tuple as its expression to retrieve a tuple of arrays representing OHLC information from a calculated lowerTimeframe. It then uses a for loop to set line coordinates with the retrieved data and current bar indices to display the results next to the current chart bar, providing a “magnified view” of the price movement within the latest candle. It also draws a box around the lines to indicate the chart region occupied by intrabar drawings:\nindicator(\"Tuples of intrabar data demo\", \"Candle magnifier\", max_lines_count = 500)\n//@variable The maximum number of intrabars to display.\nint maxIntrabars = input.int(20, \"Max intrabars\", 1, 250)\n//@variable The width of the drawn candle bodies.\nint candleWidth = input.int(20, \"Candle width\", 2)\n//@variable The largest valid timeframe closest to `maxIntrabars` times smaller than the chart timeframe.\nstring lowerTimeframe = timeframe.from_seconds(math.ceil(timeframe.in_seconds() / maxIntrabars))\n//@variable An array of lines to represent intrabar wicks.\nvar array<line> wicks = array.new<line>()\n//@variable An array of lines to represent intrabar bodies.\nvar array<line> bodies = array.new<line>()\n//@variable A box that surrounds the displayed intrabars.\nvar box magnifierBox = box.new(na, na, na, na, bgcolor = na)\n// Fill the `wicks` and `bodies` arrays with blank lines on the first bar.\nif barstate.isfirst\nfor i = 1 to maxIntrabars\narray.push(wicks, line.new(na, na, na, na, color = color.gray))\narray.push(bodies, line.new(na, na, na, na, width = candleWidth))\n//@variable A tuple of \"float\" arrays containing `open`, `high`, `low`, and `close` prices from the `lowerTimeframe`.\n[oData, hData, lData, cData] = request.security_lower_tf(syminfo.tickerid, lowerTimeframe, [open, high, low, close])\n//@variable The number of intrabars retrieved from the `lowerTimeframe` on the chart bar.\nint numIntrabars = array.size(oData)\nif numIntrabars > 0\n// Define the start and end bar index values for intrabar display.\nint startIndex = bar_index + 2\nint endIndex = startIndex + numIntrabars\n// Loop to update lines.\nfor i = 0 to maxIntrabars - 1\nline wickLine = array.get(wicks, i)\nline bodyLine = array.get(bodies, i)\nif i < numIntrabars\n//@variable The `bar_index` of the drawing.\nint candleIndex = startIndex + i\n// Update the properties of the `wickLine` and `bodyLine`.\nline.set_xy1(wickLine, startIndex + i, array.get(hData, i))\nline.set_xy2(wickLine, startIndex + i, array.get(lData, i))\nline.set_xy1(bodyLine, startIndex + i, array.get(oData, i))\nline.set_xy2(bodyLine, startIndex + i, array.get(cData, i))\nline.set_color(bodyLine, bodyLine.get_y2() > bodyLine.get_y1() ? color.teal : color.maroon)\ncontinue\n// Set the coordinates of the `wickLine` and `bodyLine` to `na` if no intrabar data is available at the index.\nline.set_xy1(wickLine, na, na)\nline.set_xy2(wickLine, na, na)\nline.set_xy1(bodyLine, na, na)\nline.set_xy2(bodyLine, na, na)\n// Set the coordinates of the `magnifierBox`.\nbox.set_lefttop(magnifierBox, startIndex - 1, array.max(hData))\nbox.set_rightbottom(magnifierBox, endIndex, array.min(lData))\nThe script draws each candle using two lines: one to represent wicks and the other to represent the body. Since the script can display up to 500 lines on the chart, we’ve limited the maxIntrabars input to 250.\nThe lowerTimeframe value is the result of calculating the math.ceil() of the timeframe.in_seconds() divided by the maxIntrabars and converting to a valid timeframe string with timeframe.from_seconds().\nThe script sets the top of the box drawing using the array.max() of the requested hData array, and it sets the box’s bottom using the array.min() of the requested lData array. As we see on the chart, these values correspond to the high and low of the chart bar.\nRequesting collections¶\nIn some cases, a script may need to request the IDs of collections from an intrabar context. However, unlike request.security(), one cannot pass collections or calls to functions that return them as the expression argument in a request.security_lower_tf() call, as arrays cannot directly reference other collections.\nDespite these limitations, it is possible to request collections from lower timeframes, if needed, with the help of wrapper types.\nThe use case described below is advanced and not recommended for beginners. Before exploring this approach, we recommend understanding how user-defined types and collections work in Pine Script™. When possible, we recommend using simpler methods to manage LTF requests, and only using this approach when nothing else will suffice.\nTo make collections requestable with request.security_lower_tf(), we must create a UDT with a field to reference a collection ID. This step is necessary since arrays cannot reference other collections directly but can reference UDTs with collection fields:\n//@type A \"wrapper\" type to hold an `array<float>` instance.\ntype Wrapper\narray<float> collection\nWith our Wrapper UDT defined, we can now pass the IDs of objects of the UDT to the expression parameter in request.security_lower_tf().\nA straightforward approach is to call the built-in *.new() function as the expression. For example, this line of code calls Wrapper.new() with array.from(close) as its collection within request.security_lower_tf():\n//@variable An array of `Wrapper` IDs requested from the 1-minute timeframe.\narray<Wrapper> wrappers = request.security_lower_tf(syminfo.tickerid, \"1\", Wrapper.new(array.from(close)))\nAlternatively, we can create a user-defined function or method that returns an object of the UDT and call that function within request.security_lower_tf(). For instance, this code calls a custom newWrapper() function that returns a Wrapper ID as the expression argument:\n//@function Creates a new `Wrapper` instance to wrap the specified `collection`.\nnewWrapper(array<float> collection) =>\nWrapper.new(collection)\n//@variable An array of `Wrapper` IDs requested from the 1-minute timeframe.\narray<Wrapper> wrappers = request.security_lower_tf(syminfo.tickerid, \"1\", newWrapper(array.from(close)))\nThe result with either of the above is an array containing Wrapper IDs from all available intrabars in the chart bar, which the script can use to reference Wrapper instances from specific intrabars and use their collection fields in additional operations.\nThe script below utilizes this approach to collect arrays of intrabar data from a lowerTimeframe and uses them to display data from a specific intrabar. Its custom Prices type contains a single data field to reference array<float> instances that hold price data, and the user-defined newPrices() function returns the ID of a Prices object.\nThe script calls request.security_lower_tf() with a newPrices() call as its expression argument to retrieve an array of Prices IDs from each intrabar in the chart bar, then uses array.get() to get the ID from a specified available intrabar, if it exists. Lastly, it uses array.get() on the data array assigned to that instance and calls plotcandle() to display its values on the chart:\nindicator(\"Requesting LTF collections demo\", \"Intrabar viewer\", true)\n//@variable The timeframe of the LTF data request.\nstring lowerTimeframe = input.timeframe(\"1\", \"Timeframe\")\n//@variable The index of the intrabar to show on each chart bar. 0 is the first available intrabar.\nint intrabarIndex = input.int(0, \"Intrabar to show\", 0)\n//@variable A custom type to hold an array of price `data`.\ntype Prices\narray<float> data\n//@function Returns a new `Prices` instance containing current `open`, `high`, `low`, and `close` prices.\nnewPrices() =>\nPrices.new(array.from(open, high, low, close))\n//@variable An array of `Prices` requested from the `lowerTimeframe`.\narray<Prices> requestedPrices = request.security_lower_tf(syminfo.tickerid, lowerTimeframe, newPrices())\n//@variable The `Prices` ID from the `requestedPrices` array at the `intrabarIndex`, or `na` if not available.\nPrices intrabarPrices = array.size(requestedPrices) > intrabarIndex ? array.get(requestedPrices, intrabarIndex) : na\n//@variable The `data` array from the `intrabarPrices`, or an array of `na` values if `intrabarPrices` is `na`.\narray<float> intrabarData = na(intrabarPrices) ? array.new<float>(4, na) : intrabarPrices.data\n// Plot the `intrabarData` values as candles.\nplotcandle(intrabarData.get(0), intrabarData.get(1), intrabarData.get(2), intrabarData.get(3))\nThe intrabarPrices variable only references a Prices ID if the size of the requestedPrices array is greater than the intrabarIndex, as attempting to use array.get() to get an element that doesn’t exist will result in an out of bounds error.\nThe intrabarData variable only references the data field from intrabarPrices if a valid Prices ID exists since a script cannot reference fields of an na value.\nThe process used in this example is not necessary to achieve the intended result. We could instead avoid using UDTs and pass an [open, high, low, close] tuple to the expression parameter to retrieve a tuple of arrays for further operations, as explained in the previous section.\nCustom contexts¶\nPine Script™ includes multiple ticker.*() functions that allow scripts to construct custom ticker IDs that specify additional settings for data requests when used as a symbol argument in request.security() and request.security_lower_tf():\nticker.new() constructs a custom ticker ID from a specified prefix and ticker with additional session and adjustment settings.\nticker.modify() constructs a modified form of a specified tickerid with additional session and adjustment settings.\nticker.heikinashi(), ticker.renko(), ticker.pointfigure(), ticker.kagi(), and ticker.linebreak() construct a modified form a symbol with non-standard chart settings.\nticker.inherit() constructs a new ticker ID for a symbol with additional parameters inherited from the from_tickerid specified in the function call, allowing scripts to request the symbol data with the same modifiers as the from_tickerid, including session, dividend adjustment, currency conversion, non-standard chart type, back-adjustment, settlement-as-close, etc.\nticker.standard() constructs a standard ticker ID representing the symbol without additional modifiers.\nLet’s explore some practical examples of applying ticker.*() functions to request data from custom contexts.\nSuppose we want to include dividend adjustment in a stock symbol’s prices without enabling the “Adjust data for dividends” option in the “Symbol” section of the chart’s settings. We can achieve this in a script by constructing a custom ticker ID for the instrument using ticker.new() or ticker.modify() with an adjustment value of adjustment.dividends.\nThis script creates an adjustedTickerID using ticker.modify(), uses that ticker ID as the symbol in request.security() to retrieve a tuple of adjusted price values, then plots the result as candles on the chart. It also highlights the background when the requested prices differ from the prices without dividend adjustment.\nAs we see on the “NYSE:XOM” chart below, enabling dividend adjustment results in different historical values before the date of the latest dividend:\nindicator(\"Custom contexts demo 1\", \"Adjusted prices\", true)\n//@variable A custom ticker ID representing the chart's symbol with the dividend adjustment modifier.\nstring adjustedTickerID = ticker.modify(syminfo.tickerid, adjustment = adjustment.dividends)\n// Request the adjusted prices for the chart's symbol.\n[o, h, l, c] = request.security(adjustedTickerID, timeframe.period, [open, high, low, close])\n//@variable The color of the candles on the chart.\ncolor candleColor = c > o ? color.teal : color.maroon\n// Plot the adjusted prices.\nplotcandle(o, h, l, c, \"Adjusted Prices\", candleColor)\n// Highlight the background when `c` is different from `close`.\nbgcolor(c != close ? color.new(color.orange, 80) : na)\nIf a modifier included in a constructed ticker ID does not apply to the symbol, the script will ignore that modifier when requesting data. For instance, this script will display the same values as the main chart on forex symbols such as “EURUSD”.\nWhile the example above demonstrates a simple way to modify the chart’s symbol, a more frequent use case for ticker.*() functions is applying custom modifiers to another symbol while requesting data. If a ticker ID referenced in a script already has the modifiers one would like to apply (e.g., adjustment settings, session type, etc.), they can use ticker.inherit() to quickly and efficiently add those modifiers to another symbol.\nIn the example below, we’ve edited the previous script to request data for a symbolInput using modifiers inherited from the adjustedTickerID. This script calls ticker.inherit() to construct an inheritedTickerID and uses that ticker ID in a request.security() call. It also requests data for the symbolInput without additional modifiers and plots candles for both ticker IDs in a separate chart pane to compare the difference.\nAs shown on the chart, the data requested using the inheritedTickerID includes dividend adjustment, whereas the data requested using the symbolInput directly does not:\nindicator(\"Custom contexts demo 2\", \"Inherited adjustment\")\n//@variable The symbol to request data from.\nstring symbolInput = input.symbol(\"NYSE:PFE\", \"Symbol\")\n//@variable A custom ticker ID representing the chart's symbol with the dividend adjustment modifier.\nstring adjustedTickerID = ticker.modify(syminfo.tickerid, adjustment = adjustment.dividends)\n//@variable A custom ticker ID representing the `symbolInput` with modifiers inherited from the `adjustedTickerID`.\nstring inheritedTickerID = ticker.inherit(adjustedTickerID, symbolInput)\n// Request prices using the `symbolInput`.\n[o1, h1, l1, c1] = request.security(symbolInput, timeframe.period, [open, high, low, close])\n// Request prices using the `inheritedTickerID`.\n[o2, h2, l2, c2] = request.security(inheritedTickerID, timeframe.period, [open, high, low, close])\n//@variable The color of the candles that use the `inheritedTickerID` prices.\ncolor candleColor = c2 > o2 ? color.teal : color.maroon\n// Plot the `symbol` prices.\nplotcandle(o1, h1, l1, c1, \"Symbol\", color.gray, color.gray, bordercolor = color.gray)\n// Plot the `inheritedTickerID` prices.\nplotcandle(o2, h2, l2, c2, \"Symbol With Modifiers\", candleColor)\n// Highlight the background when `c1` is different from `c2`.\nbgcolor(c1 != c2 ? color.new(color.orange, 80) : na)\nSince the adjustedTickerID represents a modified form of the syminfo.tickerid, if we modify the chart’s context in other ways, such as changing the chart type or enabling extended trading hours in the chart’s settings, those modifiers will also apply to the adjustedTickerID and inheritedTickerID. However, they will not apply to the symbolInput since it represents a standard ticker ID.\nAnother frequent use case for requesting custom contexts is retrieving data that uses non-standard chart calculations. For example, suppose we want to use Renko price values to calculate trade signals in a strategy() script. If we simply change the chart type to “Renko” to get the prices, the strategy will also simulate its trades based on those synthetic prices, producing misleading results:\nstrategy(\n\"Custom contexts demo 3\", \"Renko strategy\", true, default_qty_type = strategy.percent_of_equity,\ndefault_qty_value = 2, initial_capital = 50000, slippage = 2,\ncommission_type = strategy.commission.cash_per_contract, commission_value = 1, margin_long = 100,\nmargin_short = 100\n//@variable When `true`, the strategy places a long market order.\nbool longEntry = ta.crossover(close, open)\n//@variable When `true`, the strategy places a short market order.\nbool shortEntry = ta.crossunder(close, open)\nif longEntry\nstrategy.entry(\"Long Entry\", strategy.long)\nif shortEntry\nstrategy.entry(\"Short Entry\", strategy.short)\nTo ensure our strategy shows results based on actual prices, we can create a Renko ticker ID using ticker.renko() while keeping the chart on a standard type, allowing the script to request and use Renko prices to calculate its signals without calculating the strategy results on them:\nstrategy(\n\"Custom contexts demo 3\", \"Renko strategy\", true, default_qty_type = strategy.percent_of_equity,\ndefault_qty_value = 2, initial_capital = 50000, slippage = 1,\ncommission_type = strategy.commission.cash_per_contract, commission_value = 1, margin_long = 100,\nmargin_short = 100\n//@variable A Renko ticker ID.\nstring renkoTickerID = ticker.renko(syminfo.tickerid, \"ATR\", 14)\n// Request the `open` and `close` prices using the `renkoTickerID`.\n[renkoOpen, renkoClose] = request.security(renkoTickerID, timeframe.period, [open, close])\n//@variable When `true`, the strategy places a long market order.\nbool longEntry = ta.crossover(renkoClose, renkoOpen)\n//@variable When `true`, the strategy places a short market order.\nbool shortEntry = ta.crossunder(renkoClose, renkoOpen)\nif longEntry\nstrategy.entry(\"Long Entry\", strategy.long)\nif shortEntry\nstrategy.entry(\"Short Entry\", strategy.short)\nplot(renkoOpen)\nplot(renkoClose)\nHistorical and realtime behavior¶\nFunctions in the request.*() namespace can behave differently on historical and realtime bars. This behavior is closely related to Pine’s Execution model.\nConsider how a script behaves within the main context. Throughout the chart’s history, the script calculates its required values once and commits them to that bar so their states are accessible later in the execution. On an unconfirmed bar, however, the script recalculates its values on each update to the bar’s data to align with realtime changes. Before recalculating the values on that bar, it reverts calculated values to their last committed states, otherwise known as rollback, and it only commits values to that bar once the bar closes.\nNow consider the behavior of data requests from other contexts with request.security(). As when evaluating historical bars in the main context, request.security() only returns new historical values when it confirms a bar in its specified context. When executing on realtime bars, it returns recalculated values on each chart bar, similar to how a script recalculates values in the main context on the open chart bar.\nHowever, the function only confirms the requested values when a bar from its context closes. When the script restarts its execution, what were previously considered realtime bars become historical bars. Therefore, request.security() will only return the values it confirmed on those bars. In essence, this behavior means that requested data may repaint when its values fluctuate on realtime bars without confirmation from the context.\nIt’s often helpful to distinguish historical bars from realtime bars when working with request.*() functions. Scripts can determine whether bars have historical or realtime states via the barstate.ishistory and barstate.isrealtime variables.\nIn most circumstances where a script requests data from a broader context, one will typically require confirmed, stable values that do not fluctuate on realtime bars. The section below explains how to achieve such a result and avoid repainting data requests.\nAvoiding Repainting¶\nHigher-timeframe data¶\nWhen requesting values from a higher timeframe, they are subject to repainting since realtime bars can contain unconfirmed information from developing HTF bars, and the script may adjust the times that new values come in on historical bars. To avoid repainting HTF data, one must ensure that the function only returns confirmed values with consistent timing on all bars, regardless of bar state.\nThe most reliable approach to achieve non-repainting results is to use an expression argument that only references past bars (e.g., close[1]) while using barmerge.lookahead_on as the lookahead value.\nUsing barmerge.lookahead_on with non-offset HTF data requests is discouraged since it prompts request.security() to “look ahead” to the final values of an HTF bar, retrieving confirmed values before they’re actually available in the script’s history. However, if the values used in the expression are offset by at least one bar, the “future” data the function retrieves is no longer from the future. Instead, the data represents confirmed values from established, available HTF bars. In other words, applying an offset to the expression effectively prevents the requested data from repainting when the script restarts its execution and eliminates lookahead bias in the historical series.\nThe following example demonstrates a repainting HTF data request. The script uses request.security() without offset modifications or additional arguments to retrieve the results of a ta.wma() call from a higher timeframe. It also highlights the background to indicate which bars were in a realtime state during its calculations.\nAs shown on the chart below, the plot of the requested WMA only changes on historical bars when HTF bars close, whereas it fluctuates on all realtime bars since the data includes unconfirmed values from the higher timeframe:\nindicator(\"Avoiding HTF repainting demo\", overlay = true)\n//@variable The multiplier applied to the chart's timeframe.\nint tfMultiplier = input.int(10, \"Timeframe multiplier\", 1)\n//@variable The number of bars in the moving average.\nint length = input.int(5, \"WMA smoothing length\")\n//@variable The valid timeframe string closest to `tfMultiplier` times larger than the chart timeframe.\nstring timeframe = timeframe.from_seconds(timeframe.in_seconds() * tfMultiplier)\n//@variable The weighted MA of `close` prices over `length` bars on the `timeframe`.\n// This request repaints because it includes unconfirmed HTF data on realtime bars and it may offset the\n// times of its historical results.\nfloat requestedWMA = request.security(syminfo.tickerid, timeframe, ta.wma(close, length))\n// Plot the requested series.\nplot(requestedWMA, \"HTF WMA\", color.purple, 3)\n// Highlight the background on realtime bars.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime bar highlight\")\nTo avoid repainting in this script, we can add lookahead = barmerge.lookahead_on to the request.security() call and offset the call history of ta.wma() by one bar with the history-referencing operator [], ensuring the request always retrieves the last confirmed HTF bar’s WMA at the start of each new timeframe. Unlike the previous script, this version has consistent behavior on historical and realtime bar states, as we see below:\nindicator(\"Avoiding HTF repainting demo\", overlay = true)\n//@variable The multiplier applied to the chart's timeframe.\nint tfMultiplier = input.int(10, \"Timeframe multiplier\", 1)\n//@variable The number of bars in the moving average.\nint length = input.int(5, \"WMA smoothing length\")\n//@variable The valid timeframe string closest to `tfMultiplier` times larger than the chart timeframe.\nstring timeframe = timeframe.from_seconds(timeframe.in_seconds() * tfMultiplier)\n//@variable The weighted MA of `close` prices over `length` bars on the `timeframe`.\n// This request does not repaint, as it always references the last confirmed WMA value on all bars.\nfloat requestedWMA = request.security(\nsyminfo.tickerid, timeframe, ta.wma(close, length)[1], lookahead = barmerge.lookahead_on\n// Plot the requested value.\nplot(requestedWMA, \"HTF WMA\", color.purple, 3)\nbgcolor(barstate.isrealtime ? color.new(color.orange, 70) : na, title = \"Realtime bar highlight\")\nLower-timeframe data¶\nThe request.security() and request.security_lower_tf() functions can retrieve data from lower-timeframe contexts. The request.security() function can only retrieve data from a single intrabar in each chart bar, and request.security_lower_tf() retrieves data from all available intrabars.\nWhen using these functions to retrieve intrabar data, it’s important to note that such requests are not immune to repainting behavior. Historical and realtime series often rely on separate data feeds. Data providers may retroactively modify realtime data, and it’s possible for races to occur in realtime data feeds, as explained in the Data feeds section of this page. Either case may result in intrabar data retrieved on realtime bars repainting after the script restarts its execution.\nAdditionally, a particular case that will cause repainting LTF requests is using request.security() with barmerge.lookahead_on to retrieve data from the first intrabar in each chart bar. While it will generally work as expected on historical bars, it will track only the most recent intrabar on realtime bars, as request.security() does not retain all intrabar information, and the intrabars retrieved by the function on realtime bars are unsorted until restarting the script’s execution:\nindicator(\"Avoiding LTF repainting demo\", overlay = true)\n//@variable The lower timeframe of the requested data.\nstring lowerTimeframe = input.timeframe(\"1\", \"Timeframe\")\n//@variable The first intrabar `close` requested from the `lowerTimeframe` on each bar.\n// Only works as intended on historical bars.\nfloat requestedClose = request.security(syminfo.tickerid, lowerTimeframe, close, lookahead = barmerge.lookahead_on)\n// Plot the `requestedClose`.\nplot(requestedClose, \"First intrabar close\", linewidth = 3)\nbgcolor(barstate.isrealtime ? color.new(color.orange, 60) : na, title = \"Realtime bar Highlight\")\nOne can mitigate this behavior and track the values from the first intrabar, or any available intrabar in the chart bar, by using request.security_lower_tf() since it maintains an array of intrabar values ordered by the times they come in. Here, we call array.first() on a requested array of intrabar data to retrieve the close price from the first available intrabar in each chart bar:\nindicator(\"Avoiding LTF repainting demo\", overlay = true)\n//@variable The lower timeframe of the requested data.\nstring lowerTimeframe = input.timeframe(\"1\", \"Timeframe\")\n//@variable An array of intrabar `close` values requested from the `lowerTimeframe` on each bar.\narray<float> requestedCloses = request.security_lower_tf(syminfo.tickerid, lowerTimeframe, close)\n//@variable The first intrabar `close` on each bar with available data.\nfloat firstClose = requestedCloses.size() > 0 ? requestedCloses.first() : na\n// Plot the `firstClose`.\nplot(firstClose, \"First intrabar close\", linewidth = 3)\nbgcolor(barstate.isrealtime ? color.new(color.orange, 60) : na, title = \"Realtime bar Highlight\")\nWhile request.security_lower_tf() is more optimized for handling historical and realtime intrabars, it’s still possible in some cases for minor repainting to occur due to data differences from the provider, as outlined above.\nThis code may not show intrabar data on all available chart bars, depending on how many intrabars each chart bar contains, as request.*() functions can retrieve up to 100,000 intrabars from an LTF context. See this section of the Limitations page for more information.\n`request.currency_rate()`¶\nWhen a script needs to convert values expressed in one currency to another, one can use request.currency_rate(). This function requests a daily rate for currency conversion calculations based on “FX_IDC” data, providing a simpler alternative to fetching specific pairs or spreads with request.security().\nWhile one can use request.security() to retrieve daily currency rates, its use case is more involved than request.currency_rate(), as one needs to supply a valid ticker ID for a currency pair or spread to request the rate. Additionally, a historical offset and barmerge.lookahead_on are necessary to prevent the results from repainting, as explained in this section.\nThe request.currency_rate() function, on the other hand, only requires currency codes. No ticker ID is needed when requesting rates with this function, and it ensures non-repainting results without requiring additional specification.\nThe function’s signature is as follows:\nrequest.currency_rate(from, to, ignore_invalid_currency) → series float\nThe from parameter specifies the currency to convert, and the to parameter specifies the target currency. Both parameters accept “string” values in the ISO 4217 format (e.g., “USD”) or any built-in currency.* variable (e.g., currency.USD).\nWhen the function cannot calculate a valid conversion rate between the from and to currencies supplied in the call, one can decide whether it will raise a runtime error or return na via the ignore_invalid_currency parameter. The default value is false, meaning the function will raise a runtime error and halt the script’s execution.\nThe following example demonstrates a simple use case for request.currency_rate(). Suppose we want to convert values expressed in Turkish lira (currency.TRY) to South Korean won (currency.KRW) using a daily conversion rate. If we use request.security() to retrieve the rate, we must supply a valid ticker ID and request the last confirmed close from the previous day.\nIn this case, no “FX_IDC” symbol exists that would allow us to retrieve a conversion rate directly with request.security(). Therefore, we first need a ticker ID for a spread that converts TRY to an intermediate currency, such as USD, then converts the intermediate currency to KRW. We can then use that ticker ID within request.security() with close[1] as the expression and barmerge.lookahead_on as the lookahead value to request a non-repainting daily rate.\nAlternatively, we can achieve the same result more simply by calling request.currency_rate(). This function does all the heavy lifting for us, only requiring from and to currency arguments to perform its calculation.\nAs we see below, both approaches return the same daily rate:\nindicator(\"Requesting currency rates demo\")\n//@variable The currency to convert.\nsimple string fromCurrency = currency.TRY\n//@variable The resulting currency.\nsimple string toCurrency = currency.KRW\n//@variable The spread symbol to request. Required in `request.security()` since no direct \"FX_IDC\" rate exists.\nsimple string spreadSymbol = str.format(\"FX_IDC:{0}{2} * FX_IDC:{2}{1}\", fromCurrency, toCurrency, currency.USD)\n//@variable The non-repainting conversion rate from `request.security()` using the `spreadSymbol`.\nfloat securityRequestedRate = request.security(spreadSymbol, \"1D\", close[1], lookahead = barmerge.lookahead_on)\n//@variable The non-repainting conversion rate from `request.currency_rate()`.\nfloat nonSecurityRequestedRate = request.currency_rate(fromCurrency, toCurrency)\n// Plot the requested rates. We can multiply TRY values by these rates to convert them to KRW.\nplot(securityRequestedRate, \"`request.security()` value\", color.purple, 5)\nplot(nonSecurityRequestedRate, \"`request.currency_rate()` value\", color.yellow, 2)\n`request.dividends()`, `request.splits()`, and `request.earnings()`¶\nAnalyzing a stock’s earnings data and corporate actions provides helpful insights into its underlying financial strength. Pine Script™ provides the ability to retrieve essential information about applicable stocks via request.dividends(), request.splits(), and request.earnings().\nThese are the functions’ signatures:\nrequest.dividends(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float\nrequest.splits(ticker, field, gaps, lookahead, ignore_invalid_symbol) → series float\nrequest.earnings(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float\nEach function has the same parameters in its signature, with the exception of request.splits(), which doesn’t have a currency paramter.\nNote that unlike the symbol parameter in other request.*() functions, the ticker parameter in these functions only accepts an “Exchange:Symbol” pair, such as “NASDAQ:AAPL”. The built-in syminfo.ticker variable does not work with these functions since it does not contain exchange information. Instead, one must use syminfo.tickerid for such cases.\nThe field parameter determines the data the function will retrieve. Each of these functions accepts different built-in variables as the field argument since each requests different information about a stock:\nThe request.dividends() function retrieves current dividend information for a stock, i.e., the amount per share the issuing company paid out to investors who purchased shares before the ex-dividend date. Passing the built-in dividends.gross or dividends.net variables to the field parameter specifies whether the returned value represents dividends before or after factoring in expenses the company deducts from its payouts.\nThe request.splits() function retrieves current split and reverse split information for a stock. A split occurs when a company increases its outstanding shares to promote liquidity. A reverse split occurs when a company consolidates its shares and offers them at a higher price to attract specific investors or maintain their listing on a market that has a minimum per-share price. Companies express their split information as ratios. For example, a 5:1 split means the company issued additional shares to its shareholders so that they have five times the number of shares they had before the split, and the raw price of each share becomes one-fifth of the previous price. Passing splits.numerator or splits.denominator to the field parameter of request.splits() determines whether it returns the numerator or denominator of the split ratio.\nThe request.earnings() function retrieves the earnings per share (EPS) information for a stock ticker’s issuing company. The EPS value is the ratio of a company’s net income to the number of outstanding stock shares, which investors consider an indicator of the company’s profitability. Passing earnings.actual, earnings.estimate, or earnings.standardized as the field argument in request.earnings() respectively determines whether the function requests the actual, estimated, or standardized EPS value.\nFor a detailed explanation of the gaps, lookahead, and ignore_invalid_symbol parameters of these functions, see the Common characteristics section at the top of this page.\nIt’s important to note that the values returned by these functions reflect the data available as it comes in. This behavior differs from financial data originating from a request.financial() call in that the underlying data from such calls becomes available according to a company’s fiscal reporting period.\nScripts can also retrieve information about upcoming earnings and dividends for an instrument via the earnings.future_* and dividends.future_* built-in variables.\nHere, we’ve included an example that displays a handy table containing the most recent dividend, split, and EPS data. The script calls the request.*() functions discussed in this section to retrieve the data, then converts the values to “strings” with str.*() functions and displays the results in the infoTable with table.cell():\nindicator(\"Dividends, splits, and earnings demo\", overlay = true)\n//@variable The size of the table's text.\nstring tableSize = input.string(\nsize.large, \"Table size\", [size.auto, size.tiny, size.small, size.normal, size.large, size.huge]\n//@variable The color of the table's text and frame.\nvar color tableColor = chart.fg_color\n//@variable A `table` displaying the latest dividend, split, and EPS information.\nvar table infoTable = table.new(position.top_right, 3, 4, frame_color = tableColor, frame_width = 1)\n// Add header cells on the first bar.\nif barstate.isfirst\ntable.cell(infoTable, 0, 0, \"Field\", text_color = tableColor, text_size = tableSize)\ntable.cell(infoTable, 1, 0, \"Value\", text_color = tableColor, text_size = tableSize)\ntable.cell(infoTable, 2, 0, \"Date\", text_color = tableColor, text_size = tableSize)\ntable.cell(infoTable, 0, 1, \"Dividend\", text_color = tableColor, text_size = tableSize)\ntable.cell(infoTable, 0, 2, \"Split\", text_color = tableColor, text_size = tableSize)\ntable.cell(infoTable, 0, 3, \"EPS\", text_color = tableColor, text_size = tableSize)\n//@variable The amount of the last reported dividend as of the current bar.\nfloat latestDividend = request.dividends(syminfo.tickerid, dividends.gross, barmerge.gaps_on)\n//@variable The numerator of that last reported split ratio as of the current bar.\nfloat latestSplitNum = request.splits(syminfo.tickerid, splits.numerator, barmerge.gaps_on)\n//@variable The denominator of the last reported split ratio as of the current bar.\nfloat latestSplitDen = request.splits(syminfo.tickerid, splits.denominator, barmerge.gaps_on)\n//@variable The last reported earnings per share as of the current bar.\nfloat latestEPS = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on)\n// Update the \"Value\" and \"Date\" columns when new values come in.\nif not na(latestDividend)\ntable.cell(\ninfoTable, 1, 1, str.tostring(math.round(latestDividend, 3)), text_color = tableColor, text_size = tableSize\ntable.cell(infoTable, 2, 1, str.format_time(time, \"yyyy-MM-dd\"), text_color = tableColor, text_size = tableSize)\nif not na(latestSplitNum)\ntable.cell(\ninfoTable, 1, 2, str.format(\"{0}-for-{1}\", latestSplitNum, latestSplitDen), text_color = tableColor,\ntext_size = tableSize\ntable.cell(infoTable, 2, 2, str.format_time(time, \"yyyy-MM-dd\"), text_color = tableColor, text_size = tableSize)\nif not na(latestEPS)\ntable.cell(infoTable, 1, 3, str.tostring(latestEPS), text_color = tableColor, text_size = tableSize)\ntable.cell(infoTable, 2, 3, str.format_time(time, \"yyyy-MM-dd\"), text_color = tableColor, text_size = tableSize)\nWe’ve included barmerge.gaps_on in the request.*() calls, so they only return values when new data is available. Otherwise, they return na.\nThe script assigns a table ID to the infoTable variable on the first chart bar. On subsequent bars, it updates necessary cells with new information whenever data is available.\nIf no information is available from any of the request.*() calls throughout the chart’s history (e.g., if the ticker has no dividend information), the script does not initialize the corresponding cells since it’s unnecessary.\n`request.quandl()`¶\nTradingView forms partnerships with many fintech companies to provide users access to extensive information on financial instruments, economic data, and more. One of our many partners is Nasdaq Data Link (formerly Quandl), which provides multiple external data feeds that scripts can access via the request.quandl() function.\nHere is the function’s signature:\nrequest.quandl(ticker, gaps, index, ignore_invalid_symbol) → series float\nThe ticker parameter accepts a “simple string” representing the ID of the database published on Nasdaq Data Link and its time series code, separated by the “/” delimiter. For example, the code “FRED/DFF” represents the “Effective Federal Funds Rate” time series from the “Federal Reserve Economic Data” database.\nThe index parameter accepts a “simple int” representing the column index of the requested data, where 0 is the first available column. Consult the database’s documentaion on Nasdaq Data Link’s website to see available columns.\nFor details on the gaps and ignore_invalid_symbol parameters, see the Common characteristics section of this page.\nThe request.quandl() function can only request free data from Nasdaq Data Link. No data that requires a paid subscription to their services is accessible with this function. Nasdaq Data Link may change the data it provides over time, and they may not update available datasets regularly. Therefore, it’s up to programmers to research the supported data available for request and review the documentation provided for each dataset. You can search for free data here.\nThis script requests Bitcoin hash rate (“HRATE”) information from the “Bitcoin Data Insights” (“BCHAIN”) database and plots the retrieved time series data on the chart. It uses color.from_gradient() to color the area plot based on the distance from the current hash rate to its all-time high:\nindicator(\"Quandl demo\", \"BTC hash rate\")\n//@variable The estimated hash rate for the Bitcoin network.\nfloat hashRate = request.quandl(\"BCHAIN/HRATE\", barmerge.gaps_off, 0)\n//@variable The percentage threshold from the all-time highest `hashRate`.\nfloat dropThreshold = input.int(40, \"Drop threshold\", 0, 100)\n//@variable The all-time highest `hashRate`.\nfloat maxHashRate = ta.max(hashRate)\n//@variable The value `dropThreshold` percent below the `maxHashRate`.\nfloat minHashRate = maxHashRate * (100 - dropThreshold) / 100\n//@variable The color of the plot based on the `minHashRate` and `maxHashRate`.\ncolor plotColor = color.from_gradient(hashRate, minHashRate, maxHashRate, color.orange, color.blue)\n// Plot the `hashRate`.\nplot(hashRate, \"Hash Rate Estimate\", plotColor, style = plot.style_area)\n`request.financial()`¶\nFinancial metrics provide investors with insights about a company’s economic and financial health that are not tangible from solely analyzing its stock prices. TradingView offers a wide variety of financial metrics from FactSet that traders can access via the “Financials” tab in the “Indicators” menu of the chart. Scripts can access available metrics for an instrument directly via the request.financial() function.\nThis is the function’s signature:\nrequest.financial(symbol, financial_id, period, gaps, ignore_invalid_symbol, currency) → series float\nAs with the first parameter in request.dividends(), request.splits(), and request.earnings(), the symbol parameter in request.financial() requires an “Exchange:Symbol” pair. To request financial information for the chart’s ticker ID, use syminfo.tickerid, as syminfo.ticker will not work.\nThe financial_id parameter accepts a “simple string” representing the ID of the requested financial metric. TradingView has numerous financial metrics to choose from. See the Financial IDs section below for an overview of all accessible metrics and their “string” identifiers.\nThe period parameter specifies the fiscal period for which new requested data comes in. It accepts one of the following arguments: “FQ” (quarterly), “FH” (semiannual), “FY” (annual), or “TTM” (trailing twelve months). Not all fiscal periods are available for all metrics or instruments. To confirm which periods are available for specific metrics, see the second column of the tables in the Financial IDs section.\nSee this page’s Common characteristics section for a detailed explanation of this function’s gaps, ignore_invalid_symbol, and currency parameters.\nIt’s important to note that the data retrieved from this function comes in at a fixed frequency, independent of the precise date on which the data is made available within a fiscal period. For a company’s dividends, splits, and earnings per share (EPS) information, one can request data reported on exact dates via request.dividends(), request.splits(), and request.earnings().\nThis script uses request.financial() to retrieve information about the income and expenses of a stock’s issuing company and visualize the profitability of its typical business operations. It requests the “OPER_INCOME”, “TOTAL_REVENUE”, and “TOTAL_OPER_EXPENSE” financial IDs for the syminfo.tickerid over the latest fiscalPeriod, then plots the results on the chart:\nindicator(\"Requesting financial data demo\", format = format.volume)\n//@variable The size of the fiscal reporting period. Some options may not be available, depending on the instrument.\nstring fiscalPeriod = input.string(\"FQ\", \"Period\", [\"FQ\", \"FH\", \"FY\", \"TTM\"])\n//@variable The operating income after expenses reported for the stock's issuing company.\nfloat operatingIncome = request.financial(syminfo.tickerid, \"OPER_INCOME\", fiscalPeriod)\n//@variable The total revenue reported for the stock's issuing company.\nfloat totalRevenue = request.financial(syminfo.tickerid, \"TOTAL_REVENUE\", fiscalPeriod)\n//@variable The total operating expenses reported for the stock's issuing company.\nfloat totalExpenses = request.financial(syminfo.tickerid, \"TOTAL_OPER_EXPENSE\", fiscalPeriod)\n//@variable Is aqua when the `totalRevenue` exceeds the `totalExpenses`, fuchsia otherwise.\ncolor incomeColor = operatingIncome > 0 ? color.new(color.aqua, 50) : color.new(color.fuchsia, 50)\n// Display the requested data.\nplot(operatingIncome, \"Operating income\", incomeColor, 1, plot.style_area)\nplot(totalRevenue, \"Total revenue\", color.green, 3)\nplot(totalExpenses, \"Total operating expenses\", color.red, 3)\nNot all fiscalPeriod options are available for every ticker ID. For example, companies in the US typically publish quarterly reports, whereas many European companies publish semiannual reports. See this page in our Help Center for more information.\nCalculating financial metrics¶\nThe request.financial() function can provide scripts with numerous useful financial metrics that don’t require additional calculations. However, some commonly used financial estimates require combining an instrument’s current market price with requested financial data. Such is the case for:\nMarket Capitalization (market price * total shares outstanding)\nEarnings Yield (12-month EPS / market price)\nPrice-to-Book Ratio (market price / BVPS)\nPrice-to-Earnings Ratio (market price / EPS)\nPrice-to-Sales Ratio (market cap / 12-month total revenue)\nThe following script contains user-defined functions that calculate the above financial metrics for the syminfo.tickerid. We’ve created these functions so users can easily copy them into their scripts. This example uses them within a str.format() call to construct a tooltipText, which it displays in tooltips on the chart using labels. Hovering over any bar’s label will expose the tooltip containing the metrics calculated on that bar:\nindicator(\"Calculating financial metrics demo\", overlay = true, max_labels_count = 500)\n//@function Calculates the market capitalization (market cap) for the chart's symbol.\nmarketCap() =>\n//@variable The most recent number of outstanding shares reported for the symbol.\nfloat totalSharesOutstanding = request.financial(syminfo.tickerid, \"TOTAL_SHARES_OUTSTANDING\", \"FQ\")\n// Return the market cap value.\ntotalSharesOutstanding * close\n//@function Calculates the Earnings Yield for the chart's symbol.\nearningsYield() =>\n//@variable The most recent 12-month earnings per share reported for the symbol.\nfloat eps = request.financial(syminfo.tickerid, \"EARNINGS_PER_SHARE\", \"TTM\")\n//Return the Earnings Yield percentage.\n100.0 * eps / close\n//@function Calculates the Price-to-Book (P/B) ratio for the chart's symbol.\npriceBookRatio() =>\n//@variable The most recent Book Value Per Share (BVPS) reported for the symbol.\nfloat bookValuePerShare = request.financial(syminfo.tickerid, \"BOOK_VALUE_PER_SHARE\", \"FQ\")\n// Return the P/B ratio.\nclose / bookValuePerShare\n//@function Calculates the Price-to-Earnings (P/E) ratio for the chart's symbol.\npriceEarningsRatio() =>\n//@variable The most recent 12-month earnings per share reported for the symbol.\nfloat eps = request.financial(syminfo.tickerid, \"EARNINGS_PER_SHARE\", \"TTM\")\n// Return the P/E ratio.\nclose / eps\n//@function Calculates the Price-to-Sales (P/S) ratio for the chart's symbol.\npriceSalesRatio() =>\n//@variable The most recent number of outstanding shares reported for the symbol.\nfloat totalSharesOutstanding = request.financial(syminfo.tickerid, \"TOTAL_SHARES_OUTSTANDING\", \"FQ\")\n//@variable The most recent 12-month total revenue reported for the symbol.\nfloat totalRevenue = request.financial(syminfo.tickerid, \"TOTAL_REVENUE\", \"TTM\")\n// Return the P/S ratio.\ntotalSharesOutstanding * close / totalRevenue\n//@variable The text to display in label tooltips.\nstring tooltipText = str.format(\n\"Market Cap: {0} {1}\\nEarnings Yield: {2}%\\nP/B Ratio: {3}\\nP/E Ratio: {4}\\nP/S Ratio: {5}\",\nstr.tostring(marketCap(), format.volume), syminfo.currency, earningsYield(), priceBookRatio(),\npriceEarningsRatio(), priceSalesRatio()\n//@variable Displays a blank label with a tooltip containing the `tooltipText`.\nlabel info = label.new(chart.point.now(high), tooltip = tooltipText)\nSince not all companies publish quarterly financial reports, one may need to change the “FQ” in these functions to match the minimum reporting period for a specific company, as the request.financial() calls will return na when “FQ” data isn’t available.\nFinancial IDs¶\nBelow is an overview of all financial metrics one can request via request.financial(), along with the periods in which reports may be available. We’ve divided this information into four tables corresponding to the categories displayed in the “Financials” section of the “Indicators” menu:\nIncome statements\nBalance sheet\nCash flow\nStatistics\nEach table has the following three columns:\nThe first column contains descriptions of each metric with links to Help Center pages for additional information.\nThe second column lists the possible period arguments allowed for the metric. Note that all available values may not be compatible with specific ticker IDs, e.g., while “FQ” may be a possible argument, it will not work if the issuing company does not publish quarterly data.\nThe third column lists the “string” IDs for the financial_id argument in request.financial().\nThe tables in these sections are quite lengthy, as there are many financial_id arguments available. Use the “Click to show/hide” option above each table to toggle its visibility.\nIncome statements¶\nThis table lists the available metrics that provide information about a company’s income, costs, profits and losses.\nClick to show/hide\nFinancial period financial_id \nAfter tax other income/expense\tFQ, FH, FY, TTM\tAFTER_TAX_OTHER_INCOME\t\nAverage basic shares outstanding\tFQ, FH, FY\tBASIC_SHARES_OUTSTANDING\t\nBasic earnings per share (Basic EPS)\tFQ, FH, FY, TTM\tEARNINGS_PER_SHARE_BASIC\t\nCost of goods sold\tFQ, FH, FY, TTM\tCOST_OF_GOODS\t\nDeprecation and amortization\tFQ, FH, FY, TTM\tDEP_AMORT_EXP_INCOME_S\t\nDiluted earnings per share (Diluted EPS)\tFQ, FH, FY, TTM\tEARNINGS_PER_SHARE_DILUTED\t\nDiluted net income available to common stockholders\tFQ, FH, FY, TTM\tDILUTED_NET_INCOME\t\nDiluted shares outstanding\tFQ, FH, FY\tDILUTED_SHARES_OUTSTANDING\t\nDilution adjustment\tFQ, FH, FY, TTM\tDILUTION_ADJUSTMENT\t\nDiscontinued operations\tFQ, FH, FY, TTM\tDISCONTINUED_OPERATIONS\t\nEBIT\tFQ, FH, FY, TTM\tEBIT\t\nEBITDA\tFQ, FH, FY, TTM\tEBITDA\t\nEquity in earnings\tFQ, FH, FY, TTM\tEQUITY_IN_EARNINGS\t\nGross profit\tFQ, FH, FY, TTM\tGROSS_PROFIT\t\nInterest capitalized\tFQ, FH, FY, TTM\tINTEREST_CAPITALIZED\t\nInterest expense on debt\tFQ, FH, FY, TTM\tINTEREST_EXPENSE_ON_DEBT\t\nInterest expense, net of interest capitalized\tFQ, FH, FY, TTM\tNON_OPER_INTEREST_EXP\t\nMiscellaneous non-operating expense\tFQ, FH, FY, TTM\tOTHER_INCOME\t\nNet income\tFQ, FH, FY, TTM\tNET_INCOME\t\nNet income before discontinued operations\tFQ, FH, FY, TTM\tNET_INCOME_BEF_DISC_OPER\t\nNon-controlling/minority interest\tFQ, FH, FY, TTM\tMINORITY_INTEREST_EXP\t\nNon-operating income, excl. interest expenses\tFQ, FH, FY, TTM\tNON_OPER_INCOME\t\nNon-operating income, total\tFQ, FH, FY, TTM\tTOTAL_NON_OPER_INCOME\t\nNon-operating interest income\tFQ, FH, FY, TTM\tNON_OPER_INTEREST_INCOME\t\nOperating expenses (excl. COGS)\tFQ, FH, FY, TTM\tOPERATING_EXPENSES\t\nOperating income\tFQ, FH, FY, TTM\tOPER_INCOME\t\nOther cost of goods sold\tFQ, FH, FY, TTM\tCOST_OF_GOODS_EXCL_DEP_AMORT\t\nOther operating expenses, total\tFQ, FH, FY, TTM\tOTHER_OPER_EXPENSE_TOTAL\t\nPreferred dividends\tFQ, FH, FY, TTM\tPREFERRED_DIVIDENDS\t\nPretax equity in earnings\tFQ, FH, FY, TTM\tPRETAX_EQUITY_IN_EARNINGS\t\nPretax income\tFQ, FH, FY, TTM\tPRETAX_INCOME\t\nResearch & development\tFQ, FH, FY, TTM\tRESEARCH_AND_DEV\t\nSelling/general/admin expenses, other\tFQ, FH, FY, TTM\tSELL_GEN_ADMIN_EXP_OTHER\t\nSelling/general/admin expenses, total\tFQ, FH, FY, TTM\tSELL_GEN_ADMIN_EXP_TOTAL\t\nTaxes\tFQ, FH, FY, TTM\tINCOME_TAX\t\nTotal operating expenses\tFQ, FH, FY, TTM\tTOTAL_OPER_EXPENSE\t\nTotal revenue\tFQ, FH, FY, TTM\tTOTAL_REVENUE\t\nUnusual income/expense\tFQ, FH, FY, TTM\tUNUSUAL_EXPENSE_INC\t\nBalance sheet¶\nThis table lists the metrics that provide information about a company’s capital structure.\nClick to show/hide\nFinancial period financial_id \nAccounts payable\tFQ, FH, FY\tACCOUNTS_PAYABLE\t\nAccounts receivable - trade, net\tFQ, FH, FY\tACCOUNTS_RECEIVABLES_NET\t\nAccrued payroll\tFQ, FH, FY\tACCRUED_PAYROLL\t\nAccumulated depreciation, total\tFQ, FH, FY\tACCUM_DEPREC_TOTAL\t\nAdditional paid-in capital/Capital surplus\tFQ, FH, FY\tADDITIONAL_PAID_IN_CAPITAL\t\nBook value per share\tFQ, FH, FY\tBOOK_VALUE_PER_SHARE\t\nCapital and operating lease obligations\tFQ, FH, FY\tCAPITAL_OPERATING_LEASE_OBLIGATIONS\t\nCapitalized lease obligations\tFQ, FH, FY\tCAPITAL_LEASE_OBLIGATIONS\t\nCash & equivalents\tFQ, FH, FY\tCASH_N_EQUIVALENTS\t\nCash and short term investments\tFQ, FH, FY\tCASH_N_SHORT_TERM_INVEST\t\nCommon equity, total\tFQ, FH, FY\tCOMMON_EQUITY_TOTAL\t\nCommon stock par/Carrying value\tFQ, FH, FY\tCOMMON_STOCK_PAR\t\nCurrent portion of LT debt and capital leases\tFQ, FH, FY\tCURRENT_PORT_DEBT_CAPITAL_LEASES\t\nDeferred income, current\tFQ, FH, FY\tDEFERRED_INCOME_CURRENT\t\nDeferred income, non-current\tFQ, FH, FY\tDEFERRED_INCOME_NON_CURRENT\t\nDeferred tax assets\tFQ, FH, FY\tDEFERRED_TAX_ASSESTS\t\nDeferred tax liabilities\tFQ, FH, FY\tDEFERRED_TAX_LIABILITIES\t\nDividends payable\tFY\tDIVIDENDS_PAYABLE\t\nGoodwill, net\tFQ, FH, FY\tGOODWILL\t\nGross property/plant/equipment\tFQ, FH, FY\tPPE_TOTAL_GROSS\t\nIncome tax payable\tFQ, FH, FY\tINCOME_TAX_PAYABLE\t\nInventories - finished goods\tFQ, FH, FY\tINVENTORY_FINISHED_GOODS\t\nInventories - progress payments & other\tFQ, FH, FY\tINVENTORY_PROGRESS_PAYMENTS\t\nInventories - raw materials\tFQ, FH, FY\tINVENTORY_RAW_MATERIALS\t\nInventories - work in progress\tFQ, FH, FY\tINVENTORY_WORK_IN_PROGRESS\t\nInvestments in unconsolidated subsidiaries\tFQ, FH, FY\tINVESTMENTS_IN_UNCONCSOLIDATE\t\nLong term debt\tFQ, FH, FY\tLONG_TERM_DEBT\t\nLong term debt excl. lease liabilities\tFQ, FH, FY\tLONG_TERM_DEBT_EXCL_CAPITAL_LEASE\t\nLong term investments\tFQ, FH, FY\tLONG_TERM_INVESTMENTS\t\nMinority interest\tFQ, FH, FY\tMINORITY_INTEREST\t\nNet debt\tFQ, FH, FY\tNET_DEBT\t\nNet intangible assets\tFQ, FH, FY\tINTANGIBLES_NET\t\nNet property/plant/equipment\tFQ, FH, FY\tPPE_TOTAL_NET\t\nNote receivable - long term\tFQ, FH, FY\tLONG_TERM_NOTE_RECEIVABLE\t\nNotes payable\tFY\tNOTES_PAYABLE_SHORT_TERM_DEBT\t\nOperating lease liabilities\tFQ, FH, FY\tOPERATING_LEASE_LIABILITIES\t\nOther common equity\tFQ, FH, FY\tOTHER_COMMON_EQUITY\t\nOther current assets, total\tFQ, FH, FY\tOTHER_CURRENT_ASSETS_TOTAL\t\nOther current liabilities\tFQ, FH, FY\tOTHER_CURRENT_LIABILITIES\t\nOther intangibles, net\tFQ, FH, FY\tOTHER_INTANGIBLES_NET\t\nOther investments\tFQ, FH, FY\tOTHER_INVESTMENTS\t\nOther long term assets, total\tFQ, FH, FY\tLONG_TERM_OTHER_ASSETS_TOTAL\t\nOther non-current liabilities, total\tFQ, FH, FY\tOTHER_LIABILITIES_TOTAL\t\nOther receivables\tFQ, FH, FY\tOTHER_RECEIVABLES\t\nOther short term debt\tFY\tOTHER_SHORT_TERM_DEBT\t\nPaid in capital\tFQ, FH, FY\tPAID_IN_CAPITAL\t\nPreferred stock, carrying value\tFQ, FH, FY\tPREFERRED_STOCK_CARRYING_VALUE\t\nPrepaid expenses\tFQ, FH, FY\tPREPAID_EXPENSES\t\nProvision for risks & charge\tFQ, FH, FY\tPROVISION_F_RISKS\t\nRetained earnings\tFQ, FH, FY\tRETAINED_EARNINGS\t\nShareholders’ equity\tFQ, FH, FY\tSHRHLDRS_EQUITY\t\nShort term debt\tFQ, FH, FY\tSHORT_TERM_DEBT\t\nShort term debt excl. current portion of LT debt\tFQ, FH, FY\tSHORT_TERM_DEBT_EXCL_CURRENT_PORT\t\nShort term investments\tFQ, FH, FY\tSHORT_TERM_INVEST\t\nTangible book value per share\tFQ, FH, FY\tBOOK_TANGIBLE_PER_SHARE\t\nTotal assets\tFQ, FH, FY\tTOTAL_ASSETS\t\nTotal current assets\tFQ, FH, FY\tTOTAL_CURRENT_ASSETS\t\nTotal current liabilities\tFQ, FH, FY\tTOTAL_CURRENT_LIABILITIES\t\nTotal debt\tFQ, FH, FY\tTOTAL_DEBT\t\nTotal equity\tFQ, FH, FY\tTOTAL_EQUITY\t\nTotal inventory\tFQ, FH, FY\tTOTAL_INVENTORY\t\nTotal liabilities\tFQ, FH, FY\tTOTAL_LIABILITIES\t\nTotal liabilities & shareholders’ equities\tFQ, FH, FY\tTOTAL_LIABILITIES_SHRHLDRS_EQUITY\t\nTotal non-current assets\tFQ, FH, FY\tTOTAL_NON_CURRENT_ASSETS\t\nTotal non-current liabilities\tFQ, FH, FY\tTOTAL_NON_CURRENT_LIABILITIES\t\nTotal receivables, net\tFQ, FH, FY\tTOTAL_RECEIVABLES_NET\t\nTreasury stock - common\tFQ, FH, FY\tTREASURY_STOCK_COMMON\t\nCash flow¶\nThis table lists the available metrics that provide information about how cash flows through a company.\nClick to show/hide\nFinancial period financial_id \nAmortization\tFQ, FH, FY, TTM\tAMORTIZATION\t\nCapital expenditures\tFQ, FH, FY, TTM\tCAPITAL_EXPENDITURES\t\nCapital expenditures - fixed assets\tFQ, FH, FY, TTM\tCAPITAL_EXPENDITURES_FIXED_ASSETS\t\nCapital expenditures - other assets\tFQ, FH, FY, TTM\tCAPITAL_EXPENDITURES_OTHER_ASSETS\t\nCash from financing activities\tFQ, FH, FY, TTM\tCASH_F_FINANCING_ACTIVITIES\t\nCash from investing activities\tFQ, FH, FY, TTM\tCASH_F_INVESTING_ACTIVITIES\t\nCash from operating activities\tFQ, FH, FY, TTM\tCASH_F_OPERATING_ACTIVITIES\t\nChange in accounts payable\tFQ, FH, FY, TTM\tCHANGE_IN_ACCOUNTS_PAYABLE\t\nChange in accounts receivable\tFQ, FH, FY, TTM\tCHANGE_IN_ACCOUNTS_RECEIVABLE\t\nChange in accrued expenses\tFQ, FH, FY, TTM\tCHANGE_IN_ACCRUED_EXPENSES\t\nChange in inventories\tFQ, FH, FY, TTM\tCHANGE_IN_INVENTORIES\t\nChange in other assets/liabilities\tFQ, FH, FY, TTM\tCHANGE_IN_OTHER_ASSETS\t\nChange in taxes payable\tFQ, FH, FY, TTM\tCHANGE_IN_TAXES_PAYABLE\t\nChanges in working capital\tFQ, FH, FY, TTM\tCHANGES_IN_WORKING_CAPITAL\t\nCommon dividends paid\tFQ, FH, FY, TTM\tCOMMON_DIVIDENDS_CASH_FLOW\t\nDeferred taxes (cash flow)\tFQ, FH, FY, TTM\tCASH_FLOW_DEFERRED_TAXES\t\nDepreciation & amortization (cash flow)\tFQ, FH, FY, TTM\tCASH_FLOW_DEPRECATION_N_AMORTIZATION\t\nDepreciation/depletion\tFQ, FH, FY, TTM\tDEPRECIATION_DEPLETION\t\nFinancing activities - other sources\tFQ, FH, FY, TTM\tOTHER_FINANCING_CASH_FLOW_SOURCES\t\nFinancing activities - other uses\tFQ, FH, FY, TTM\tOTHER_FINANCING_CASH_FLOW_USES\t\nFree cash flow\tFQ, FH, FY, TTM\tFREE_CASH_FLOW\t\nFunds from operations\tFQ, FH, FY, TTM\tFUNDS_F_OPERATIONS\t\nInvesting activities - other sources\tFQ, FH, FY, TTM\tOTHER_INVESTING_CASH_FLOW_SOURCES\t\nInvesting activities - other uses\tFQ, FH, FY\tOTHER_INVESTING_CASH_FLOW_USES\t\nIssuance of long term debt\tFQ, FH, FY, TTM\tSUPPLYING_OF_LONG_TERM_DEBT\t\nIssuance/retirement of debt, net\tFQ, FH, FY, TTM\tISSUANCE_OF_DEBT_NET\t\nIssuance/retirement of long term debt\tFQ, FH, FY, TTM\tISSUANCE_OF_LONG_TERM_DEBT\t\nIssuance/retirement of other debt\tFQ, FH, FY, TTM\tISSUANCE_OF_OTHER_DEBT\t\nIssuance/retirement of short term debt\tFQ, FH, FY, TTM\tISSUANCE_OF_SHORT_TERM_DEBT\t\nIssuance/retirement of stock, net\tFQ, FH, FY, TTM\tISSUANCE_OF_STOCK_NET\t\nNet income (cash flow)\tFQ, FH, FY, TTM\tNET_INCOME_STARTING_LINE\t\nNon-cash items\tFQ, FH, FY, TTM\tNON_CASH_ITEMS\t\nOther financing cash flow items, total\tFQ, FH, FY, TTM\tOTHER_FINANCING_CASH_FLOW_ITEMS_TOTAL\t\nOther investing cash flow items, total\tFQ, FH, FY\tOTHER_INVESTING_CASH_FLOW_ITEMS_TOTAL\t\nPreferred dividends paid\tFQ, FH, FY\tPREFERRED_DIVIDENDS_CASH_FLOW\t\nPurchase of investments\tFQ, FH, FY, TTM\tPURCHASE_OF_INVESTMENTS\t\nPurchase/acquisition of business\tFQ, FH, FY, TTM\tPURCHASE_OF_BUSINESS\t\nPurchase/sale of business, net\tFQ, FH, FY\tPURCHASE_SALE_BUSINESS\t\nPurchase/sale of investments, net\tFQ, FH, FY, TTM\tPURCHASE_SALE_INVESTMENTS\t\nReduction of long term debt\tFQ, FH, FY, TTM\tREDUCTION_OF_LONG_TERM_DEBT\t\nRepurchase of common & preferred stock\tFQ, FH, FY, TTM\tPURCHASE_OF_STOCK\t\nSale of common & preferred stock\tFQ, FH, FY, TTM\tSALE_OF_STOCK\t\nSale of fixed assets & businesses\tFQ, FH, FY, TTM\tSALES_OF_BUSINESS\t\nSale/maturity of investments\tFQ, FH, FY\tSALES_OF_INVESTMENTS\t\nTotal cash dividends paid\tFQ, FH, FY, TTM\tTOTAL_CASH_DIVIDENDS_PAID\t\nStatistics¶\nThis table contains a variety of statistical metrics, including commonly used financial ratios.\nClick to show/hide\nFinancial period financial_id \nAccruals\tFQ, FH, FY\tACCRUALS_RATIO\t\nAltman Z-score\tFQ, FH, FY\tALTMAN_Z_SCORE\t\nAsset turnover\tFQ, FH, FY\tASSET_TURNOVER\t\nBeneish M-score\tFQ, FH, FY\tBENEISH_M_SCORE\t\nBuyback yield %\tFQ, FH, FY\tBUYBACK_YIELD\t\nCOGS to revenue ratio\tFQ, FH, FY\tCOGS_TO_REVENUE\t\nCash conversion cycle\tFQ, FY\tCASH_CONVERSION_CYCLE\t\nCash to debt ratio\tFQ, FH, FY\tCASH_TO_DEBT\t\nCurrent ratio\tFQ, FH, FY\tCURRENT_RATIO\t\nDays inventory\tFQ, FY\tDAYS_INVENT\t\nDays payable\tFQ, FY\tDAYS_PAY\t\nDays sales outstanding\tFQ, FY\tDAY_SALES_OUT\t\nDebt to EBITDA ratio\tFQ, FH, FY\tDEBT_TO_EBITDA\t\nDebt to assets ratio\tFQ, FH, FY\tDEBT_TO_ASSET\t\nDebt to equity ratio\tFQ, FH, FY\tDEBT_TO_EQUITY\t\nDebt to revenue ratio\tFQ, FH, FY\tDEBT_TO_REVENUE\t\nDividend payout ratio %\tFQ, FH, FY, TTM\tDIVIDEND_PAYOUT_RATIO\t\nDividend yield %\tFQ, FH, FY\tDIVIDENDS_YIELD\t\nDividends per share - common stock primary issue\tFQ, FH, FY, TTM\tDPS_COMMON_STOCK_PRIM_ISSUE\t\nEBITDA margin %\tFQ, FH, FY, TTM\tEBITDA_MARGIN\t\nEPS basic one year growth\tFQ, FH, FY, TTM\tEARNINGS_PER_SHARE_BASIC_ONE_YEAR_GROWTH\t\nEPS diluted one year growth\tFQ, FH, FY\tEARNINGS_PER_SHARE_DILUTED_ONE_YEAR_GROWTH\t\nEPS estimates\tFQ, FH, FY\tEARNINGS_ESTIMATE\t\nEffective interest rate on debt %\tFQ, FH, FY\tEFFECTIVE_INTEREST_RATE_ON_DEBT\t\nEnterprise value\tFQ, FH, FY\tENTERPRISE_VALUE\t\nEnterprise value to EBIT ratio\tFQ, FH, FY\tEV_EBIT\t\nEnterprise value to EBITDA ratio\tFQ, FH, FY\tENTERPRISE_VALUE_EBITDA\t\nEnterprise value to revenue ratio\tFQ, FH, FY\tEV_REVENUE\t\nEquity to assets ratio\tFQ, FH, FY\tEQUITY_TO_ASSET\t\nFloat shares outstanding\tFY\tFLOAT_SHARES_OUTSTANDING\t\nFree cash flow margin %\tFQ, FH, FY\tFREE_CASH_FLOW_MARGIN\t\nFulmer H factor\tFQ, FY\tFULMER_H_FACTOR\t\nGoodwill to assets ratio\tFQ, FH, FY\tGOODWILL_TO_ASSET\t\nGraham’s number\tFQ, FY\tGRAHAM_NUMBERS\t\nGross margin %\tFQ, FH, FY, TTM\tGROSS_MARGIN\t\nGross profit to assets ratio\tFQ, FY\tGROSS_PROFIT_TO_ASSET\t\nInterest coverage\tFQ, FH, FY\tINTERST_COVER\t\nInventory to revenue ratio\tFQ, FH, FY\tINVENT_TO_REVENUE\t\nInventory turnover\tFQ, FH, FY\tINVENT_TURNOVER\t\nKZ index\tFY\tKZ_INDEX\t\nLong term debt to total assets ratio\tFQ, FH, FY\tLONG_TERM_DEBT_TO_ASSETS\t\nNet current asset value per share\tFQ, FY\tNCAVPS_RATIO\t\nNet income per employee\tFY\tNET_INCOME_PER_EMPLOYEE\t\nNet margin %\tFQ, FH, FY, TTM\tNET_MARGIN\t\nNumber of employees\tFY\tNUMBER_OF_EMPLOYEES\t\nOperating earnings yield %\tFQ, FH, FY\tOPERATING_EARNINGS_YIELD\t\nOperating margin %\tFQ, FH, FY\tOPERATING_MARGIN\t\nPEG ratio\tFQ, FY\tPEG_RATIO\t\nPiotroski F-score\tFQ, FH, FY\tPIOTROSKI_F_SCORE\t\nPrice earnings ratio forward\tFQ, FY\tPRICE_EARNINGS_FORWARD\t\nPrice sales ratio forward\tFQ, FY\tPRICE_SALES_FORWARD\t\nQuality ratio\tFQ, FH, FY\tQUALITY_RATIO\t\nQuick ratio\tFQ, FH, FY\tQUICK_RATIO\t\nResearch & development to revenue ratio\tFQ, FH, FY\tRESEARCH_AND_DEVELOP_TO_REVENUE\t\nReturn on assets %\tFQ, FH, FY\tRETURN_ON_ASSETS\t\nReturn on common equity %\tFQ, FH, FY\tRETURN_ON_COMMON_EQUITY\t\nReturn on equity %\tFQ, FH, FY\tRETURN_ON_EQUITY\t\nReturn on equity adjusted to book value %\tFQ, FH, FY\tRETURN_ON_EQUITY_ADJUST_TO_BOOK\t\nReturn on invested capital %\tFQ, FH, FY\tRETURN_ON_INVESTED_CAPITAL\t\nReturn on tangible assets %\tFQ, FH, FY\tRETURN_ON_TANG_ASSETS\t\nReturn on tangible equity %\tFQ, FH, FY\tRETURN_ON_TANG_EQUITY\t\nRevenue estimates\tFQ, FH, FY\tSALES_ESTIMATES\t\nRevenue one year growth\tFQ, FH, FY, TTM\tREVENUE_ONE_YEAR_GROWTH\t\nRevenue per employee\tFY\tREVENUE_PER_EMPLOYEE\t\nShares buyback ratio %\tFQ, FH, FY\tSHARE_BUYBACK_RATIO\t\nSloan ratio %\tFQ, FH, FY\tSLOAN_RATIO\t\nSpringate score\tFQ, FY\tSPRINGATE_SCORE\t\nSustainable growth rate\tFQ, FY\tSUSTAINABLE_GROWTH_RATE\t\nTangible common equity ratio\tFQ, FH, FY\tTANGIBLE_COMMON_EQUITY_RATIO\t\nTobin’s Q (approximate)\tFQ, FH, FY\tTOBIN_Q_RATIO\t\nTotal common shares outstanding\tFQ, FH, FY\tTOTAL_SHARES_OUTSTANDING\t\nZmijewski score\tFQ, FY\tZMIJEWSKI_SCORE\t\n`request.economic()`¶\nThe request.economic() function provides scripts with the ability to retrieve economic data for a specified country or region, including information about the state of the economy (GDP, inflation rate, etc.) or of a particular industry (steel production, ICU beds, etc.).\nBelow is the signature for this function:\nrequest.economic(country_code, field, gaps, ignore_invalid_symbol) → series float\nThe country_code parameter accepts a “simple string” representing the identifier of the country or region to request economic data for (e.g., “US”, “EU”, etc.). See the Country/region codes section for a complete list of codes this function supports. Note that the economic metrics available depend on the country or region specified in the function call.\nThe field parameter specifies the metric the function will request. The Field codes section covers all accessible metrics and the countries/regions they’re available for.\nFor a detailed explanation on the last two parameters of this function, see the Common characteristics section at the top of this page.\nThis simple example requests the growth rate of the Gross Domestic Product (“GDPQQ”) for the United States (“US”) using request.economic(), then plots its value on the chart with a gradient color:\nindicator(\"Requesting economic data demo\")\n//@variable The GDP growth rate for the US economy.\nfloat gdpqq = request.economic(\"US\", \"GDPQQ\")\n//@variable The all-time maximum growth rate.\nfloat maxRate = ta.max(gdpqq)\n//@variable The all-time minimum growth rate.\nfloat minRate = ta.min(gdpqq)\n//@variable The color of the `gdpqq` plot.\ncolor rateColor = switch\ngdpqq >= 0 => color.from_gradient(gdpqq, 0, maxRate, color.purple, color.blue)\n=> color.from_gradient(gdpqq, minRate, 0, color.red, color.purple)\n// Plot the results.\nplot(gdpqq, \"US GDP Growth Rate\", rateColor, style = plot.style_area)\nThis example does not include a gaps argument in the request.economic() call, so the function uses the default barmerge.gaps_off. In other words, it returns the last retrieved value when new data isn’t yet available.\nThe tables in the sections below are rather large, as there are numerous country_code and field arguments available. Use the “Click to show/hide” option above each table to toggle its visibility.\nCountry/region codes¶\nThe table in this section lists all country/region codes available for use with request.economic(). The first column of the table contains the “string” values that represent the country or region code, and the second column contains the corresponding country/region names.\nIt’s important to note that the value used as the country_code argument determines which field codes are accessible to the function.\ncountry_code Country/region name \nAF\tAfghanistan\t\nAL\tAlbania\t\nDZ\tAlgeria\t\nAD\tAndorra\t\nAO\tAngola\t\nAG\tAntigua and Barbuda\t\nAR\tArgentina\t\nAM\tArmenia\t\nAW\tAruba\t\nAU\tAustralia\t\nAT\tAustria\t\nAZ\tAzerbaijan\t\nBS\tBahamas\t\nBH\tBahrain\t\nBD\tBangladesh\t\nBB\tBarbados\t\nBY\tBelarus\t\nBE\tBelgium\t\nBZ\tBelize\t\nBJ\tBenin\t\nBM\tBermuda\t\nBT\tBhutan\t\nBO\tBolivia\t\nBA\tBosnia and Herzegovina\t\nBW\tBotswana\t\nBR\tBrazil\t\nBN\tBrunei\t\nBG\tBulgaria\t\nBF\tBurkina Faso\t\nBI\tBurundi\t\nKH\tCambodia\t\nCM\tCameroon\t\nCA\tCanada\t\nCV\tCape Verde\t\nKY\tCayman Islands\t\nCF\tCentral African Republic\t\nTD\tChad\t\nCL\tChile\t\nCN\tChina\t\nCO\tColombia\t\nKM\tComoros\t\nCG\tCongo\t\nCR\tCosta Rica\t\nHR\tCroatia\t\nCU\tCuba\t\nCY\tCyprus\t\nCZ\tCzech Republic\t\nDK\tDenmark\t\nDJ\tDjibouti\t\nDM\tDominica\t\nDO\tDominican Republic\t\nTL\tEast Timor\t\nEC\tEcuador\t\nEG\tEgypt\t\nSV\tEl Salvador\t\nGQ\tEquatorial Guinea\t\nER\tEritrea\t\nEE\tEstonia\t\nET\tEthiopia\t\nEU\tEuro area\t\nFO\tFaroe Islands\t\nFJ\tFiji\t\nFI\tFinland\t\nFR\tFrance\t\nGA\tGabon\t\nGM\tGambia\t\nGE\tGeorgia\t\nDE\tGermany\t\nGH\tGhana\t\nGR\tGreece\t\nGL\tGreenland\t\nGD\tGrenada\t\nGT\tGuatemala\t\nGN\tGuinea\t\nGW\tGuinea Bissau\t\nGY\tGuyana\t\nHT\tHaiti\t\nHN\tHonduras\t\nHK\tHong Kong\t\nHU\tHungary\t\nIS\tIceland\t\nIN\tIndia\t\nID\tIndonesia\t\nIR\tIran\t\nIQ\tIraq\t\nIE\tIreland\t\nIM\tIsle of Man\t\nIL\tIsrael\t\nIT\tItaly\t\nCI\tIvory Coast\t\nJM\tJamaica\t\nJP\tJapan\t\nJO\tJordan\t\nKZ\tKazakhstan\t\nKE\tKenya\t\nKI\tKiribati\t\nXK\tKosovo\t\nKW\tKuwait\t\nKG\tKyrgyzstan\t\nLA\tLaos\t\nLV\tLatvia\t\nLB\tLebanon\t\nLS\tLesotho\t\nLR\tLiberia\t\nLY\tLibya\t\nLI\tLiechtenstein\t\nLT\tLithuania\t\nLU\tLuxembourg\t\nMO\tMacau\t\nMK\tMacedonia\t\nMG\tMadagascar\t\nMW\tMalawi\t\nMY\tMalaysia\t\nMV\tMaldives\t\nML\tMali\t\nMT\tMalta\t\nMR\tMauritania\t\nMU\tMauritius\t\nMX\tMexico\t\nMD\tMoldova\t\nMC\tMonaco\t\nMN\tMongolia\t\nME\tMontenegro\t\nMA\tMorocco\t\nMZ\tMozambique\t\nMM\tMyanmar\t\nNA\tNamibia\t\nNP\tNepal\t\nNL\tNetherlands\t\nNC\tNew Caledonia\t\nNZ\tNew Zealand\t\nNI\tNicaragua\t\nNE\tNiger\t\nNG\tNigeria\t\nKP\tNorth Korea\t\nNO\tNorway\t\nOM\tOman\t\nPK\tPakistan\t\nPS\tPalestine\t\nPA\tPanama\t\nPG\tPapua New Guinea\t\nPY\tParaguay\t\nPE\tPeru\t\nPH\tPhilippines\t\nPL\tPoland\t\nPT\tPortugal\t\nPR\tPuerto Rico\t\nQA\tQatar\t\nCD\tRepublic of the Congo\t\nRO\tRomania\t\nRU\tRussia\t\nRW\tRwanda\t\nWS\tSamoa\t\nSM\tSan Marino\t\nST\tSao Tome and Principe\t\nSA\tSaudi Arabia\t\nSN\tSenegal\t\nRS\tSerbia\t\nSC\tSeychelles\t\nSL\tSierra Leone\t\nSG\tSingapore\t\nSK\tSlovakia\t\nSI\tSlovenia\t\nSB\tSolomon Islands\t\nSO\tSomalia\t\nZA\tSouth Africa\t\nKR\tSouth Korea\t\nSS\tSouth Sudan\t\nES\tSpain\t\nLK\tSri Lanka\t\nLC\tSt Lucia\t\nVC\tSt Vincent and the Grenadines\t\nSD\tSudan\t\nSR\tSuriname\t\nSZ\tSwaziland\t\nSE\tSweden\t\nCH\tSwitzerland\t\nSY\tSyria\t\nTW\tTaiwan\t\nTJ\tTajikistan\t\nTZ\tTanzania\t\nTH\tThailand\t\nTG\tTogo\t\nTO\tTonga\t\nTT\tTrinidad and Tobago\t\nTN\tTunisia\t\nTR\tTurkey\t\nTM\tTurkmenistan\t\nUG\tUganda\t\nUA\tUkraine\t\nAE\tUnited Arab Emirates\t\nGB\tUnited Kingdom\t\nUS\tUnited States\t\nUY\tUruguay\t\nUZ\tUzbekistan\t\nVU\tVanuatu\t\nVE\tVenezuela\t\nVN\tVietnam\t\nYE\tYemen\t\nZM\tZambia\t\nZW\tZimbabwe\t\nField codes¶\nThe table in this section lists the field codes available for use with request.economic(). The first column contains the “string” values used as the field argument, and the second column contains names of each metric and links to our Help Center with additional information, including the countries/regions they’re available for.\nfield Metric \nAA\tAsylum Applications\t\nACR\tAPI Crude Runs\t\nAE\tAuto Exports\t\nAHE\tAverage Hourly Earnings\t\nAHO\tAPI Heating Oil\t\nAWH\tAverage Weekly Hours\t\nBBS\tBanks Balance Sheet\t\nBCLI\tBusiness Climate Indicator\t\nBCOI\tBusiness Confidence Index\t\nBI\tBusiness Inventories\t\nBLR\tBank Lending Rate\t\nBOI\tNFIB Business Optimism Index\t\nBOT\tBalance Of Trade\t\nBP\tBuilding Permits\t\nBR\tBankruptcies\t\nCA\tCurrent Account\t\nCAG\tCurrent Account To GDP\t\nCAP\tCar Production\t\nCAR\tCar Registrations\t\nCBBS\tCentral Bank Balance Sheet\t\nCCC\tClaimant Count Change\t\nCCI\tConsumer Confidence Index\t\nCCOS\tCushing Crude Oil Stocks\t\nCCP\tCore Consumer Prices\t\nCCPI\tCore CPI\t\nCCPT\tConsumer Confidence Price Trends\t\nCCR\tConsumer Credit\t\nCCS\tCredit Card Spending\t\nCEP\tCement Production\t\nCF\tCapital Flows\t\nCFNAI\tChicago Fed National Activity Index\t\nCI\tAPI Crude Imports\t\nCIND\tCoincident Index\t\nCIR\tCore Inflation Rate, YoY\t\nCJC\tContinuing Jobless Claims\t\nCN\tAPI Cushing Number\t\nCOI\tCrude Oil Imports\t\nCOIR\tCrude Oil Imports from Russia\t\nCONSTS\tConstruction Spending\t\nCOP\tCrude Oil Production\t\nCOR\tCrude Oil Rigs\t\nCORD\tConstruction Orders, YoY\t\nCORPI\tCorruption Index\t\nCORR\tCorruption Rank\t\nCOSC\tCrude Oil Stocks Change\t\nCOUT\tConstruction Output, YoY\t\nCP\tCopper Production\t\nCPCEPI\tCore PCE Price Index\t\nCPI\tConsumer Price Index\t\nCPIHU\tCPI Housing Utilities\t\nCPIM\tCPI Median\t\nCPIT\tCPI Transportation\t\nCPITM\tCPI Trimmed Mean\t\nCPMI\tChicago PMI\t\nCPPI\tCore Producer Price Index\t\nCPR\tCorporate Profits\t\nCRLPI\tCereals Price Index\t\nCRR\tCash Reserve Ratio\t\nCS\tConsumer Spending\t\nCSC\tAPI Crude Oil Stock Change\t\nCSHPI\tCase Shiller Home Price Index\t\nCSHPIMM\tCase Shiller Home Price Index, MoM\t\nCSHPIYY\tCase Shiller Home Price Index, YoY\t\nCSS\tChain Store Sales\t\nCTR\tCorporate Tax Rate\t\nCU\tCapacity Utilization\t\nDFMI\tDallas Fed Manufacturing Index\t\nDFP\tDistillate Fuel Production\t\nDFS\tDistillate Stocks\t\nDFSI\tDallas Fed Services Index\t\nDFSRI\tDallas Fed Services Revenues Index\t\nDG\tDeposit Growth\t\nDGO\tDurable Goods Orders\t\nDGOED\tDurable Goods Orders Excluding Defense\t\nDGOET\tDurable Goods Orders Excluding Transportation\t\nDIR\tDeposit Interest Rate\t\nDPI\tDisposable Personal Income\t\nDRPI\tDairy Price Index\t\nDS\tAPI Distillate Stocks\t\nDT\tCBI Distributive Trades\t\nEC\tADP Employment Change\t\nED\tExternal Debt\t\nEDBR\tEase Of Doing Business Ranking\t\nEHS\tExisting Home Sales\t\nELP\tElectricity Production\t\nEMC\tEmployment Change\t\nEMCI\tEmployment Cost Index\t\nEMP\tEmployed Persons\t\nEMR\tEmployment Rate\t\nEOI\tEconomic Optimism Index\t\nEP\tExport Prices\t\nESI\tZEW Economic Sentiment Index\t\nEWS\tEconomy Watchers Survey\t\nEXP\tExports\t\nEXPYY\tExports, YoY\t\nFAI\tFixed Asset Investment\t\nFBI\tForeign Bond Investment\t\nFDI\tForeign Direct Investment\t\nFE\tFiscal Expenditure\t\nFER\tForeign Exchange Reserves\t\nFI\tFood Inflation, YoY\t\nFO\tFactory Orders\t\nFOET\tFactory Orders Excluding Transportation\t\nFPI\tFood Price Index\t\nFSI\tForeign Stock Investment\t\nFTE\tFull Time Employment\t\nFYGDPG\tFull Year GDP Growth\t\nGASP\tGasoline Prices\t\nGBP\tGovernment Budget\t\nGBV\tGovernment Budget Value\t\nGCI\tCompetitiveness Index\t\nGCR\tCompetitiveness Rank\t\nGD\tGovernment Debt\t\nGDG\tGovernment Debt To GDP\t\nGDP\tGross Domestic Product\t\nGDPA\tGDP From Agriculture\t\nGDPC\tGDP From Construction\t\nGDPCP\tGDP Constant Prices\t\nGDPD\tGDP Deflator\t\nGDPGA\tGDP Growth Annualized\t\nGDPMAN\tGDP From Manufacturing\t\nGDPMIN\tGDP From Mining\t\nGDPPA\tGDP From Public Administration\t\nGDPPC\tGDP Per Capita\t\nGDPPCP\tGDP Per Capita, PPP\t\nGDPQQ\tGDP Growth Rate\t\nGDPS\tGDP From Services\t\nGDPSA\tGDP Sales\t\nGDPT\tGDP From Transport\t\nGDPU\tGDP From Utilities\t\nGDPYY\tGDP, YoY\t\nGDTPI\tGlobal Dairy Trade Price Index\t\nGFCF\tGross Fixed Capital Formation\t\nGNP\tGross National Product\t\nGP\tGold Production\t\nGPA\tGovernment Payrolls\t\nGPRO\tGasoline Production\t\nGR\tGovernment Revenues\t\nGRES\tGold Reserves\t\nGS\tAPI Gasoline Stocks\t\nGSC\tGrain Stocks Corn\t\nGSCH\tGasoline Stocks Change\t\nGSG\tGovernment Spending To GDP\t\nGSP\tGovernment Spending\t\nGSS\tGrain Stocks Soy\t\nGSW\tGrain Stocks Wheat\t\nGTB\tGoods Trade Balance\t\nHB\tHospital Beds\t\nHDG\tHouseholds Debt To GDP\t\nHDI\tHouseholds Debt To Income\t\nHICP\tHarmonised Index of Consumer Prices\t\nHIRMM\tHarmonised Inflation Rate, MoM\t\nHIRYY\tHarmonised Inflation Rate, YoY\t\nHMI\tNAHB Housing Market Index\t\nHOR\tHome Ownership Rate\t\nHOS\tHeating Oil Stocks\t\nHOSP\tHospitals\t\nHPI\tHouse Price Index\t\nHPIMM\tHouse Price Index, MoM\t\nHPIYY\tHouse Price Index, YoY\t\nHS\tHome Loans\t\nHSP\tHousehold Spending\t\nHST\tHousing Starts\t\nIC\tChanges In Inventories\t\nICUB\tICU Beds\t\nIE\tInflation Expectations\t\nIFOCC\tIFO Assessment Of The Business Situation\t\nIFOE\tIFO Business Developments Expectations\t\nIJC\tInitial Jobless Claims\t\nIMP\tImports\t\nIMPYY\tImports, YoY\t\nINBR\tInterbank Rate\t\nINTR\tInterest Rate\t\nIPA\tIP Addresses\t\nIPMM\tIndustrial Production, MoM\t\nIPRI\tImport Prices\t\nIPYY\tIndustrial Production, YoY\t\nIRMM\tInflation Rate, MoM\t\nIRYY\tInflation Rate, YoY\t\nIS\tIndustrial Sentiment\t\nISP\tInternet Speed\t\nJA\tJob Advertisements\t\nJAR\tJobs To Applications Ratio\t\nJC\tChallenger Job Cuts\t\nJC4W\tJobless Claims, 4-Week Average\t\nJO\tJob Offers\t\nJV\tJob Vacancies\t\nKFMI\tKansas Fed Manufacturing Index\t\nLB\tLoans To Banks\t\nLC\tLabor Costs\t\nLEI\tLeading Economic Index\t\nLFPR\tLabor Force Participation Rate\t\nLG\tLoan Growth, YoY\t\nLIVRR\tLiquidity Injections Via Reverse Repo\t\nLMIC\tLMI Logistics Managers Index Current\t\nLMICI\tLMI Inventory Costs\t\nLMIF\tLMI Logistics Managers Index Future\t\nLMITP\tLMI Transportation Prices\t\nLMIWP\tLMI Warehouse Prices\t\nLPS\tLoans To Private Sector\t\nLR\tCentral Bank Lending Rate\t\nLTUR\tLong Term Unemployment Rate\t\nLWF\tLiving Wage Family\t\nLWI\tLiving Wage Individual\t\nM0\tMoney Supply M0\t\nM1\tMoney Supply M1\t\nM2\tMoney Supply M2\t\nM3\tMoney Supply M3\t\nMA\tMortgage Approvals\t\nMAPL\tMortgage Applications\t\nMCE\tMichigan Consumer Expectations\t\nMCEC\tMichigan Current Economic Conditions\t\nMD\tMedical Doctors\t\nME\tMilitary Expenditure\t\nMGDPYY\tMonthly GDP, YoY\t\nMIE1Y\tMichigan Inflation Expectations\t\nMIE5Y\tMichigan 5 Year Inflation Expectations\t\nMIP\tMining Production, YoY\t\nMMI\tMBA Mortgage Market Index\t\nMO\tMachinery Orders\t\nMP\tManufacturing Payrolls\t\nMPI\tMeat Price Index\t\nMPRMM\tManufacturing Production, MoM\t\nMPRYY\tManufacturing Production, YoY\t\nMR\tMortgage Rate\t\nMRI\tMBA Mortgage Refinance Index\t\nMS\tManufacturing Sales\t\nMTO\tMachine Tool Orders\t\nMW\tMinimum Wages\t\nNDCGOEA\tOrders For Non-defense Capital Goods Excluding Aircraft\t\nNEGTB\tGoods Trade Deficit With Non-EU Countries\t\nNFP\tNonfarm Payrolls\t\nNGI\tNatural Gas Imports\t\nNGIR\tNatural Gas Imports from Russia\t\nNGSC\tNatural Gas Stocks Change\t\nNHPI\tNationwide House Price Index\t\nNHS\tNew Home Sales\t\nNHSMM\tNew Home Sales, MoM\t\nNMPMI\tNon-Manufacturing PMI\t\nNO\tNew Orders\t\nNODXMM\tNon-Oil Domestic Exports, MoM\t\nNODXYY\tNon-Oil Domestic Exports, YoY\t\nNOE\tNon-Oil Exports\t\nNPP\tNonfarm Payrolls Private\t\nNURS\tNurses\t\nNYESMI\tNY Empire State Manufacturing Index\t\nOE\tOil Exports\t\nOPI\tOils Price Index\t\nPCEPI\tPCE Price Index\t\nPDG\tPrivate Debt To GDP\t\nPFMI\tPhiladelphia Fed Manufacturing Index\t\nPHSIMM\tPending Home Sales Index, MoM\t\nPHSIYY\tPending Home Sales Index, YoY\t\nPI\tPersonal Income\t\nPIN\tPrivate Investment\t\nPIND\tMBA Purchase Index\t\nPITR\tPersonal Income Tax Rate\t\nPOP\tPopulation\t\nPPI\tProducer Price Index\t\nPPII\tProducer Price Index Input\t\nPPIMM\tProducer Price Inflation, MoM\t\nPPIYY\tProducer Prices Index, YoY\t\nPRI\tAPI Product Imports\t\nPROD\tProductivity\t\nPS\tPersonal Savings\t\nPSC\tPrivate Sector Credit\t\nPSP\tPersonal Spending\t\nPTE\tPart Time Employment\t\nPUAC\tPandemic Unemployment Assistance Claims\t\nRAM\tRetirement Age Men\t\nRAW\tRetirement Age Women\t\nRCR\tRefinery Crude Runs\t\nREM\tRemittances\t\nRFMI\tRichmond Fed Manufacturing Index\t\nRFMSI\tRichmond Fed Manufacturing Shipments Index\t\nRFSI\tRichmond Fed Services Index\t\nRI\tRedbook Index\t\nRIEA\tRetail Inventories Excluding Autos\t\nRPI\tRetail Price Index\t\nRR\tRepo Rate\t\nRRR\tReverse Repo Rate\t\nRSEA\tRetail Sales Excluding Autos\t\nRSEF\tRetail Sales Excluding Fuel\t\nRSMM\tRetail Sales, MoM\t\nRSYY\tRetail Sales, YoY\t\nRTI\tReuters Tankan Index\t\nSBSI\tSmall Business Sentiment Index\t\nSFHP\tSingle Family Home Prices\t\nSP\tSteel Production\t\nSPI\tSugar Price Index\t\nSS\tServices Sentiment\t\nSSR\tSocial Security Rate\t\nSSRC\tSocial Security Rate For Companies\t\nSSRE\tSocial Security Rate For Employees\t\nSTR\tSales Tax Rate\t\nTA\tTourist Arrivals\t\nTAXR\tTax Revenue\t\nTCB\tTreasury Cash Balance\t\nTCPI\tTokyo CPI\t\nTI\tTerrorism Index\t\nTII\tTertiary Industry Index\t\nTOT\tTerms Of Trade\t\nTR\tTourism Revenues\t\nTVS\tTotal Vehicle Sales\t\nUC\tUnemployment Change\t\nUP\tUnemployed Persons\t\nUR\tUnemployment Rate\t\nWAG\tWages\t\nWES\tWeapons Sales\t\nWG\tWage Growth, YoY\t\nWHS\tWages High Skilled\t\nWI\tWholesale Inventories\t\nWLS\tWages Low Skilled\t\nWM\tWages In Manufacturing\t\nWPI\tWholesale Price Index\t\nWS\tWholesale Sales\t\nYUR\tYouth Unemployment Rate\t\nZCC\tZEW Current Conditions\t\n`request.seed()`¶\nTradingView aggregates a vast amount of data from its many providers, including price and volume information on tradable instruments, financials, economic data, and more, which users can retrieve in Pine Script™ using the functions discussed in the sections above, as well as multiple built-in variables.\nTo further expand the horizons of possible data one can analyze on TradingView, we have Pine Seeds, which allows users to supply custom user-maintained EOD data feeds via GitHub for use on TradingView charts and within Pine Script™ code.\nThis section contains only a brief overview of Pine Seeds. For in-depth information about Pine Seeds functionality, setting up a repo, data formats, and more, consult the documentation here.\nTo retrieve data from a Pine Seeds data feed within a script, one can use the request.seed() function.\nBelow is the function’s signature:\nrequest.seed(source, symbol, expression, ignore_invalid_symbol) → series <type>\nThe source parameter specifies the unique name of the user-maintained GitHub repository that contains the data feed. For details on creating a repo, see this page.\nThe symbol parameter represents the file name from the “data/” directory of the source repository, excluding the “.csv” file extension. See this page for information about the structure of the data stored in repositories.\nThe expression parameter is the series to evaluate using data extracted from the requested context. It is similar to the equivalent in request.security() and request.security_lower_tf(). Data feeds stored in user-maintained repos contain time, open, high, low, close, and volume information, meaning expressions used as the expression argument can use the corresponding built-in variables, including variables derived from them (e.g., bar_index, ohlc4, etc.) to request their values from the context of the custom data.\nThe script below visualizes sample data from the seed_crypto_santiment demo repo. It uses two calls to request.seed() to retrieve the close values from the repo’s BTC_SENTIMENT_POSITIVE_TOTAL and BTC_SENTIMENT_NEGATIVE_TOTAL data feeds and plots the results on the chart as step lines:\nindicator(\"Pine Seeds demo\", format=format.volume)\n//@variable The total positive sentiment for BTC extracted from the \"seed_crypto_santiment\" repository.\nfloat positiveTotal = request.seed(\"seed_crypto_santiment\", \"BTC_SENTIMENT_POSITIVE_TOTAL\", close)\n//@variable The total negative sentiment for BTC extracted from the \"seed_crypto_santiment\" repository.\nfloat negativeTotal = request.seed(\"seed_crypto_santiment\", \"BTC_SENTIMENT_NEGATIVE_TOTAL\", close)\n// Plot the data.\nplot(positiveTotal, \"Positive sentiment\", color.teal, 2, plot.style_stepline)\nplot(negativeTotal, \"Negative sentiment\", color.maroon, 2, plot.style_stepline)\nThis example requests data from the repo highlighted in the Pine Seeds documentation. It exists solely for example purposes, and its data does not update on a regular basis.\nUnlike most other request.*() functions, request.seed() does not have a gaps parameter. It will always return na values when no new data exists.\nPine Seeds data is searchable from the chart’s symbol search bar. To load a data feed on the chart, enter the “Repo:File” pair, similar to searching for an “Exchange:Symbol” pair."
},
{
  "text": "Plots¶\n`plot()` parameters\nPlotting conditionally\nValue control\nColor control\nLevels\nOffsets\nPlot count limit\nScale\nMerging two indicators\nThe plot() function is the most frequently used function used to display information calculated using Pine scripts. It is versatile and can plot different styles of lines, histograms, areas, columns (like volume columns), fills, circles or crosses.\nThe use of plot() to create fills is explained in the page on Fills.\nThis script showcases a few different uses of plot() in an overlay script:\nindicator(\"`plot()`\", \"\", true)\nplot(high, \"Blue `high` line\")\nplot(math.avg(close, open), \"Crosses in body center\", close > open ? color.lime : color.purple, 6, plot.style_cross)\nplot(math.min(open, close), \"Navy step line on body low point\", color.navy, 3, plot.style_stepline)\nplot(low, \"Gray dot on `low`\", color.gray, 3, plot.style_circles)\ncolor VIOLET = #AA00FF\ncolor GOLD = #CCCC00\nma = ta.alma(hl2, 40, 0.85, 6)\nvar almaColor = color.silver\nalmaColor := ma > ma[2] ? GOLD : ma < ma[2] ? VIOLET : almaColor\nplot(ma, \"Two-color ALMA\", almaColor, 2)\nThe first plot() call plots a 1-pixel blue line across the bar highs.\nThe second plots crosses at the mid-point of bodies. The crosses are colored lime when the bar is up and purple when it is down. The argument used for linewidth is 6 but it is not a pixel value; just a relative size.\nThe third call plots a 3-pixel wide step line following the low point of bodies.\nThe fourth call plot a gray circle at the bars’ low.\nThe last plot requires some preparation. We first define our bull/bear colors, calculate an Arnaud Legoux Moving Average, then make our color calculations. We initialize our color variable on bar zero only, using var. We initialize it to color.silver, so on the dataset’s first bars, until one of our conditions causes the color to change, the line will be silver. The conditions that change the color of the line require it to be higher/lower than its value two bars ago. This makes for less noisy color transitions than if we merely looked for a higher/lower value than the previous one.\nThis script shows other uses of plot() in a pane:\nindicator(\"Volume change\", format = format.volume)\ncolor GREEN = #008000\ncolor GREEN_LIGHT = color.new(GREEN, 50)\ncolor GREEN_LIGHTER = color.new(GREEN, 85)\ncolor PINK = #FF0080\ncolor PINK_LIGHT = color.new(PINK, 50)\ncolor PINK_LIGHTER = color.new(PINK, 90)\nbool barUp = ta.rising(close, 1)\nbool barDn = ta.falling(close, 1)\nfloat volumeChange = ta.change(volume)\nvolumeColor = barUp ? GREEN_LIGHTER : barDn ? PINK_LIGHTER : color.gray\nplot(volume, \"Volume columns\", volumeColor, style = plot.style_columns)\nvolumeChangeColor = barUp ? volumeChange > 0 ? GREEN : GREEN_LIGHT : volumeChange > 0 ? PINK : PINK_LIGHT\nplot(volumeChange, \"Volume change columns\", volumeChangeColor, 12, plot.style_histogram)\nplot(0, \"Zero line\", color.gray)\nWe are plotting normal volume values as wide columns above the zero line (see the style = plot.style_columns in our plot() call).\nBefore plotting the columns we calculate our volumeColor by using the values of the barUp and barDn boolean variables. They become respectively true when the current bar’s close is higher/lower than the previous one. Note that the “Volume” built-in does not use the same condition; it identifies an up bar with close > open. We use the GREEN_LIGHTER and PINK_LIGHTER colors for the volume columns.\nBecause the first plot plots columns, we do not use the linewidth parameter, as it has no effect on columns.\nOur script’s second plot is the change in volume, which we have calculated earlier using ta.change(volume). This value is plotted as a histogram, for which the linewidth parameter controls the width of the column. We make this width 12 so that histogram elements are thinner than the columns of the first plot. Positive/negative volumeChange values plot above/below the zero line; no manipulation is required to achieve this effect.\nBefore plotting the histogram of volumeChange values, we calculate its color value, which can be one of four different colors. We use the bright GREEN or PINK colors when the bar is up/down AND the volume has increased since the last bar (volumeChange > 0). Because volumeChange is positive in this case, the histogram’s element will be plotted above the zero line. We use the bright GREEN_LIGHT or PINK_LIGHT colors when the bar is up/down AND the volume has NOT increased since the last bar. Because volumeChange is negative in this case, the histogram’s element will be plotted below the zero line.\nFinally, we plot a zero line. We could just as well have used hline(0) there.\nWe use format = format.volume in our indicator() call so that large values displayed for this script are abbreviated like those of the built-in “Volume” indicator.\nplot() calls must always be placed in a line’s first position, which entails they are always in the script’s global scope. They can’t be placed in user-defined functions or structures like if, for, etc. Calls to plot() can, however, be designed to plot conditionally in two ways, which we cover in the Conditional plots section of this page.\nA script can only plot in its own visual space, whether it is in a pane or on the chart as an overlay. Scripts running in a pane can only color bars in the chart area.\n`plot()` parameters¶\nThe plot() function has the following signature:\nplot(series, title, color, linewidth, style, trackprice, histbase, offset, join, editable, show_last, display) → plot\nThe parameters of plot() are:\nseries It is the only mandatory parameter. Its argument must be of “series int/float” type. Note that because the auto-casting rules in Pine Script™ convert in the int 🠆 float 🠆 bool direction, a “bool” type variable cannot be used as is; it must be converted to an “int” or a “float” for use as an argument. For example, if newDay is of “bool” type, then newDay ? 1 : 0 can be used to plot 1 when the variable is true, and zero when it is false. title \nRequires a “const string” argument, so it must be known at compile time. The string appears:\nIn the script’s scale when the “Chart settings/Scales/Indicator Name Label” field is checked.\nIn the Data Window.\nIn the “Settings/Style” tab.\nIn the dropdown of input.source() fields.\nIn the “Condition” field of the “Create Alert” dialog box, when the script is selected.\nAs the column header when exporting chart data to a CSV file.\ncolor Accepts “series color”, so can be calculated on the fly, bar by bar. Plotting with na as the color, or any color with a transparency of 100, is one way to hide plots when they are not needed. linewidth Is the plotted element’s size, but it does not apply to all styles. When a line is plotted, the unit is pixels. It has no impact when plot.style_columns is used. style \nThe available arguments are:\nplot.style_line (the default): It plots a continous line using the linewidth argument in pixels for its width. na values will not plot as a line, but they will be bridged when a value that is not na comes in. Non-na values are only bridged if they are visible on the chart.\nplot.style_linebr: Allows the plotting of discontinuous lines by not plotting on na values, and not joining gaps, i.e., bridging over na values.\nplot.style_stepline: Plots using a staircase effect. Transitions between changes in values are done using a vertical line drawn in middle of bars, as opposed to a point-to-point diagonal joining the midpoints of bars. Can also be used to achieve an effect similar to that of plot.style_linebr, but only if care is taken to plot no color on na values.\nplot.style_area: plots a line of linewidth width, filling the area between the line and the histbase. The color argument is used for both the line and the fill. You can make the line a different color by using another plot() call. Positive values are plotted above the histbase, negative values below it.\nplot.style_areabr: This is similar to plot.style_area but it doesn’t bridge over na values. Another difference is how the indicator’s scale is calculated. Only the plotted values serve in the calculation of the y range of the script’s visual space. If only high values situated far away from the histbase are plotted, for example, those values will be used to calculate the y scale of the script’s visual space. Positive values are plotted above the histbase, negative values below it.\nplot.style_columns: Plots columns similar to those of the “Volume” built-in indicator. The linewidth value does not affect the width of the columns. Positive values are plotted above the histbase, negative values below it. Always includes the value of histbase in the y scale of the script’s visual space.\nplot.style_histogram: Plots columns similar to those of the “Volume” built-in indicator, except that the linewidth value is used to determine the width of the histogram’s bars in pixels. Note that since linewidth requires an “input int” value, the width of the histogram’s bars cannot vary bar to bar. Positive values are plotted above the histbase, negative values below it. Always includes the value of histbase in the y scale of the script’s visual space.\nplot.style_circles and plot.style_cross: These plot a shape that is not joined across bars unless join = true is also used. For these styles, the linewidth argument becomes a relative sizing measure — its units are not pixels.\ntrackprice The default value of this is false. When it is true, a dotted line made up of small squares will be plotted the full width of the script’s visual space. It is often used in conjuction with show_last = 1, offset = -99999 to hide the actual plot and only leave the residual dotted line. histbase It is the reference point used with plot.style_area, plot.style_columns and plot.style_histogram. It determines the level separating positive and negative values of the series argument. It cannot be calculated dynamically, as an “input int/float” is required. offset This allows shifting the plot in the past/future using a negative/positive offset in bars. The value cannot change during the script’s execution. join This only affect styles plot.style_circles or plot.style_cross. When true, the shapes are joined by a one-pixel line. editable This boolean parameter controls whether or not the plot’s properties can be edited in the “Settings/Style” tab. Its default value is true. show_last Allows control over how many of the last bars the plotted values are visible. An “input int” argument is required, so it cannot be calculated dynamically. display The default is display.all. When it is set to display.none, plotted values will not affect the scale of the script’s visual space. The plot will be invisible and will not appear in indicator values or the Data Window. It can be useful in plots destined for use as external inputs for other scripts, or for plots used with the {{plot(\"[plot_title]\")}} placeholder in alertcondition() calls, e.g.: \nindicator(\"\")\nr = ta.rsi(close, 14)\nxUp = ta.crossover(r, 50)\nplot(r, \"RSI\", display = display.none)\nalertcondition(xUp, \"xUp alert\", message = 'RSI is bullish at: {{plot(\"RSI\")}}')\nPlotting conditionally¶\nplot() calls cannot be used in conditional structures such as if, but they can be controlled by varying their plotted values, or their color. When no plot is required, you can either plot na values, or plot values using na color or any color with 100 transparency (which also makes it invisible).\nValue control¶\nOne way to control the display of plots is to plot na values when no plot is needed. Sometimes, values returned by functions such as request.security() will return na values, when gaps = barmerge.gaps_on is used, for example. In both these cases it is sometimes useful to plot discontinuous lines. This script shows a few ways to do it:\nindicator(\"Discontinuous plots\", \"\", true)\nbool plotValues = bar_index % 3 == 0\nplot(plotValues ? high : na, color = color.fuchsia, linewidth = 6, style = plot.style_linebr)\nplot(plotValues ? high : na)\nplot(plotValues ? math.max(open, close) : na, color = color.navy, linewidth = 6, style = plot.style_cross)\nplot(plotValues ? math.min(open, close) : na, color = color.navy, linewidth = 6, style = plot.style_circles)\nplot(plotValues ? low : na, color = plotValues ? color.green : na, linewidth = 6, style = plot.style_stepline)\nWe define the condition determining when we plot using bar_index % 3 == 0, which becomes true when the remainder of the division of the bar index by 3 is zero. This will happen every three bars.\nIn the first plot, we use plot.style_linebr, which plots the fuchsia line on highs. It is centered on the bar’s horizontal midpoint.\nThe second plot shows the result of plotting the same values, but without using special care to break the line. What’s happening here is that the thin blue line of the plain plot() call is automatically bridged over na values (or gaps), so the plot does not interrupt.\nWe then plot navy blue crosses and circles on the body tops and bottoms. The plot.style_circles and plot.style_cross style are a simple way to plot discontinuous values, e.g., for stop or take profit levels, or support & resistance levels.\nThe last plot in green on the bar lows is done using plot.style_stepline. Note how its segments are wider than the fuchsia line segments plotted with plot.style_linebr. Also note how on the last bar, it only plots halfway until the next bar comes in.\nThe plotting order of each plot is controlled by their order of appearance in the script. See\nThis script shows how you can restrict plotting to bars after a user-defined date. We use the input.time() function to create an input widget allowing script users to select a date and time, using Jan 1st 2021 as its default value:\nstartInput = input.time(timestamp(\"2021-01-01\"))\nplot(time > startInput ? close : na)\nColor control¶\nThe Conditional coloring section of the page on colors discusses color control for plots. We’ll look here at a few examples.\nThe value of the color parameter in plot() can be a constant, such as one of the built-in constant colors or a color literal. In Pine Script™, the qualified type of such colors is called “const color” (see the Type system page). They are known at compile time:\nplot(close, color = color.gray)\nThe color of a plot can also be determined using information that is only known when the script begins execution on the first historical bar of a chart (bar zero, i.e., bar_index == 0 or barstate.isfirst == true), as will be the case when the information needed to determine a color depends on the chart the script is running on. Here, we calculate a plot color using the syminfo.type built-in variable, which returns the type of the chart’s symbol. The qualified type of plotColor in this case will be “simple color”:\nplotColor = switch syminfo.type\n\"stock\" => color.purple\n\"futures\" => color.red\n\"index\" => color.gray\n\"forex\" => color.fuchsia\n\"crypto\" => color.lime\n\"fund\" => color.orange\n\"dr\" => color.aqua\n\"cfd\" => color.blue\nplot(close, color = plotColor)\nprintTable(txt) => var table t = table.new(position.middle_right, 1, 1), table.cell(t, 0, 0, txt, bgcolor = color.yellow)\nprintTable(syminfo.type)\nPlot colors can also be chosen through a script’s inputs. In this case, the lineColorInput variable is of the “input color” type:\ncolor lineColorInput = input(#1848CC, \"Line color\")\nplot(close, color = lineColorInput)\nFinally, plot colors can also be dynamic values, i.e., calculated values that can change on each bar. These values are of the “series color” type:\nplotColor = close >= open ? color.lime : color.red\nplot(close, color = plotColor)\nWhen plotting pivot levels, one common requirement is to avoid plotting level transitions. Using lines is one alternative, but you can also use plot() like this:\nindicator(\"Pivot plots\", \"\", true)\npivotHigh = fixnan(ta.pivothigh(3,3))\nplot(pivotHigh, \"High pivot\", ta.change(pivotHigh) ? na : color.olive, 3)\nplotchar(ta.change(pivotHigh), \"ta.change(pivotHigh)\", \"•\", location.top, size = size.small)\nWe use pivotHigh = fixnan(ta.pivothigh(3,3)) to hold our pivot values. Because ta.pivothigh() only returns a value when a new pivot is found, we use fixnan() to fill the gaps with the last pivot value returned. The gaps here refer to the na values ta.pivothigh() returns when no new pivot is found.\nOur pivots are detected three bars after they occur because we use the argument 3 for both the leftbars and rightbars parameters in our ta.pivothigh() call.\nThe last plot is plotting a continuous value, but it is setting the plot’s color to na when the pivot’s value changes, so the plot isn’t visible then. Because of this, a visible plot will only appear on the bar following the one where we plotted using na color.\nThe blue dot indicates when a new high pivot is detected and no plot is drawn between the preceding bar and that one. Note how the pivot on the bar indicated by the arrow has just been detected in the realtime bar, three bars later, and how no plot is drawn. The plot will only appear on the next bar, making the plot visible four bars after the actual pivot.\nLevels¶\nPine Script™ has an hline() function to plot horizontal lines (see the page on Levels). hline() is useful because it has some line styles unavailable with plot(), but it also has some limitations, namely that it does not accept “series color”, and that its price parameter requires an “input int/float”, so cannot vary during the script’s execution.\nYou can plot levels with plot() in a few different ways. This shows a CCI indicator with levels plotted using plot():\nindicator(\"CCI levels with `plot()`\")\nplot(ta.cci(close, 20))\nplot(0, \"Zero\", color.gray, 1, plot.style_circles)\nplot(bar_index % 2 == 0 ? 100 : na, \"100\", color.lime, 1, plot.style_linebr)\nplot(bar_index % 2 == 0 ? -100 : na, \"-100\", color.fuchsia, 1, plot.style_linebr)\nplot( 200, \"200\", color.green, 2, trackprice = true, show_last = 1, offset = -99999)\nplot(-200, \"-200\", color.red, 2, trackprice = true, show_last = 1, offset = -99999)\nplot( 300, \"300\", color.new(color.green, 50), 1)\nplot(-300, \"-300\", color.new(color.red, 50), 1)\nThe zero level is plotted using plot.style_circles.\nThe 100 levels are plotted using a conditional value that only plots every second bar. In order to prevent the na values from being bridged, we use the plot.style_linebr line style.\nThe 200 levels are plotted using trackprice = true to plot a distinct pattern of small squares that extends the full width of the script’s visual space. The show_last = 1 in there displays only the last plotted value, which would appear as a one-bar straight line if the next trick wasn’t also used: the offset = -99999 pushes that one-bar segment far away in the past so that it is never visible.\nThe 300 levels are plotted using a continuous line, but a lighter transparency is used to make them less prominent.\nOffsets¶\nThe offset parameter specifies the shift used when the line is plotted (negative values shift in the past, positive values shift into the future). For example:\nplot(close, color = color.red, offset = -5)\nplot(close, color = color.lime, offset = 5)\nAs can be seen in the screenshot, the red series has been shifted to the left (since the argument’s value is negative), while the green series has been shifted to the right (its value is positive).\nPlot count limit¶\nEach script is limited to a maximum plot count of 64. All plot*() calls and alertcondition() calls count in the plot count of a script. Some types of calls count for more than one in the total plot count.\nplot() calls count for one in the total plot count if they use a “const color” argument for the color parameter, which means it is known at compile time, e.g.:\nplot(close, color = color.green)\nWhen they use another qualified type, such as any one of these, they will count for two in the total plot count:\nplot(close, color = syminfo.mintick > 0.0001 ? color.green : color.red) //🠆 \"simple color\"\nplot(close, color = input.color(color.purple)) //🠆 \"input color\"\nplot(close, color = close > open ? color.green : color.red) //🠆 \"series color\"\nplot(close, color = color.new(color.silver, close > open ? 40 : 0)) //🠆 \"series color\"\nScale¶\nNot all values can be plotted everywhere. Your script’s visual space is always bound by upper and lower limits that are dynamically adjusted with the values plotted. An RSI indicator will plot values between 0 and 100, which is why it is usually displayed in a distinct pane — or area — above or below the chart. If RSI values were plotted as an overlay on the chart, the effect would be to distort the symbol’s normal price scale, unless it just hapenned to be close to RSI’s 0 to 100 range. This shows an RSI signal line and a centerline at the 50 level, with the script running in a separate pane:\nindicator(\"RSI\")\nmyRSI = ta.rsi(close, 20)\nbullColor = color.from_gradient(myRSI, 50, 80, color.new(color.lime, 70), color.new(color.lime, 0))\nbearColor = color.from_gradient(myRSI, 20, 50, color.new(color.red, 0), color.new(color.red, 70))\nmyRSIColor = myRSI > 50 ? bullColor : bearColor\nplot(myRSI, \"RSI\", myRSIColor, 3)\nhline(50)\nNote that the y axis of our script’s visual space is automatically sized using the range of values plotted, i.e., the values of RSI. See the page on Colors for more information on the color.from_gradient() function used in the script.\nIf we try to plot the symbol’s close values in the same space by adding the following line to our script:\nThis is what happens:\nThe chart is on the BTCUSD symbol, whose close prices are around 40000 during this period. Plotting values in the 40000 range makes our RSI plots in the 0 to 100 range indiscernible. The same distorted plots would occur if we placed the RSI indicator on the chart as an overlay.\nMerging two indicators¶\nIf you are planning to merge two signals in one script, first consider the scale of each. It is impossible, for example, to correctly plot an RSI and a MACD in the same script’s visual space because RSI has a fixed range (0 to 100) while MACD doesn’t, as it plots moving averages calculated on price._\nIf both your indicators used fixed ranges, you can shift the values of one of them so they do not overlap. We could, for example, plot both RSI (0 to 100) and the True Strength Indicator (TSI) (-100 to +100) by displacing one of them. Our strategy here will be to compress and shift the TSI values so they plot over RSI:\nindicator(\"RSI and TSI\")\nmyRSI = ta.rsi(close, 20)\nbullColor = color.from_gradient(myRSI, 50, 80, color.new(color.lime, 70), color.new(color.lime, 0))\nbearColor = color.from_gradient(myRSI, 20, 50, color.new(color.red, 0), color.new(color.red, 70))\nmyRSIColor = myRSI > 50 ? bullColor : bearColor\nplot(myRSI, \"RSI\", myRSIColor, 3)\nhline(100)\nhline(50)\nhline(0)\n// 1. Compress TSI's range from -100/100 to -50/50.\n// 2. Shift it higher by 150, so its -50 min value becomes 100.\nmyTSI = 150 + (100 * ta.tsi(close, 13, 25) / 2)\nplot(myTSI, \"TSI\", color.blue, 2)\nplot(ta.ema(myTSI, 13), \"TSI EMA\", #FF006E)\nhline(200)\nhline(150)\nWe have added levels using hline to situate both signals.\nIn order for both signal lines to oscillate on the same range of 100, we divide the TSI value by 2 because it has a 200 range (-100 to +100). We then shift this value up by 150 so it oscillates between 100 and 200, making 150 its centerline.\nThe manipulations we make here are typical of the compromises required to bring two indicators with different scales in the same visual space, even when their values, contrary to MACD, are bounded in a fixed range."
},
{
  "text": "We define repainting as: script behavior causing historical vs realtime calculations or plots to behave differently.\nRepainting behavior is widespread and many factors can cause it. Following our definition, our estimate is that more than 95% of indicators in existence exhibit some form of repainting behavior. Commony used indicators such as MACD and RSI, for example, show confirmed values on historical bars, but will fluctuate on a realtime, unconfirmed chart bar until it closes. Therefore, they behave differently in historical and realtime states.\nNot all repainting behavior is inherently useless or misleading, nor does such behavior prevent knowledgeable traders from using indicators with such behavior. For example, who would think of discrediting a volume profile indicator solely because it updates its values on realtime bars?\nOne may encounter any of the following forms of repainting in the scripts they use, depending on what a script’s calculations entail:\nWidespread but often acceptable: A script may use values that update with realtime price changes on the unconfirmed bar. For example, if one uses the close variable in calculations performed on an open chart bar, its values will reflect the most recent price in the bar. However, the script will only commit a new data point to its historical series once the bar closes. Another common case is using request.security() to fetch higher-timeframe data on realtime bars, as explained in the Historical and realtime behavior section of the Other timeframes and data page. As with the unconfirmed chart bar in the chart’s timeframe, request.security() can track unconfirmed values from a higher-timeframe context on realtime bars, which can lead to repainting after the script restarts its execution. There is often nothing wrong with using such scripts, provided you understand how they work. When electing to use such scripts to issue alerts or trade orders, however, it’s important to understand the difference between their realtime and historical behavior and decide for yourself whether it provides utility for your needs.\nPotentially misleading: Scripts that plot values into the past, calculate results on realtime bars that one cannot replicate on historical bars, or relocate past events are potentially misleading. For example, Ichimoku, most scripts based on pivots, most strategies using calc_on_every_tick = true, scripts using request.security() when it behaves differently on realtime bars, many scripts using varip, many scripts using timenow, and some scripts that use barstate.* variables can exhibit misleading repainting behavior.\nUnacceptable: Scripts that leak future information into the past, strategies that execute on non-standard charts, and scripts using realtime intrabars to generate alerts or orders, are examples that can produce heavily misleading repainting behavior.\nUnavoidable: Revisions of the data feed from a provider and variations in the starting bar of the chart’s history can cause repainting behavior that may be unavoidable in a script.\nThe first two types of repainting can be perfectly acceptable if:\nYou are aware of the behavior.\nYou can live with it, or\nYou can circumvent it.\nIt should now be clear that not all repainting behavior is wrong and requires avoiding at all costs. In many situations, some forms of repainting may be exactly what a script needs. What’s important is to know when repainting behavior is not acceptable for one’s needs. To avoid repainting that’s not acceptable, it’s important to understand how a tool works or how you should design the tools you build. If you publish scripts, ensure you mention any potentially misleading behavior along with the other limitations of your script in the publication’s description.\nFor script users¶\nOne can decide to use repainting indicators if they understand the behavior, and whether that behavior meets their analysis requirements. Don’t be one of those newcomers who slap “repaint” sentences on published scripts in an attempt to discredit them, as doing so reveals a lack of foundational knowledge on the subject.\nSimply asking whether a script repaints is relatively meaningless, given that there are forms of repainting behavior that are perfectly acceptable in a script. Therefore, such a question will not beget a meaningful answer. One should instead ask specific questions about a script’s potential repainting behavior, such as:\nDoes the script calculate/display in the same way on historical and realtime bars?\nDo alerts from the script wait for the end of a realtime bar before triggering?\nDo signal markers shown by the script wait for the end of a realtime bar before showing?\nDoes the script plot/draw values into the past?\nDoes the strategy use calc_on_every_tick = true?\nDo the script’s request.security() calls leak future information into the past on historical bars?\nWhat’s important is that you understand how the tools you use work, and whether their behavior is compatible with your objectives, repainting or not. As you will learn if you read this page, repainting is a complex matter. It has many faces and many causes. Even if you don’t program in Pine Script™, this page will help you understand the array of causes that can lead to repainting, and hopefully enable more meaningful discussions with script authors.\nFor Pine Script™ programmers¶\nAs discussed above, not all forms of repainting behavior must be avoided at all costs, nor is all potential repainting behavior necessarily avoidable. We hope this page helps you better understand the dynamics at play so that you can design your trading tools with these behaviors in mind. This page’s content should help make you aware of common coding mistakes that produce misleading repainting results.\nWhatever your design decisions are, if you publish your script, explain the script to traders so they can understand how it behaves.\nThis page covers three broad categories of repainting causes:\nHistorical vs realtime calculations\nPlotting in the past\nDataset variations\nHistorical vs realtime calculations¶\nFluid data values¶\nHistorical data does not include records of intermediary price movements on bars; only open, high, low and close values (OHLC).\nOn realtime bars (bars running when the instrument’s market is open), however, the high, low and close values are not fixed; they can change values many times before the realtime bar closes and its HLC values are fixed. They are fluid. This leads to a script sometimes working differently on historical data and in real time, where only the open price will not change during the bar.\nAny script using values like high, low and close in realtime is subject to producing calculations that may not be repeatable on historical bars — thus repaint.\nLet’s look at this simple script. It detects crosses of the close value (in the realtime bar, this corresponds to the current price of the instrument) over and under an EMA:\nindicator(\"Repainting\", \"\", true)\nma = ta.ema(close, 5)\nxUp = ta.crossover(close, ma)\nxDn = ta.crossunder(close, ma)\nplot(ma, \"MA\", color.black, 2)\nbgcolor(xUp ? color.new(color.lime, 80) : xDn ? color.new(color.fuchsia, 80) : na)\nThe script uses bgcolor() to color the background green when close crosses over the EMA, and red on crosses under the EMA.\nThe screen snapshot shows the script in realtime on a 30sec chart. A cross over the EMA has been detected, thus the background of the realtime bar is green.\nThe problem here is that nothing guarantees this condition will hold true until the end of the realtime bar. The arrow points to the timer showing that 21 seconds remain in the realtime bar, and anything could happen until then.\nWe are witnessing a repainting script.\nTo prevent this repainting, we must rewrite our script so that it does not use values that fluctuate during the realtime bar. This will require using values from a bar that has elapsed (typically the preceding bar), or the open price, which does not vary in realtime.\nWe can achieve this in many ways. This method adds a and barstate.isconfirmed condition to our cross detections, which requires the script to be executing on the bar’s last iteration, when it closes and prices are confirmed. It is a simple way to avoid repainting:\nindicator(\"Repainting\", \"\", true)\nma = ta.ema(close, 5)\nxUp = ta.crossover(close, ma) and barstate.isconfirmed\nxDn = ta.crossunder(close, ma) and barstate.isconfirmed\nplot(ma, \"MA\", color.black, 2)\nbgcolor(xUp ? color.new(color.lime, 80) : xDn ? color.new(color.fuchsia, 80) : na)\nThis uses the crosses detected on the previous bar:\nindicator(\"Repainting\", \"\", true)\nma = ta.ema(close, 5)\nxUp = ta.crossover(close, ma)[1]\nxDn = ta.crossunder(close, ma)[1]\nplot(ma, \"MA\", color.black, 2)\nbgcolor(xUp ? color.new(color.lime, 80) : xDn ? color.new(color.fuchsia, 80) : na)\nThis uses only confirmed close and EMA values for its calculations:\nindicator(\"Repainting\", \"\", true)\nma = ta.ema(close[1], 5)\nxUp = ta.crossover(close[1], ma)\nxDn = ta.crossunder(close[1], ma)\nplot(ma, \"MA\", color.black, 2)\nbgcolor(xUp ? color.new(color.lime, 80) : xDn ? color.new(color.fuchsia, 80) : na)\nThis detects crosses between the realtime bar’s open and the value of the EMA from the previous bars. Notice that the EMA is calculated using close, so it repaints. We must ensure we use a confirmed value to detect crosses, thus ma[1] in the cross detection logic:\nma = ta.ema(close, 5)\nxUp = ta.crossover(open, ma[1])\nxDn = ta.crossunder(open, ma[1])\nAll these methods have one thing in common: while they prevent repainting, they will also trigger signals later than repainting scripts. This is an inevitable compromise if one wants to avoid repainting. You can’t have your cake and eat it too.\nRepainting `request.security()` calls¶\nThe request.security() function behaves differently on historical and realtime bars. On historical bars, it only returns confirmed values from its requested context, wheras it can return unconfirmed values on realtime bars. When the script restarts its execution, the bars that had a realtime state become historical bars, and will therefore only contain the values it confirmed on those bars. If the values returned by request.security() fluctuate on realtime bars without confirmation from the context, the script will repaint them when it restarts its execution. See the Historical and realtime behavior section of the Other timeframes and data page for a detailed explanation.\nOne can ensure higher-timeframe data requests only return confirmed values on all bars, regardless of bar state, by offsetting the expression argument by at least one bar with the history-referencing operator [] and using barmerge.lookahead_on for the lookahead argument in the request.security() call, as explained here.\nThe script below demonstrates the difference between repainting and non-repainting HTF data requests. It contains two request.security() calls. The first function call requests close data from the higherTimeframe without additional specification, and the second call requests the same series with an offset and barmerge.lookahead_on.\nAs we see on all realtime bars (the ones with an orange background), the repaintingClose contains values that fluctuate without confirmation from the higherTimeframe, meaning it will repaint when the script restarts its execution. The nonRepaintingClose, on the other hand, behaves the same on realtime and historical bars, i.e., it only changes its value when new, confirmed data is available:\nindicator(\"Repainting vs non-repainting `request.security()` demo\", overlay = true)\n//@variable The timeframe to request data from.\nstring higherTimeframe = input.timeframe(\"30\", \"Timeframe\")\nif timeframe.in_seconds() > timeframe.in_seconds(higherTimeframe)\nruntime.error(\"The 'Timeframe' input is smaller than the chart's timeframe. Choose a higher timeframe.\")\n//@variable The current `close` requested from the `higherTimeframe`. Fluctuates without confirmation on realtime bars.\nfloat repaintingClose = request.security(syminfo.tickerid, higherTimeframe, close)\n//@variable The last confirmed `close` requested from the `higherTimeframe`.\n// Behaves the same on historical and realtime bars.\nfloat nonRepaintingClose = request.security(\nsyminfo.tickerid, higherTimeframe, close[1], lookahead = barmerge.lookahead_on\n// Plot the values.\nplot(repaintingClose, \"Repainting close\", color.new(color.purple, 50), 8)\nplot(nonRepaintingClose, \"Non-repainting close\", color.teal, 3)\n// Plot a shape when a new `higherTimeframe` starts.\nplotshape(timeframe.change(higherTimeframe), \"Timeframe change marker\", shape.square, location.top, size = size.small)\n// Color the background on realtime bars.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 60) : na, title = \"Realtime bar highlight\")\nWe used the plotshape() function to mark the chart when there’s a change on the higherTimeframe.\nThis script produces a runtime error if the higherTimeframe is lower than the chart’s timeframe.\nOn historical bars, the repaintingClose has a new value at the end of each timeframe, and the nonRepaintingClose has a new value at the start of each timeframe.\nFor the sake of easy reusability, below is a simple a noRepaintSecurity() function that one can apply in their scripts to request non-repainting higher-timeframe values:\n//@function Requests non-repainting `expression` values from the context of the `symbol` and `timeframe`.\nnoRepaintSecurity(symbol, timeframe, expression) =>\nrequest.security(symbol, timeframe, expression[1], lookahead = barmerge.lookahead_on)\nThe [1] offset to the series and the use of lookahead = barmerge.lookahead_on are interdependent. One cannot be removed without compromising the integrity of the function.\nUnlike a plain request.security() call, this wrapper function cannot accept tuple expression arguments. For multi-element use cases, one can pass a user-defined type whose fields contain the desired elements to request.\nUsing `request.security()` at lower timeframes¶\nSome scripts use request.security() to request data from a timeframe lower than the chart’s timeframe. This can be useful when functions specifically designed to handle intrabars at lower timeframes are sent down the timeframe. When this type of user-defined function requires the detection of the intrabars’ first bar, as most do, the technique will only work on historical bars. This is due to the fact that realtime intrabars are not yet sorted. The impact of this is that such scripts cannot reproduce in real time their behavior on historical bars. Any logic generating alerts, for example, will be flawed, and constant refreshing will be required to recalculate elapsed realtime bars as historical bars.\nWhen used at lower timeframes than the chart’s without specialized functions able to distinguish between intrabars, request.security() will only return the value of the last intrabar in the dilation of the chart’s bar, which is usually not useful, and will also not reproduce in real time, so lead to repainting.\nFor all these reasons, unless you understand the subtleties of using request.security() at lower timeframes than the chart’s, it is best to avoid using the function at those timeframes. Higher-quality scripts will have logic to detect such anomalies and prevent the display of results which would be invalid when a lower timeframe is used.\nFor more reliable lower-timeframe data requests, use request.security_lower_tf(), as explained in this section of the Other timeframes and data page.\nFuture leak with `request.security()`¶\nWhen request.security() is used with lookahead = barmerge.lookahead_on to fetch prices without offsetting the series by [1], it will return data from the future on historical bars, which is dangerously misleading.\nWhile historical bars will magically display future prices before they should be known, no lookahead is possible in realtime because the future there is unknown, as it should, so no future bars exist.\nThis is an example:\n// FUTURE LEAK! DO NOT USE!\nindicator(\"Future leak\", \"\", true)\nfutureHigh = request.security(syminfo.tickerid, \"1D\", high, lookahead = barmerge.lookahead_on)\nplot(futureHigh)\nNote how the higher timeframe line is showing the timeframe’s high value before it occurs. The solution to avoid this effect is to use the function as demonstrated in this section.\nUsing lookahead to produce misleading results is not allowed in script publications, as explained in the lookahead section of the Other timeframes and data page. Script publications that use this misleading technique will be moderated.\n`varip`¶\nScripts using the varip declaration mode for variables (see our section on varip for more information) save information across realtime updates, which cannot be reproduced on historical bars where only OHLC information is available. Such scripts may be useful in realtime, including to generate alerts, but their logic cannot be backtested, nor can their plots on historical bars reflect calculations that will be done in realtime.\nBar state built-ins¶\nScripts using bar states may or may not repaint. As we have seen in the previous section, using barstate.isconfirmed is actually one way to avoid repainting that will reproduce on historical bars, which are always “confirmed”. Uses of other bar states such as barstate.isnew, however, will lead to repainting. The reason is that on historical bars, barstate.isnew is true on the bar’s close, yet in realtime, it is true on the bar’s open. Using the other bar state variables will usually cause some type of behavioral discrepancy between historical and realtime bars.\n`timenow`¶\nThe timenow built-in returns the current time. Scripts using this variable cannot show consistent historical and realtime behavior, so they necessarily repaint.\nStrategies¶\nStrategies using calc_on_every_tick = true execute on each realtime update, while strategies run on the close of historical bars. They will most probably not generate the same order executions, and so repaint. Note that when this happens, it also invalidates backtesting results, as they are not representative of the strategy’s behavior in realtime.\nPlotting in the past¶\nScripts detecting pivots after 5 bars have elapsed will often go back in the past to plot pivot levels or values on the actual pivot, 5 bars in the past. This will often cause unsuspecting traders looking at plots on historical bars to infer that when the pivot happens in realtime, the same plots will apppear on the pivot when it occurs, as opposed to when it is detected.\nLet’s look at a script showing the price of high pivots by placing the price in the past, 5 bars after the pivot was detected:\nindicator(\"Plotting in the past\", \"\", true)\npHi = ta.pivothigh(5, 5)\nif not na(pHi)\nlabel.new(bar_index[5], na, str.tostring(pHi, format.mintick) + \"\\n🠇\", yloc = yloc.abovebar, style = label.style_none, textcolor = color.black, size = size.normal)\nThis script repaints because an elapsed realtime bar showing no price may get a price placed on it if it is identified as a pivot, 5 bars after the actual pivot occurs.\nThe display looks great, but it can be misleading.\nThe best solution to this problem when developing script for others is to plot without an offset by default, but give the option for script users to turn on plotting in the past through inputs, so they are necessarily aware of what the script is doing, e.g.:\nindicator(\"Plotting in the past\", \"\", true)\nplotInThePast = input(false, \"Plot in the past\")\npHi = ta.pivothigh(5, 5)\nif not na(pHi)\nlabel.new(bar_index[plotInThePast ? 5 : 0], na, str.tostring(pHi, format.mintick) + \"\\n🠇\", yloc = yloc.abovebar, style = label.style_none, textcolor = color.black, size = size.normal)\nDataset variations¶\nStarting points¶\nScripts begin executing on the chart’s first historical bar, and then execute on each bar sequentially, as is explained in this manual’s page on Pine Script™’s execution model. If the first bar changes, then the script will often not calculate the same way it did when the dataset began at a different point in time.\nThe following factors have an impact on the quantity of bars you see on your charts, and their starting point:\nThe type of account you hold\nThe historical data available from the data supplier\nThe alignment requirements of the dataset, which determine its starting point\nThese are the account-specific bar limits:\n20000 historical bars for the Premium plan.\n10000 historical bars for Pro and Pro+ plans.\n5000 historical bars for other plans.\nStarting points are determined using the following rules, which depend on the chart’s timeframe:\n1, 5, 10, 15, 30 seconds: aligns to the beginning of a day.\n1 - 14 minutes: aligns to the beginning of a week.\n15 - 29 minutes: aligns to the beginning of a month.\n30 - 1439 minutes: aligns to the beginning of a year.\n1440 minutes and higher: aligns to the first available historical data point.\nAs time goes by, these factors cause your chart’s history to start at different points in time. This often has an impact on your scripts calculations, because changes in calculation results in early bars can ripple through all the other bars in the dataset. Using functions like ta.valuewhen(), ta.barssince() or ta.ema(), for example, will yield results that vary with early history.\nRevision of historical data¶\nHistorical and realtime bars are built using two different data feeds supplied by exchanges/brokers: historical data, and realtime data. When realtime bars elapse, exchanges/brokers sometimes make what are usually small adjustments to bar prices, which are then written to their historical data. When the chart is refreshed or the script is re-executed on those elapsed realtime bars, they will then be built and calculated using the historical data, which will contain those usually small price revisions, if any have been made.\nHistorical data may also be revised for other reasons, e.g., for stock splits."
},
{
  "text": "Sessions¶\nSession strings\nSession string specifications\nUsing session strings\nSession states\nUsing sessions with `request.security()`\nSession information is usable in three different ways in Pine Script™:\nSession strings containing from-to start times and day information that can be used in functions such as time() and time_close() to detect when bars are in a particular time period, with the option of limiting valid sessions to specific days. The input.session() function provides a way to allow script users to define session values through a script’s “Inputs” tab (see the Session input section for more information).\nSession states built-in variables such as session.ismarket can identify which session a bar belongs to.\nWhen fetching data with request.security() you can also choose to return data from regular sessions only or extended sessions. In this case, the definition of regular and extended sessions is that of the exchange. It is part of the instrument’s properties — not user-defined, as in point #1. This notion of regular and extended sessions is the same one used in the chart’s interface, in the “Chart Settings/Symbol/Session” field, for example.\nThe following sections cover both methods of using session information in Pine Script™.\nNot all user accounts on TradingView have access to extended session information.\nThere is no special “session” type in Pine Script™. Instead, session strings are of “string” type but must conform to the session string syntax.\nSession strings¶\nSession string specifications¶\nSession strings used with time() and time_close() must have a specific format. Their syntax is:\nWhere:\n<time_period> uses times in “hhmm” format, with “hh” in 24-hour format, so 1700 for 5PM. The time periods are in the “hhmm-hhmm” format, and a comma can separate multiple time periods to specify combinations of discrete periods.\nFor example, - <days> is a set of digits from 1 to 7 that specifies on which days the session is valid. 1 is Sunday, 7 is Saturday. \nThe default days are: 1234567, which is different in Pine Script™ v5 than in earlier versions where 23456 (weekdays) is used. For v5 code to reproduce the behavior from previous versions, it should explicitly mention weekdays, as in \"0930-1700:23456\".\nThese are examples of session strings:\n\"24x7\" A 7-day, 24-hour session beginning at midnight. \"0000-0000:1234567\" Equivalent to the previous example. \"0000-0000\" Equivalent to the previous two examples because the default days are 1234567. \"0000-0000:23456\" The same as the previous example, but only Monday to Friday. \"2000-1630:1234567\" An overnight session that begins at 20:00 and ends at 16:30 the next day. It is valid on all days of the week. \"0930-1700:146\" A session that begins at 9:30 and ends at 17:00 on Sundays (1), Wednesdays (4), and Fridays (6). \"1700-1700:23456\" An overnight session. The Monday session starts Sunday at 17:00 and ends Monday at 17:00. It is valid Monday through Friday. \"1000-1001:26\" A weird session that lasts only one minute on Mondays (2) and Fridays (6). \"0900-1600,1700-2000\" A session that begins at 9:00, breaks from 16:00 to 17:00, and continues until 20:00. Applies to every day of the week. \nUsing session strings¶\nSession properties defined with session strings are independent of the exchange-defined sessions determining when an instrument can be traded. Programmers have complete liberty in creating whatever session definitions suit their purpose, which is usually to detect when bars belong to specific time periods. This is accomplished in Pine Script™ by using one of the following two signatures of the time() function:\ntime(timeframe, session, timezone) → series int\ntime(timeframe, session) → series int\nHere, we use time() with a session argument to display the market’s opening high and low values on an intraday chart:\nindicator(\"Opening high/low\", overlay = true)\nsessionInput = input.session(\"0930-0935\")\nsessionBegins(sess) =>\nt = time(\"\", sess)\ntimeframe.isintraday and (not barstate.isfirst) and na(t[1]) and not na(t)\nvar float hi = na\nvar float lo = na\nif sessionBegins(sessionInput)\nhi := high\nlo := low\nplot(lo, \"lo\", color.fuchsia, 2, plot.style_circles)\nplot(hi, \"hi\", color.lime, 2, plot.style_circles)\nWe use a session input to allow users to specify the time they want to detect. We are only looking for the session’s beginning time on bars, so we use a five-minute gap between the beginning and end time of our \"0930-0935\" default value.\nWe create a sessionBegins() function to detect the beginning of a session. Its time(\"\", sess) call uses an empty string for the function’s timeframe parameter, which means it uses the chart’s timeframe, whatever that is. The function returns true when:\nThe chart uses an intraday timeframe (seconds or minutes).\nThe script isn’t on the chart’s first bar, which we ensure with (not barstate.isfirst). This check prevents the code from always detecting a session beginning on the first bar because na(t[1]) and not na(t) is always true there.\nThe time() call has returned na on the previous bar because it wasn’t in the session’s time period, and it has returned a value that is not na on the current bar, which means the bar is in the session’s time period.\nSession states¶\nThree built-in variables allow you to distinguish the type of session the current bar belongs to. They are only helpful on intraday timeframes:\nsession.ismarket returns true when the bar belongs to regular trading hours.\nsession.ispremarket returns true when the bar belongs to the extended session preceding regular trading hours.\nsession.ispostmarket returns true when the bar belongs to the extended session following regular trading hours.\nUsing sessions with `request.security()`¶\nWhen your TradingView account provides access to extended sessions, you can choose to see their bars with the “Settings/Symbol/Session” field. There are two types of sessions:\nregular (which does not include pre- and post-market data), and\nextended (which includes pre- and post-market data).\nScripts using the request.security() function to access data can return extended session data or not. This is an example where only regular session data is fetched:\nindicator(\"Example 1: Regular Session Data\")\nregularSessionData = request.security(\"NASDAQ:AAPL\", timeframe.period, close, barmerge.gaps_on)\nplot(regularSessionData, style = plot.style_linebr)\nIf you want the request.security() call to return extended session data, you must first use the ticker.new() function to build the first argument of the request.security() call:\nindicator(\"Example 2: Extended Session Data\")\nt = ticker.new(\"NASDAQ\", \"AAPL\", session.extended)\nextendedSessionData = request.security(t, timeframe.period, close, barmerge.gaps_on)\nplot(extendedSessionData, style = plot.style_linebr)\nNote that the previous chart’s gaps in the script’s plot are now filled. Also, keep in mind that our example scripts do not produce the background coloring on the chart; it is due to the chart’s settings showing extended hours.\nThe ticker.new() function has the following signature:\nticker.new(prefix, ticker, session, adjustment) → simple string\nWhere:\nprefix is the exchange prefix, e.g., \"NASDAQ\"\nticker is a symbol name, e.g., \"AAPL\"\nsession can be session.extended or session.regular. Note that this is not a session string.\nadjustment adjusts prices using different criteria: adjustment.none, adjustment.splits, adjustment.dividends.\nOur first example could be rewritten as:\nindicator(\"Example 1: Regular Session Data\")\nt = ticker.new(\"NASDAQ\", \"AAPL\", session.regular)\nregularSessionData = request.security(t, timeframe.period, close, barmerge.gaps_on)\nplot(regularSessionData, style = plot.style_linebr)\nIf you want to use the same session specifications used for the chart’s main symbol, omit the third argument in ticker.new(); it is optional. If you want your code to declare your intention explicitly, use the syminfo.session built-in variable. It holds the session type of the chart’s main symbol:\nindicator(\"Example 1: Regular Session Data\")\nt = ticker.new(\"NASDAQ\", \"AAPL\", syminfo.session)\nregularSessionData = request.security(t, timeframe.period, close, barmerge.gaps_on)\nplot(regularSessionData, style = plot.style_linebr)"
},
{
  "text": "Strategies¶\nA simple strategy example\nApplying a strategy to a chart\nStrategy tester\nOverview\nPerformance summary\nList of trades\nProperties\nBroker emulator\nBar magnifier\nOrders and entries\nOrder types\nMarket orders\nLimit orders\nStop and stop-limit orders\nOrder placement commands\n`strategy.entry()`\n`strategy.order()`\n`strategy.exit()`\n`strategy.close()` and `strategy.close_all()`\n`strategy.cancel()` and `strategy.cancel_all()`\nPosition sizing\nClosing a market position\nOCA groups\n`strategy.oca.cancel`\n`strategy.oca.reduce`\n`strategy.oca.none`\nCurrency\nAltering calculation behavior\n`calc_on_every_tick`\n`calc_on_order_fills`\n`process_orders_on_close`\nSimulating trading costs\nCommission\nSlippage and unfilled limits\nRisk management\nMargin\nStrategy Alerts\nNotes on testing strategies\nBacktesting and forward testing\nLookahead bias\nSelection bias\nOverfitting\nPine Script™ strategies simulate the execution of trades on historical and real-time data to facilitate the backtesting and forward testing of trading systems. They include many of the same capabilities as Pine Script™ indicators while providing the ability to place, modify, and cancel hypothetical orders and analyze the results.\nWhen a script uses the strategy() function for its declaration, it gains access to the strategy.* namespace, where it can call functions and variables for simulating orders and accessing essential strategy information. Additionally, the script will display information and simulated results externally in the “Strategy Tester” tab.\nA simple strategy example¶\nThe following script is a simple strategy that simulates the entry of long or short positions upon the crossing of two moving averages:\nstrategy(\"test\", overlay = true)\n// Calculate two moving averages with different lengths.\nfloat fastMA = ta.sma(close, 14)\nfloat slowMA = ta.sma(close, 28)\n// Enter a long position when `fastMA` crosses over `slowMA`.\nif ta.crossover(fastMA, slowMA)\nstrategy.entry(\"buy\", strategy.long)\n// Enter a short position when `fastMA` crosses under `slowMA`.\nif ta.crossunder(fastMA, slowMA)\nstrategy.entry(\"sell\", strategy.short)\n// Plot the moving averages.\nplot(fastMA, \"Fast MA\", color.aqua)\nplot(slowMA, \"Slow MA\", color.orange)\nThe strategy(\"test\" overlay = true) line declares that the script is a strategy named “test” with visual outputs overlaid on the main chart pane.\nstrategy.entry() is the command that the script uses to simulate “buy” and “sell” orders. When the script places an order, it also plots the order id on the chart and an arrow to indicate the direction.\nTwo plot() functions plot the moving averages with two different colors for visual reference.\nApplying a strategy to a chart¶\nTo test a strategy, apply it to the chart. You can use a built-in strategy from the “Indicators & Strategies” dialog box or write your own in the Pine Editor. Click “Add to chart” from the “Pine Editor” tab to apply a script to the chart:\nAfter a strategy script is compiled and applied to a chart, it will plot order marks on the main chart pane and display simulated performance results in the “Strategy Tester” tab below:\nThe results from a strategy applied to non-standard charts (Heikin Ashi, Renko, Line Break, Kagi, Point & Figure, and Range) do not reflect actual market conditions by default. Strategy scripts will use the synthetic price values from these charts during simulation, which often do not align with actual market prices and will thus produce unrealistic backtest results. We therefore highly recommend using standard chart types for backtesting strategies. Alternatively, on Heikin Ashi charts, users can simulate orders using actual prices by enabling the “Fill orders using standard OHLC” option in the Strategy properties.\nStrategy tester¶\nThe Strategy Tester module is available to all scripts declared with the strategy() function. Users can access this module from the “Strategy Tester” tab below their charts, where they can conveniently visualize their strategies and analyze hypothetical performance results.\nOverview¶\nThe Overview tab of the Strategy Tester presents essential performance metrics and equity and drawdown curves over a simulated sequence of trades, providing a quick look at strategy performance without diving into granular detail. The chart in this section shows the strategy’s equity curve as a baseline plot centered at the initial value, the buy and hold equity curve as a line plot, and the drawdown curve as a histogram plot. Users can toggle these plots and scale them as absolute values or percentages using the options below the chart.\nThe overview chart uses two scales; the left is for the equity curves, and the right is for the drawdown curve.\nWhen a user clicks a point on these plots, this will direct the main chart view to the point where the trade was closed.\nPerformance summary¶\nThe Performance Summary tab of the module presents a comprehensive overview of a strategy’s performance metrics. It displays three columns: one for all trades, one for all longs, and one for all shorts, to provide traders with more detailed insights on a strategy’s long, short, and overall simulated trading performance.\nList of trades¶\nThe List of Trades tab provides a granular look at the trades simulated by a strategy with essential information, including the date and time of execution, the type of order used (entry or exit), the number of contracts/shares/lots/units traded, and the price, as well as some key trade performance metrics.\nUsers can navigate the times of specific trades on their charts by clicking on them in this list.\nBy clicking the “Trade #” field above the list, users can organize the trades in ascending order starting from the first or descending order starting from the last.\nProperties¶\nThe Properties tab provides detailed information about a strategy’s configuration and the dataset to which it is applied. It includes the strategy’s date range, symbol information, script settings, and strategy properties.\nDate Range - Includes the range of dates with simulated trades and the total available backtesting range.\nSymbol Info - Contains the symbol name and broker/exchange, the chart’s timeframe and type, the tick size, the point value for the chart, and the base currency.\nStrategy Inputs - Outlines the various parameters and variables used in the strategy script available in the “Inputs” tab of the script settings.\nStrategy Properties - Provides an overview of the configuration of the trading strategy. It includes essential details such as the initial capital, base currency, order size, margin, pyramiding, commission, and slippage. Additionally, this section highlights any modifications made to strategy calculation behavior.\nBroker emulator¶\nTradingView utilizes a broker emulator to simulate the performance of trading strategies. Unlike in real-life trading, the emulator strictly uses available chart prices for order simulation. Consequently, the simulation can only place historical trades after a bar closes, and it can only place real-time trades on a new price tick. For more information on this behavior, please refer to the Pine Script™ Execution model.\nSince the emulator can only use chart data, it makes assumptions about intrabar price movement. It uses a bar’s open, high, and low prices to infer intrabar activity while calculating order fills with the following logic:\nIf the high price is closer to the opening price than the low price, it assumes that the price moved in this order on the bar: open → high → low → close.\nIf the low price is closer to the opening price than the high price, it assumes that the price moved in this order on the bar: open → low → high → close.\nThe broker emulator assumes no gaps exist between prices within bars; in the “eyes” of the emulator, the full range of intrabar prices is available for order execution.\nBar magnifier¶\nPremium account holders can override the broker emulator’s intrabar assumptions via the use_bar_magnifier parameter of the strategy() function or the “Use bar magnifier” input in the “Properties” tab of the script settings. The Bar Magnifier inspects data on timeframes smaller than the chart’s to obtain more granular information about price action within a bar, thus allowing more precise order fills during simulation.\nTo demonstrate, the following script places a “Buy” limit order at the entryPrice and an “Exit” limit order at the exitPrice when the time value crosses the orderTime, and draws two horizontal lines to visualize the order prices. The script also highlights the background using the orderColor to indicate when the strategy placed the orders:\nstrategy(\"Bar Magnifier Demo\", overlay = true, use_bar_magnifier = false)\n//@variable The UNIX timestamp to place the order at.\nint orderTime = timestamp(\"UTC\", 2023, 3, 22, 18)\n//@variable Returns `color.orange` when `time` crosses the `orderTime`, false otherwise.\ncolor orderColor = na\n// Entry and exit prices.\nfloat entryPrice = hl2 - (high - low)\nfloat exitPrice = entryPrice + (high - low) * 0.25\n// Entry and exit lines.\nvar line entryLine = na\nvar line exitLine = na\nif ta.cross(time, orderTime)\n// Draw new entry and exit lines.\nentryLine := line.new(bar_index, entryPrice, bar_index + 1, entryPrice, color = color.green, width = 2)\nexitLine := line.new(bar_index, exitPrice, bar_index + 1, exitPrice, color = color.red, width = 2)\n// Update order highlight color.\norderColor := color.new(color.orange, 80)\n// Place limit orders at the `entryPrice` and `exitPrice`.\nstrategy.entry(\"Buy\", strategy.long, limit = entryPrice)\nstrategy.exit(\"Exit\", \"Buy\", limit = exitPrice)\n// Update lines while the position is open.\nelse if strategy.position_size > 0.0\nentryLine.set_x2(bar_index + 1)\nexitLine.set_x2(bar_index + 1)\nbgcolor(orderColor)\nAs we see in the chart above, the broker emulator assumed that intrabar prices moved from open to high, then high to low, then low to close on the bar the “Buy” order filled on, meaning the emulator assumed that the “Exit” order couldn’t fill on the same bar. However, after including use_bar_magnifier = true in the declaration statement, we see a different story:\nThe maximum amount of intrabars that a script can request is 100,000. Some symbols with lengthier history may not have full intrabar coverage for their beginning chart bars with this limitation, meaning that simulated trades on those bars will not be affected by the bar magnifier.\nOrders and entries¶\nJust like in real-life trading, Pine strategies use orders to manage positions. In this context, an order is a command to simulate a market action, and a trade is the result after the order fills. Thus, to enter or exit positions using Pine, users must create orders with parameters that specify how they’ll behave.\nTo take a closer look at how orders work and how they become trades, let’s write a simple strategy script:\nstrategy(\"My strategy\", overlay = true, margin_long = 100, margin_short = 100)\n//@function Displays text passed to `txt` when called.\ndebugLabel(txt) =>\nlabel.new(\nbar_index, high, text = txt, color=color.lime, style = label.style_label_lower_right,\ntextcolor = color.black, size = size.large\nlongCondition = bar_index % 20 == 0 // true on every 20th bar\nif (longCondition)\ndebugLabel(\"Long entry order created\")\nstrategy.entry(\"My Long Entry Id\", strategy.long)\nstrategy.close_all()\nIn this script, we’ve defined a longCondition that is true whenever the bar_index is divisible by 20, i.e., every 20th bar. The strategy uses this condition within an if structure to simulate an entry order with strategy.entry() and draws a label at the entry price with the user-defined debugLabel() function. The script calls strategy.close_all() from the global scope to simulate a market order that closes any open position. Let’s see what happens once we add the script to our chart:\nThe blue arrows on the chart indicate entry locations, and the purple ones mark the points where the strategy closed positions. Notice that the labels precede the actual entry point rather than occurring on the same bar - this is orders in action. By default, Pine strategies wait for the next available price tick before filling orders, as filling an order on the same tick isn’t realistic. Also, they recalculate on the close of every historical bar, meaning the next available tick to fill an order at is the open of the next bar in this case. As a result, by default, all orders are delayed by one chart bar.\nIt’s important to note that although the script calls strategy.close_all() from the global scope, forcing execution on every bar, the function call does nothing if the strategy isn’t simulating an open position. If there is an open position, the command issues a market order to close it, which executes on the next available tick. For example, when the longCondition is true on bar 20, the strategy places an entry order to fill at the next tick, which is at the open of bar 21. Once the script recalculates its values on that bar’s close, the function places an order to close the position, which fills at the open of bar 22.\nOrder types¶\nPine Script™ strategies allow users to simulate different order types for their particular needs. The main notable types are market, limit, stop, and stop-limit.\nMarket orders¶\nMarket orders are the most basic type of orders. They command a strategy to buy or sell a security as soon as possible, regardless of the price. Consequently, they always execute on the next available price tick. By default, all strategy.*() functions that generate orders specifically produce market orders.\nThe following script simulates a long market order when the bar_index is divisible by 2 * cycleLength. Otherwise, it simulates a short market order when the bar_index is divisible by cycleLength, resulting in a strategy with alternating long and short trades once every cycleLength bars:\nstrategy(\"Market order demo\", overlay = true, margin_long = 100, margin_short = 100)\n//@variable Number of bars between long and short entries.\ncycleLength = input.int(10, \"Cycle length\")\n//@function Displays text passed to `txt` when called.\ndebugLabel(txt, lblColor) => label.new(\nbar_index, high, text = txt, color = lblColor, textcolor = color.white,\nstyle = label.style_label_lower_right, size = size.large\n//@variable Returns `true` every `2 * cycleLength` bars.\nlongCondition = bar_index % (2 * cycleLength) == 0\n//@variable Returns `true` every `cycleLength` bars.\nshortCondition = bar_index % cycleLength == 0\n// Generate a long market order with a `color.green` label on `longCondition`.\nif longCondition\ndebugLabel(\"Long market order created\", color.green)\nstrategy.entry(\"My Long Entry Id\", strategy.long)\n// Otherwise, generate a short market order with a `color.red` label on `shortCondition`.\nelse if shortCondition\ndebugLabel(\"Short market order created\", color.red)\nstrategy.entry(\"My Short Entry Id\", strategy.short)\nLimit orders¶\nLimit orders command a strategy to enter a position at a specific price or better (lower than specified for long orders and higher for short ones). When the current market price is better than the order command’s limit parameter, the order will fill without waiting for the market price to reach the limit level.\nTo simulate limit orders in a script, pass a price value to an order placement command with a limit parameter. The following example places a limit order 800 ticks below the bar close 100 bars before the last_bar_index:\nstrategy(\"Limit order demo\", overlay = true, margin_long = 100, margin_short = 100)\n//@function Displays text passed to `txt` and a horizontal line at `price` when called.\ndebugLabel(price, txt) =>\nlabel.new(\nbar_index, price, text = txt, color = color.teal, textcolor = color.white,\nstyle = label.style_label_lower_right, size = size.large\nline.new(\nbar_index, price, bar_index + 1, price, color = color.teal, extend = extend.right,\nstyle = line.style_dashed\n// Generate a long limit order with a label and line 100 bars before the `last_bar_index`.\nif last_bar_index - bar_index == 100\nlimitPrice = close - syminfo.mintick * 800\ndebugLabel(limitPrice, \"Long Limit order created\")\nstrategy.entry(\"Long\", strategy.long, limit = limitPrice)\nNote how the script placed the label and started the line several bars before the trade. As long as the price remained above the limitPrice value, the order could not fill. Once the market price reached the limit, the strategy executed the trade mid-bar. If we had set the limitPrice to 800 ticks above the bar close rather than below, the order would fill immediately since the price is already at a better value:\nstrategy(\"Limit order demo\", overlay = true, margin_long = 100, margin_short = 100)\n//@function Displays text passed to `txt` and a horizontal line at `price` when called.\ndebugLabel(price, txt) =>\nlabel.new(\nbar_index, price, text = txt, color = color.teal, textcolor = color.white,\nstyle = label.style_label_lower_right, size = size.large\nline.new(\nbar_index, price, bar_index + 1, price, color = color.teal, extend = extend.right,\nstyle = line.style_dashed\n// Generate a long limit order with a label and line 100 bars before the `last_bar_index`.\nif last_bar_index - bar_index == 100\nlimitPrice = close + syminfo.mintick * 800\ndebugLabel(limitPrice, \"Long Limit order created\")\nstrategy.entry(\"Long\", strategy.long, limit = limitPrice)\nStop and stop-limit orders¶\nStop orders command a strategy to simulate another order after price reaches the specified stop price or a worse value (higher than specified for long orders and lower for short ones). They are essentially the opposite of limit orders. When the current market price is worse than the stop parameter, the strategy will trigger the subsequent order without waiting for the current price to reach the stop level. If the order placement command includes a limit argument, the subsequent order will be a limit order at the specified value. Otherwise, it will be a market order.\nThe script below places a stop order 800 ticks above the close 100 bars ago. In this example, the strategy entered a long position when the market price crossed the stop price some bars after it placed the order. Notice that the initial price at the time of the order was better than the one passed to stop. An equivalent limit order would have filled on the following chart bar:\nstrategy(\"Stop order demo\", overlay = true, margin_long = 100, margin_short = 100)\n//@function Displays text passed to `txt` when called and shows the `price` level on the chart.\ndebugLabel(price, txt) =>\nbar_index, high, text = txt, color = color.teal, textcolor = color.white,\nstyle = label.style_label_lower_right, size = size.large\nline.new(bar_index, high, bar_index, price, style = line.style_dotted, color = color.teal)\nline.new(\nbar_index, price, bar_index + 1, price, color = color.teal, extend = extend.right,\nstyle = line.style_dashed\n// Generate a long stop order with a label and lines 100 bars before the last bar.\nif last_bar_index - bar_index == 100\nstopPrice = close + syminfo.mintick * 800\ndebugLabel(stopPrice, \"Long Stop order created\")\nstrategy.entry(\"Long\", strategy.long, stop = stopPrice)\nOrder placement commands that use both limit and stop arguments produce stop-limit orders. This order type waits for the price to cross the stop level, then places a limit order at the specified limit price.\nLet’s modify our previous script to simulate and visualize a stop-limit order. In this example, we use the low value from 100 bars ago as the limit price in the entry command. This script also displays a label and price level to indicate when the strategy crosses the stopPrice, i.e., when the strategy activates the limit order. Notice how the market price initially reaches the limit level, but the strategy doesn’t simulate a trade because the price must cross the stopPrice to place the pending limit order at the limitPrice:\nstrategy(\"Stop-Limit order demo\", overlay = true, margin_long = 100, margin_short = 100)\n//@function Displays text passed to `txt` when called and shows the `price` level on the chart.\ndebugLabel(price, txt, lblColor, lineWidth = 1) =>\nbar_index, high, text = txt, color = lblColor, textcolor = color.white,\nline.new(bar_index, close, bar_index, price, style = line.style_dotted, color = lblColor, width = lineWidth)\nline.new(\nbar_index, price, bar_index + 1, price, color = lblColor, extend = extend.right,\nstyle = line.style_dashed, width = lineWidth\nvar float stopPrice = na\nvar float limitPrice = na\n// Generate a long stop-limit order with a label and lines 100 bars before the last bar.\nif last_bar_index - bar_index == 100\nstopPrice := close + syminfo.mintick * 800\nlimitPrice := low\ndebugLabel(limitPrice, \"\", color.gray)\ndebugLabel(stopPrice, \"Long Stop-Limit order created\", color.teal)\nstrategy.entry(\"Long\", strategy.long, stop = stopPrice, limit = limitPrice)\n// Draw a line and label once the strategy activates the limit order.\nif high >= stopPrice\ndebugLabel(limitPrice, \"Limit order activated\", color.green, 2)\nstopPrice := na\nOrder placement commands¶\nPine Script™ strategies feature several functions to simulate the placement of orders, known as order placement commands. Each command serves a unique purpose and behaves differently from the others.\n`strategy.entry()`¶\nThis command simulates entry orders. By default, strategies place market orders when calling this function, but they can also create stop, limit, and stop-limit orders when utilizing the stop and limit parameters.\nTo simplify opening positions, strategy.entry() features several unique behaviors. One such behavior is that this command can reverse an open market position without additional function calls. When an order placed using strategy.entry() fills, the function will automatically calculate the amount the strategy needs to close the open market position and trade qty contracts/shares/lots/units in the opposite direction by default. For example, if a strategy has an open position of 15 shares in the strategy.long direction and calls strategy.entry() to place a market order in the strategy.short direction, the amount the strategy will trade to place the order is 15 shares plus the qty of the new short order.\nThe example below demonstrates a strategy that uses only strategy.entry() calls to place entry orders. It creates a long market order with a qty value of 15 shares once every 100 bars and a short market order with a qty of 5 once every 25 bars. The script highlights the background blue and red for occurrences of the respective buyCondition and sellCondition:\nstrategy(\"Entry demo\", \"test\", overlay = true)\n//@variable Is `true` on every 100th bar.\nbuyCondition = bar_index % 100 == 0\n//@variable Is `true` on every 25th bar except for those that are divisible by 100.\nsellCondition = bar_index % 25 == 0 and not buyCondition\nif buyCondition\nstrategy.entry(\"buy\", strategy.long, qty = 15)\nif sellCondition\nstrategy.entry(\"sell\", strategy.short, qty = 5)\nbgcolor(buyCondition ? color.new(color.blue, 90) : na)\nbgcolor(sellCondition ? color.new(color.red, 90) : na)\nAs we see in the chart above, the order marks show that the strategy traded 20 shares on each order fill rather than 15 and 5. Since strategy.entry() automatically reverses positions, unless otherwise specified via the strategy.risk.allow_entry_in() function, it adds the open position size (15 for long entries) to the new order’s size (5 for short entries) when it changes the direction, resulting in a traded quantity of 20 shares.\nNotice that in the above example, although the sellCondition occurs three times before another buyCondition, the strategy only places a “sell” order on the first occurrence. Another unique behavior of the strategy.entry() command is that it’s affected by a script’s pyramiding setting. Pyramiding specifies the number of consecutive orders the strategy can fill in the same direction. Its value is 1 by default, meaning the strategy only allows one consecutive order to fill in either direction. Users can set the strategy pyramiding values via the pyramiding parameter of the strategy() function call or the “Pyramiding” input in the “Properties” tab of the script settings.\nIf we add pyramiding = 3 to our previous script’s declaration statement, the strategy will allow up to three consecutive trades in the same direction, meaning it can simulate new market orders on each occurrence of sellCondition:\n`strategy.order()`¶\nThis command simulates a basic order. Unlike most order placement commands, which contain internal logic to simplify interfacing with strategies, strategy.order() uses the specified parameters without accounting for most additional strategy settings. Orders placed by strategy.order() can open new positions and modify or close existing ones.\nThe following script uses only strategy.order() calls to create and modify entries. The strategy simulates a long market order for 15 units every 100 bars, then three short orders for five units every 25 bars. The script highlights the background blue and red to indicate when the strategy simulates “buy” and “sell” orders:\nstrategy(\"Order demo\", \"test\", overlay = true)\n//@variable Is `true` on every 100th bar.\nbuyCond = bar_index % 100 == 0\n//@variable Is `true` on every 25th bar except for those that are divisible by 100.\nsellCond = bar_index % 25 == 0 and not buyCond\nif buyCond\nstrategy.order(\"buy\", strategy.long, qty = 15) // Enter a long position of 15 units.\nif sellCond\nstrategy.order(\"sell\", strategy.short, qty = 5) // Exit 5 units from the long position.\nbgcolor(buyCond ? color.new(color.blue, 90) : na)\nbgcolor(sellCond ? color.new(color.red, 90) : na)\nThis particular strategy will never simulate a short position, as unlike strategy.entry(), strategy.order() does not automatically reverse positions. When using this command, the resulting market position is the net sum of the current market position and the filled order quantity. After the strategy fills the “buy” order for 15 units, it executes three “sell” orders that reduce the open position by five units each, and 15 - 5 * 3 = 0. The same script would behave differently using strategy.entry(), as per the example shown in the section above.\n`strategy.exit()`¶\nThis command simulates exit orders. It’s unique in that it allows a strategy to exit a market position or form multiple exits in the form of stop-loss, take-profit, and trailing stop orders via the loss, stop, profit, limit, and trail_* parameters.\nThe most basic use of the strategy.exit() command is the creation of levels where the strategy will exit a position due to losing too much money (stop-loss), earning enough money (take-profit), or both (bracket).\nThe stop-loss and take-profit functionalities of this command are associated with two parameters. The function’s loss and profit parameters specify stop-loss and take-profit values as a defined number of ticks away from the entry order’s price, while its stop and limit parameters provide specific stop-loss and take-profit price values. The absolute parameters in the function call supersede the relative ones. If a strategy.exit() call contains profit and limit arguments, the command will prioritize the limit value and ignore the profit value. Likewise, it will only consider the stop value when the function call contains stop and loss arguments.\nDespite sharing the same names with parameters from strategy.entry() and strategy.order() commands, the limit and stop parameters work differently in strategy.exit(). In the first case, using limit and stop in the command will create a single stop-limit order that opens a limit order after crossing the stop price. In the second case, the command will create a separate limit and stop order to exit from an open position.\nAll exit orders from strategy.exit() with a from_entry argument are bound to the id of a corresponding entry order; strategies cannot simulate exit orders when there is no open market position or active entry order associated with a from_entry ID.\nThe following strategy places a “buy” entry order via strategy.entry() and a stop-loss and take-profit order via the strategy.exit() command every 100 bars. Notice that the script calls strategy.exit() twice. The “exit1” command references a “buy1” entry order, and “exit2” references the “buy” order. The strategy will only simulate exit orders from “exit2” because “exit1” references an order ID that doesn’t exist:\nstrategy(\"Exit demo\", \"test\", overlay = true)\n//@variable Is `true` on every 100th bar.\nbuyCondition = bar_index % 100 == 0\n//@variable Stop-loss price for exit commands.\nvar float stopLoss = na\n//@variable Take-profit price for exit commands.\nvar float takeProfit = na\n// Place orders upon `buyCondition`.\nif buyCondition\nif strategy.position_size == 0.0\nstopLoss := close * 0.99\ntakeProfit := close * 1.01\nstrategy.entry(\"buy\", strategy.long)\nstrategy.exit(\"exit1\", \"buy1\", stop = stopLoss, limit = takeProfit) // Does nothing. \"buy1\" order doesn't exist.\nstrategy.exit(\"exit2\", \"buy\", stop = stopLoss, limit = takeProfit)\n// Set `stopLoss` and `takeProfit` to `na` when price touches either, i.e., when the strategy simulates an exit.\nif low <= stopLoss or high >= takeProfit\nstopLoss := na\ntakeProfit := na\nplot(stopLoss, \"SL\", color.red, style = plot.style_circles)\nplot(takeProfit, \"TP\", color.green, style = plot.style_circles)\nLimit and stop orders from each exit command do not necessarily fill at the specified prices. Strategies can fill limit orders at better prices and stop orders at worse prices, depending on the range of values available to the broker emulator.\nIf a user does not provide a from_entry argument in the strategy.exit() call, the function will create exit orders for each open entry.\nIn this example, the strategy creates “buy1” and “buy2” entry orders and calls strategy.exit() without a from_entry argument every 100 bars. As we can see from the order marks on the chart, once the market price reaches the stopLoss or takeProfit values, the strategy fills an exit order for both “buy1” and “buy2” entries:\nstrategy(\"Exit all demo\", \"test\", overlay = true, pyramiding = 2)\n//@variable Is `true` on every 100th bar.\nbuyCondition = bar_index % 100 == 0\n//@variable Stop-loss price for exit commands.\nvar float stopLoss = na\n//@variable Take-profit price for exit commands.\nvar float takeProfit = na\n// Place orders upon `buyCondition`.\nif buyCondition\nif strategy.position_size == 0.0\nstopLoss := close * 0.99\ntakeProfit := close * 1.01\nstrategy.entry(\"buy1\", strategy.long)\nstrategy.entry(\"buy2\", strategy.long)\nstrategy.exit(\"exit\", stop = stopLoss, limit = takeProfit) // Places orders to exit all open entries.\n// Set `stopLoss` and `takeProfit` to `na` when price touches either, i.e., when the strategy simulates an exit.\nif low <= stopLoss or high >= takeProfit\nstopLoss := na\ntakeProfit := na\nplot(stopLoss, \"SL\", color.red, style = plot.style_circles)\nplot(takeProfit, \"TP\", color.green, style = plot.style_circles)\nIt is possible for a strategy to exit from the same entry ID more than once, which facilitates the formation of multi-level exit strategies. When performing multiple exit commands, each order’s quantity must be a portion of the traded quantity, with their sum not exceeding the open position. If the qty of the function is less than the size of the current market position, the strategy will simulate a partial exit. If the qty value exceeds the open position quantity, it will reduce the order since it cannot fill more contracts/shares/lots/units than the open position.\nIn the example below, we’ve modified our previous “Exit demo” script to simulate two stop-loss and take-profit orders per entry. The strategy places a “buy” order with a qty of two shares, “exit1” stop-loss and take-profit orders with a qty of one share, and “exit2” stop-loss and take profit orders with a qty of three shares:\nstrategy(\"Multiple exit demo\", \"test\", overlay = true)\nbuyCondition = bar_index % 100 == 0\n//@variable Stop-loss price for \"exit1\" commands.\nvar float stopLoss1 = na\n//@variable Stop-loss price for \"exit2\" commands.\nvar float stopLoss2 = na\n//@variable Take-profit price for \"exit1\" commands.\nvar float takeProfit1 = na\n//@variable Take-profit price for \"exit2\" commands.\nvar float takeProfit2 = na\n// Place orders upon `buyCondition`.\nif buyCondition\nif strategy.position_size == 0.0\nstopLoss1 := close * 0.99\nstopLoss2 := close * 0.98\ntakeProfit1 := close * 1.01\ntakeProfit2 := close * 1.02\nstrategy.entry(\"buy\", strategy.long, qty = 2)\nstrategy.exit(\"exit1\", \"buy\", stop = stopLoss1, limit = takeProfit1, qty = 1)\nstrategy.exit(\"exit2\", \"buy\", stop = stopLoss2, limit = takeProfit2, qty = 3)\n// Set `stopLoss1` and `takeProfit1` to `na` when price touches either.\nif low <= stopLoss1 or high >= takeProfit1\nstopLoss1 := na\ntakeProfit1 := na\n// Set `stopLoss2` and `takeProfit2` to `na` when price touches either.\nif low <= stopLoss2 or high >= takeProfit2\nstopLoss2 := na\ntakeProfit2 := na\nplot(stopLoss1, \"SL1\", color.red, style = plot.style_circles)\nplot(stopLoss2, \"SL2\", color.red, style = plot.style_circles)\nplot(takeProfit1, \"TP1\", color.green, style = plot.style_circles)\nplot(takeProfit2, \"TP2\", color.green, style = plot.style_circles)\nAs we can see from the order marks on the chart, the strategy filled “exit2” orders despite the specified qty value exceeding the traded amount. Rather than using this quantity, the script reduced the orders’ sizes to match the remaining position.\nAll orders generated from a strategy.exit() call belong to the same strategy.oca.reduce group, meaning that when either order fills, the strategy reduces all others to match the open position.\nIt’s important to note that orders produced by this command reserve a portion of the open market position to exit. strategy.exit() cannot place an order to exit a portion of the position already reserved for exit by another exit command.\nThe following script simulates a “buy” market order for 20 shares 100 bars ago with “limit” and “stop” orders of 19 and 20 shares respectively. As we see on the chart, the strategy executed the “stop” order first. However, the traded quantity was only one share. Since the script placed the “limit” order first, the strategy reserved its qty (19 shares) to close the open position, leaving only one share to be closed by the “stop” order:\nstrategy(\"Reserved exit demo\", \"test\", overlay = true)\n//@variable \"stop\" exit order price.\nvar float stop = na\n//@variable \"limit\" exit order price\nvar float limit = na\n//@variable Is `true` 100 bars before the `last_bar_index`.\nlongCondition = last_bar_index - bar_index == 100\nif longCondition\nstop := close * 0.99\nlimit := close * 1.01\nstrategy.entry(\"buy\", strategy.long, 20)\nstrategy.exit(\"limit\", limit = limit, qty = 19)\nstrategy.exit(\"stop\", stop = stop, qty = 20)\nbool showPlot = strategy.position_size != 0\nplot(showPlot ? stop : na, \"Stop\", color.red, 2, plot.style_linebr)\nplot(showPlot ? limit : na, \"Limit 1\", color.green, 2, plot.style_linebr)\nAnother key feature of the strategy.exit() function is that it can create trailing stops, i.e., stop-loss orders that trail behind the market price by a specified amount whenever the price moves to a better value in the favorable direction. These orders have two components: the activation level and the trail offset. The activation level is the value the market price must cross to activate the trailing stop calculation, expressed in ticks via the trail_points parameter or as a price value via the trail_price parameter. If an exit call contains both arguments, the trail_price argument takes precedence. The trail offset is the distance the stop will follow behind the market price, expressed in ticks via the trail_offset parameter. For strategy.exit() to create and activate trailing stops, the function call must contain trail_offset and either trail_price or trail_points arguments.\nThe example below shows a trailing stop in action and visualizes its behavior. The strategy simulates a long entry order on the bar 100 bars before the last bar on the chart, then a trailing stop on the next bar. The script has two inputs: one controls the activation level offset (i.e., the amount past the entry price required to activate the stop), and the other controls the trail offset (i.e., the distance to follow behind the market price when it moves to a better value in the desired direction).\nThe green dashed line on the chart shows the level the market price must cross to trigger the trailing stop order. After the price crosses this level, the script plots a blue line to signify the trailing stop. When the price rises to a new high value, which is favorable for the strategy since it means the position’s value is increasing, the stop also rises to maintain a distance of trailingStopOffset ticks behind the current price. When the price decreases or doesn’t reach a new high point, the stop value stays the same. Eventually, the price crosses below the stop, triggering the exit:\nstrategy(\"Trailing stop order demo\", overlay = true, margin_long = 100, margin_short = 100)\n//@variable Offset used to determine how far above the entry price (in ticks) the activation level will be located.\nactivationLevelOffset = input(1000, \"Activation Level Offset (in ticks)\")\n//@variable Offset used to determine how far below the high price (in ticks) the trailing stop will trail the chart.\ntrailingStopOffset = input(2000, \"Trailing Stop Offset (in ticks)\")\n//@function Displays text passed to `txt` when called and shows the `price` level on the chart.\ndebugLabel(price, txt, lblColor, hasLine = false) =>\nbar_index, price, text = txt, color = lblColor, textcolor = color.white,\nif hasLine\nbar_index, price, bar_index + 1, price, color = lblColor, extend = extend.right,\nstyle = line.style_dashed\n//@variable The price at which the trailing stop activation level is located.\nvar float trailPriceActivationLevel = na\n//@variable The price at which the trailing stop itself is located.\nvar float trailingStop = na\n//@variable Caclulates the value that Trailing Stop would have if it were active at the moment.\ntheoreticalStopPrice = high - trailingStopOffset * syminfo.mintick\n// Generate a long market order to enter 100 bars before the last bar.\nstrategy.entry(\"Long\", strategy.long)\n// Generate a trailing stop 99 bars before the last bar.\nif last_bar_index - bar_index == 99\ntrailPriceActivationLevel := open + syminfo.mintick * activationLevelOffset\nstrategy.exit(\n\"Trailing Stop\", from_entry = \"Long\", trail_price = trailPriceActivationLevel,\ntrail_offset = trailingStopOffset\ndebugLabel(trailPriceActivationLevel, \"Trailing Stop Activation Level\", color.green, true)\n// Visualize the trailing stop mechanic in action.\n// If there is an open trade, check whether the Activation Level has been achieved.\n// If it has been achieved, track the trailing stop by assigning its value to a variable.\nif strategy.opentrades == 1\nif na(trailingStop) and high > trailPriceActivationLevel\ndebugLabel(trailPriceActivationLevel, \"Activation level crossed\", color.green)\ntrailingStop := theoreticalStopPrice\ndebugLabel(trailingStop, \"Trailing Stop Activated\", color.blue)\nelse if theoreticalStopPrice > trailingStop\ntrailingStop := theoreticalStopPrice\n// Visualize the movement of the trailing stop.\nplot(trailingStop, \"Trailing Stop\")\n`strategy.close()` and `strategy.close_all()`¶\nThese commands simulate exit positions using market orders. The functions close trades upon being called rather than at a specific price.\nThe example below demonstrates a simple strategy that places a “buy” order via strategy.entry() once every 50 bars that it closes with a market order using strategy.close() 25 bars afterward:\nstrategy(\"Close demo\", \"test\", overlay = true)\n//@variable Is `true` on every 50th bar.\nbuyCond = bar_index % 50 == 0\n//@variable Is `true` on every 25th bar except for those that are divisible by 50.\nsellCond = bar_index % 25 == 0 and not buyCond\nif buyCond\nstrategy.entry(\"buy\", strategy.long)\nif sellCond\nstrategy.close(\"buy\")\nbgcolor(buyCond ? color.new(color.blue, 90) : na)\nbgcolor(sellCond ? color.new(color.red, 90) : na)\nUnlike most other order placement commands, the id parameter of strategy.close() references an existing entry ID to close. If the specified id does not exist, the command will not execute an order. If a position was formed from multiple entries with the same ID, the command will exit all entries simultaneously.\nTo demonstrate, the following script places a “buy” order once every 25 bars. The script closes all “buy” entries once every 100 bars. We’ve included pyramiding = 3 in the strategy() declaration statement to allow the strategy to simulate up to three orders in the same direction:\nstrategy(\"Multiple close demo\", \"test\", overlay = true, pyramiding = 3)\nsellCond = bar_index % 100 == 0\n//@variable Is `true` on every 25th bar except for those that are divisible by 100.\nbuyCond = bar_index % 25 == 0 and not sellCond\nif buyCond\nstrategy.entry(\"buy\", strategy.long)\nif sellCond\nstrategy.close(\"buy\")\nbgcolor(buyCond ? color.new(color.blue, 90) : na)\nbgcolor(sellCond ? color.new(color.red, 90) : na)\nFor cases where a script has multiple entries with different IDs, the strategy.close_all() command can come in handy since it closes all entries, irrespective of their IDs.\nThe script below places “A”, “B”, and “C” entry orders sequentially based on the number of open trades, then closes all of them with a single market order:\nstrategy(\"Close multiple ID demo\", \"test\", overlay = true, pyramiding = 3)\nswitch strategy.opentrades\n0 => strategy.entry(\"A\", strategy.long)\n1 => strategy.entry(\"B\", strategy.long)\n2 => strategy.entry(\"C\", strategy.long)\n3 => strategy.close_all()\n`strategy.cancel()` and `strategy.cancel_all()`¶\nThese commands allow a strategy to cancel pending orders, i.e., those generated by strategy.exit() or by strategy.order() or strategy.entry() when they use limit or stop arguments.\nThe following strategy simulates a “buy” limit order 500 ticks below the closing price 100 bars ago, then cancels the order on the next bar. The script draws a horizontal line at the limitPrice and colors the background green and orange to indicate when the limit order is placed and canceled respectively. As we can see, nothing happened once the market price crossed the limitPrice because the strategy already canceled the order:\nstrategy(\"Cancel demo\", \"test\", overlay = true)\n//@variable Draws a horizontal line at the `limit` price of the \"buy\" order.\nvar line limitLine = na\n//@variable Returns `color.green` when the strategy places the \"buy\" order, `color.orange` when it cancels the order.\ncolor bgColor = na\nfloat limitPrice = close - syminfo.mintick * 500\nstrategy.entry(\"buy\", strategy.long, limit = limitPrice)\nlimitLine := line.new(bar_index, limitPrice, bar_index + 1, limitPrice, extend = extend.right)\nbgColor := color.new(color.green, 50)\nif last_bar_index - bar_index == 99\nstrategy.cancel(\"buy\")\nbgColor := color.new(color.orange, 50)\nbgcolor(bgColor)\nAs with strategy.close(), the id parameter of strategy.cancel() refers to the ID of an existing entry. This command will do nothing if the id parameter references an ID that doesn’t exist. When there are multiple pending orders with the same ID, this command will cancel all of them at once.\nIn this example, we’ve modified the previous script to place a “buy” limit order on three consecutive bars starting from 100 bars ago. The strategy cancels all of them after the bar_index is 97 bars away from the most recent bar, resulting in it doing nothing when the price crosses any of the lines:\nstrategy(\"Multiple cancel demo\", \"test\", overlay = true, pyramiding = 3)\n//@variable Draws a horizontal line at the `limit` price of the \"buy\" order.\nvar line limitLine = na\n//@variable Returns `color.green` when the strategy places the \"buy\" order, `color.orange` when it cancels the order.\ncolor bgColor = na\nif last_bar_index - bar_index <= 100 and last_bar_index - bar_index >= 98\nfloat limitPrice = close - syminfo.mintick * 500\nstrategy.entry(\"buy\", strategy.long, limit = limitPrice)\nlimitLine := line.new(bar_index, limitPrice, bar_index + 1, limitPrice, extend = extend.right)\nbgColor := color.new(color.green, 50)\nif last_bar_index - bar_index == 97\nstrategy.cancel(\"buy\")\nbgColor := color.new(color.orange, 50)\nbgcolor(bgColor)\nWe added pyramiding = 3 to the script’s declaration statement to allow three strategy.entry() orders to fill. Alternatively, the script would achieve the same output by using strategy.order() since it isn’t sensitive to the pyramiding setting.\nIt’s important to note that neither strategy.cancel() nor strategy.cancel_all() can cancel market orders, as the strategy executes them immediately upon the next tick. Strategies cannot cancel orders after they’ve been filled. To close an open position, use strategy.close() or strategy.close_all().\nThis example simulates a “buy” market order 100 bars ago, then attempts to cancel all pending orders on the next bar. Since the strategy already filled the “buy” order, the strategy.cancel_all() command does nothing in this case, as there are no pending orders to cancel:\nstrategy(\"Cancel market demo\", \"test\", overlay = true)\n//@variable Returns `color.green` when the strategy places the \"buy\" order, `color.orange` when it tries to cancel.\ncolor bgColor = na\nbgColor := color.new(color.green, 50)\nif last_bar_index - bar_index == 99\nstrategy.cancel_all()\nbgColor := color.new(color.orange, 50)\nbgcolor(bgColor)\nPosition sizing¶\nPine Script™ strategies feature two ways to control the sizes of simulated trades:\nSet a default fixed quantity type and value for all orders using the default_qty_type and default_qty_value arguments in the strategy() function, which also sets the default values in the “Properties” tab of the script settings.\nSpecify the qty argument when calling strategy.entry(). When a user supplies this argument to the function, the script ignores the strategy’s default quantity value and type.\nThe following example simulates “Buy” orders of longAmount size whenever the low price equals the lowest value, and “Sell” orders of shortAmount size when the high price equals the highest value:\nstrategy(\"Buy low, sell high\", overlay = true, default_qty_type = strategy.cash, default_qty_value = 5000)\nint length = input.int(20, \"Length\")\nfloat longAmount = input.float(4.0, \"Long Amount\")\nfloat shortAmount = input.float(2.0, \"Short Amount\")\nfloat highest = ta.highest(length)\nfloat lowest = ta.lowest(length)\nswitch\nlow == lowest => strategy.entry(\"Buy\", strategy.long, longAmount)\nhigh == highest => strategy.entry(\"Sell\", strategy.short, shortAmount)\nNotice that in the above example, although we’ve specified the default_qty_type and default_qty_value arguments in the declaration statement, the script does not use these defaults for the simulated orders. Instead, it sizes them as a longAmount and shortAmount of units. If we want the script to use the default type and value, we must remove the qty specification from the strategy.entry() calls:\nstrategy(\"Buy low, sell high\", overlay = true, default_qty_type = strategy.cash, default_qty_value = 5000)\nint length = input.int(20, \"Length\")\nfloat highest = ta.highest(length)\nfloat lowest = ta.lowest(length)\nswitch\nlow == lowest => strategy.entry(\"Buy\", strategy.long)\nhigh == highest => strategy.entry(\"Sell\", strategy.short)\nClosing a market position¶\nAlthough it is possible to simulate an exit from a specific entry order shown in the List of Trades tab of the Strategy Tester module, all orders are linked according to FIFO (first in, first out) rules. If the user does not specify the from_entry parameter of a strategy.exit() call, the strategy will exit the open market position starting from the first entry order that opened it.\nThe following example simulates two orders sequentially: “Buy1” at the market price for the last 100 bars and “Buy2” once the position size matches the size of “Buy1”. The strategy only places an exit order when the positionSize is 15 units. The script does not supply a from_entry argument to the strategy.exit() command, so the strategy places exit orders for all open positions each time it calls the function, starting with the first. It plots the positionSize in a separate pane for visual reference:\nstrategy(\"Exit Demo\", pyramiding = 2)\nfloat positionSize = strategy.position_size\nif positionSize == 0 and last_bar_index - bar_index <= 100\nstrategy.entry(\"Buy1\", strategy.long, 5)\nelse if positionSize == 5\nstrategy.entry(\"Buy2\", strategy.long, 10)\nelse if positionSize == 15\nstrategy.exit(\"bracket\", loss = 10, profit = 10)\nplot(positionSize == 0 ? na : positionSize, \"Position Size\", color.lime, 4, plot.style_histogram)\nWe included pyramiding = 2 in our script’s declaration statement to allow it to simulate two consecutive orders in the same direction.\nSuppose we wanted to exit “Buy2” before “Buy1”. Let’s see what happens if we instruct the strategy to close “Buy2” before “Buy1” when it fills both orders:\nstrategy(\"Exit Demo\", pyramiding = 2)\nfloat positionSize = strategy.position_size\nif positionSize == 0 and last_bar_index - bar_index <= 100\nstrategy.entry(\"Buy1\", strategy.long, 5)\nelse if positionSize == 5\nstrategy.entry(\"Buy2\", strategy.long, 10)\nelse if positionSize == 15\nstrategy.close(\"Buy2\")\nstrategy.exit(\"bracket\", \"Buy1\", loss = 10, profit = 10)\nplot(positionSize == 0 ? na : positionSize, \"Position Size\", color.lime, 4, plot.style_histogram)\nAs we can see in the Strategy Tester’s “List of Trades” tab, rather than closing the “Buy2” position with strategy.close(), it closes the quantity of “Buy1” first, which is half the quantity of the close order, then closes half of the “Buy2” position, as the broker emulator follows FIFO rules by default. Users can change this behavior by specifying close_entries_rule = \"ANY\" in the strategy() function.\nOCA groups¶\nOne-Cancels-All (OCA) groups allow a strategy to fully or partially cancel other orders upon the execution of order placement commands, including strategy.entry() and strategy.order(), with the same oca_name, depending on the oca_type that the user provides in the function call.\n`strategy.oca.cancel`¶\nThe strategy.oca.cancel OCA type cancels all orders with the same oca_name upon the fill or partial fill of an order from the group.\nFor example, the following strategy executes orders upon ma1 crossing ma2. When the strategy.position_size is 0, it places long and short stop orders on the high and low of the bar. Otherwise, it calls strategy.close_all() to close all open positions with a market order. Depending on the price action, the strategy may fill both orders before issuing a close order. Additionally, if the broker emulator’s intrabar assumption supports it, both orders may fill on the same bar. The strategy.close_all() command does nothing in such cases, as the script cannot invoke the action until after already executing both orders:\nstrategy(\"OCA Cancel Demo\", overlay=true)\nfloat ma1 = ta.sma(close, 5)\nfloat ma2 = ta.sma(close, 9)\nif ta.cross(ma1, ma2)\nif strategy.position_size == 0\nstrategy.order(\"Long\", strategy.long, stop = high)\nstrategy.order(\"Short\", strategy.short, stop = low)\nstrategy.close_all()\nplot(ma1, \"Fast MA\", color.aqua)\nplot(ma2, \"Slow MA\", color.orange)\nTo eliminate scenarios where the strategy fills long and short orders before a close order, we can instruct it to cancel one order after it executes the other. In this example, we’ve set the oca_name for both strategy.order() commands to “Entry” and their oca_type to strategy.oca.cancel:\nstrategy(\"OCA Cancel Demo\", overlay=true)\nfloat ma1 = ta.sma(close, 5)\nfloat ma2 = ta.sma(close, 9)\nif ta.cross(ma1, ma2)\nif strategy.position_size == 0\nstrategy.order(\"Long\", strategy.long, stop = high, oca_name = \"Entry\", oca_type = strategy.oca.cancel)\nstrategy.order(\"Short\", strategy.short, stop = low, oca_name = \"Entry\", oca_type = strategy.oca.cancel)\nstrategy.close_all()\nplot(ma1, \"Fast MA\", color.aqua)\nplot(ma2, \"Slow MA\", color.orange)\n`strategy.oca.reduce`¶\nThe strategy.oca.reduce OCA type does not cancel orders. Instead, it reduces the size of orders with the same oca_name upon each new fill by the number of closed contracts/shares/lots/units, which is particularly useful for exit strategies.\nThe following example demonstrates an attempt at a long-only exit strategy that generates a stop-loss order and two take-profit orders for each new entry. Upon the crossover of two moving averages, it simulates a “Long” entry order using strategy.entry() with a qty of 6 units, then simulates stop/limit orders for 6, 3, and 3 units using strategy.order() at the stop, limit1, and limit2 prices respectively.\nAfter adding the strategy to our chart, we see it doesn’t work as intended. The issue with this script is that strategy.order() doesn’t belong to an OCA group by default, unlike strategy.exit(). Since we have not explicitly assigned the orders to an OCA group, the strategy does not cancel or reduce them when it fills one, meaning it’s possible to trade a greater quantity than the open position and reverse the direction:\nstrategy(\"Multiple TP Demo\", overlay = true)\nvar float stop = na\nvar float limit1 = na\nvar float limit2 = na\nbool longCondition = ta.crossover(ta.sma(close, 5), ta.sma(close, 9))\nif longCondition and strategy.position_size == 0\nstop := close * 0.99\nlimit1 := close * 1.01\nlimit2 := close * 1.02\nstrategy.entry(\"Long\", strategy.long, 6)\nstrategy.order(\"Stop\", strategy.short, stop = stop, qty = 6)\nstrategy.order(\"Limit 1\", strategy.short, limit = limit1, qty = 3)\nstrategy.order(\"Limit 2\", strategy.short, limit = limit2, qty = 3)\nbool showPlot = strategy.position_size != 0\nplot(showPlot ? stop : na, \"Stop\", color.red, style = plot.style_linebr)\nplot(showPlot ? limit1 : na, \"Limit 1\", color.green, style = plot.style_linebr)\nplot(showPlot ? limit2 : na, \"Limit 2\", color.green, style = plot.style_linebr)\nFor our strategy to work as intended, we must instruct it to reduce the number of units for the other stop-loss/take-profit orders so that they do not exceed the size of the remaining open position.\nIn the example below, we’ve set the oca_name for each order in our exit strategy to “Bracket” and the oca_type to strategy.oca.reduce. These settings tell the strategy to reduce the qty values of orders in the “Bracket” group by the qty filled when it executes one of them, preventing it from trading an excessive number of units and causing a reversal:\nstrategy(\"Multiple TP Demo\", overlay = true)\nvar float stop = na\nvar float limit1 = na\nvar float limit2 = na\nbool longCondition = ta.crossover(ta.sma(close, 5), ta.sma(close, 9))\nif longCondition and strategy.position_size == 0\nstop := close * 0.99\nlimit1 := close * 1.01\nlimit2 := close * 1.02\nstrategy.entry(\"Long\", strategy.long, 6)\nstrategy.order(\"Stop\", strategy.short, stop = stop, qty = 6, oca_name = \"Bracket\", oca_type = strategy.oca.reduce)\nstrategy.order(\"Limit 1\", strategy.short, limit = limit1, qty = 3, oca_name = \"Bracket\", oca_type = strategy.oca.reduce)\nstrategy.order(\"Limit 2\", strategy.short, limit = limit2, qty = 6, oca_name = \"Bracket\", oca_type = strategy.oca.reduce)\nbool showPlot = strategy.position_size != 0\nplot(showPlot ? stop : na, \"Stop\", color.red, style = plot.style_linebr)\nplot(showPlot ? limit1 : na, \"Limit 1\", color.green, style = plot.style_linebr)\nplot(showPlot ? limit2 : na, \"Limit 2\", color.green, style = plot.style_linebr)\nWe changed the qty of the “Limit 2” order to 6 instead of 3 because the strategy will reduce its value by 3 when it fills the “Limit 1” order. Keeping the qty value of 3 would cause it to drop to 0 and never fill after filling the first limit order.\nCurrency¶\nPine Script™ strategies can use different base currencies than the instruments they calculate on. Users can specify the simulated account’s base currency by including a currency.* variable as the currency argument in the strategy() function, which will change the script’s strategy.account_currency value. The default currency value for strategies is currency.NONE, meaning that the script uses the base currency of the instrument on the chart.\nWhen a strategy script uses a specified base currency, it multiplies the simulated profits by the FX_IDC conversion rate from the previous trading day. For example, the strategy below places an entry order for a standard lot (100,000 units) with a profit target and stop-loss of 1 point on each of the last 500 chart bars, then plots the net profit alongside the inverted daily close of the symbol in a separate pane. We have set the base currency to currency.EUR. When we add this script to FX_IDC:EURUSD, the two plots align, confirming the strategy uses the previous day’s rate from this symbol for its calculations:\nstrategy(\"Currency Test\", currency = currency.EUR)\nif last_bar_index - bar_index < 500\nstrategy.entry(\"LE\", strategy.long, 100000)\nstrategy.exit(\"LX\", \"LE\", profit = 1, loss = 1)\nplot(math.abs(ta.change(strategy.netprofit)), \"1 Point profit\", color = color.fuchsia, linewidth = 4)\nplot(request.security(syminfo.tickerid, \"D\", 1 / close)[1], \"Previous day's inverted price\", color = color.lime)\nWhen trading on timeframes higher than daily, the strategy will use the closing price from one trading day before the bar closes for cross-rate calculation on historical bars. For example, on a weekly timeframe, it will base the cross-rate on the previous Thursday’s closing value, though the strategy will still use the daily closing rate for real-time bars.\nAltering calculation behavior¶\nStrategies execute on all historical bars available from a chart, then automatically continue their calculations in real-time as new data is available. By default, strategy scripts only calculate once per confirmed bar. We can alter this behavior by changing the parameters of the strategy() function or clicking the checkboxes in the “Recalculate” section of the script’s “Properties” tab.\n`calc_on_every_tick`¶\ncalc_on_every_tick is an optional setting that controls the calculation behavior on real-time data. When this parameter is enabled, the script will recalculate its values on each new price tick. By default, its value is false, meaning the script only executes calculations after a bar is confirmed.\nEnabling this calculation behavior may be particularly useful when forward testing since it facilitates granular, real-time strategy simulation. However, it’s important to note that this behavior introduces a data difference between real-time and historical simulations, as historical bars do not contain tick information. Users should exercise caution with this setting, as the data difference may cause a strategy to repaint its history.\nThe following script will simulate a new order each time that close reaches the highest or lowest value over the input length. Since calc_on_every_tick is enabled in the strategy declaration, the script will simulate new orders on each new real-time price tick after compilation:\nstrategy(\"Donchian Channel Break\", overlay = true, calc_on_every_tick = true, pyramiding = 20)\nint length = input.int(15, \"Length\")\nfloat highest = ta.highest(close, length)\nfloat lowest = ta.lowest(close, length)\nif close == highest\nstrategy.entry(\"Buy\", strategy.long)\nif close == lowest\nstrategy.entry(\"Sell\", strategy.short)\n//@variable The starting time for real-time bars.\nvar realTimeStart = timenow\n// Color the background of real-time bars.\nbgcolor(time_close >= realTimeStart ? color.new(color.orange, 80) : na)\nplot(highest, \"Highest\", color = color.lime)\nplot(lowest, \"Lowest\", color = color.red)\nThe script uses a pyramiding value of 20 in its declaration, which allows the strategy to simulate a maximum of 20 trades in the same direction.\nTo visually demarcate what bars are processed as real-time bars by the strategy, the script colors the background for all bars since the timenow when it was last compiled.\nAfter applying the script to the chart and letting it calculate on some real-time bars, we may see an output like the following:\nThe script placed “Buy” orders on each new real-time tick the condition was valid on, resulting in multiple orders per bar. However, it may surprise users unfamiliar with this behavior to see the strategy’s outputs change after recompiling the script, as the bars that it previously executed real-time calculations on are now historical bars, which do not hold tick information:\n`calc_on_order_fills`¶\nThe optional calc_on_order_fills setting enables the recalculation of a strategy immediately after simulating an order fill, which allows the script to use more granular prices and place additional orders without waiting for a bar to be confirmed.\nEnabling this setting can provide the script with additional data that would otherwise not be available until after a bar closes, such as the current average price of a simulated position on an unconfirmed bar.\nThe example below shows a simple strategy declared with calc_on_order_fills enabled that simulates a “Buy” order when the strategy.position_size is 0. The script uses the strategy.position_avg_price to calculate a stopLoss and takeProfit and simulates “Exit” orders when the price crosses them, regardless of whether the bar is confirmed. As a result, as soon as an exit is triggered, the strategy recalculates and places a new entry order because the strategy.position_size is once again equal to 0. The strategy places the order once the exit happens and executes it on the next tick after the exit, which will be one of the bar’s OHLC values, depending on the emulated intrabar movement:\nstrategy(\"Intrabar exit\", overlay = true, calc_on_order_fills = true)\nfloat stopSize = input.float(5.0, \"SL %\", minval = 0.0) / 100.0\nfloat profitSize = input.float(5.0, \"TP %\", minval = 0.0) / 100.0\nif strategy.position_size == 0.0\nstrategy.entry(\"Buy\", strategy.long)\nfloat stopLoss = strategy.position_avg_price * (1.0 - stopSize)\nfloat takeProfit = strategy.position_avg_price * (1.0 + profitSize)\nstrategy.exit(\"Exit\", stop = stopLoss, limit = takeProfit)\nWith calc_on_order_fills turned off, the same strategy will only ever enter one bar after it triggers an exit order. First, the mid-bar exit will happen, but no entry order. Then, the strategy will simulate an entry order once the bar closes, which it will fill on the next tick after that, i.e., the open of the next bar.\nIt’s important to note that enabling calc_on_order_fills may produce unrealistic strategy results, as the broker emulator may assume order prices that are not possible when trading in real-time. Users must exercise caution with this setting and carefully consider the logic in their scripts.\nThe following example simulates a “Buy” order after each new order fill and bar confirmation over a 25-bar window from the last_bar_index when the script loaded on the chart. With the setting enabled, the strategy simulates four entries per bar since the emulator considers each bar to have four ticks (open, high, low, close), which is unrealistic behavior, as it’s not typically possible for an order to fill at the exact high or low of a bar:\nstrategy(\"buy on every fill\", overlay = true, calc_on_order_fills = true, pyramiding = 100)\nif last_bar_index - bar_index <= 25\nstrategy.entry(\"Buy\", strategy.long)\n`process_orders_on_close`¶\nThe default strategy behavior simulates orders at the close of each bar, meaning that the earliest opportunity to fill the orders and execute strategy calculations and alerts is upon the opening of the following bar. Traders can change this behavior to process a strategy using the closing value of each bar by enabling the process_orders_on_close setting.\nThis behavior is most useful when backtesting manual strategies in which traders exit positions before a bar closes or in scenarios where algorithmic traders in non-24x7 markets set up after-hours trading capability so that alerts sent after close still have hope of filling before the following day.\nIt’s crucial to be aware that using strategies with process_orders_on_close in a live trading environment may lead to a repainting strategy, as alerts on the close of a bar still occur when the market closes, and orders may not fill until the next market open.\nSimulating trading costs¶\nFor a strategy performance report to contain relevant, meaningful data, traders should strive to account for potential real-world costs in their strategy results. Neglecting to do so may give traders an unrealistic view of strategy performance and undermine the credibility of test results. Without modeling the potential costs associated with their trades, traders may overestimate a strategy’s historical profitability, potentially leading to suboptimal decisions in live trading. Pine Script™ strategies include inputs and parameters for simulating trading costs in performance results.\nCommission¶\nCommission refers to the fee a broker/exchange charges when executing trades. Depending on the broker/exchange, some may charge a flat fee per trade or contract/share/lot/unit, and others may charge a percentage of the total transaction value. Users can set the commission properties of their strategies by including commission_type and commission_value arguments in the strategy() function or by setting the “Commission” inputs in the “Properties” tab of the strategy settings.\nThe following script is a simple strategy that simulates a “Long” position of 2% of equity when close equals the highest value over the length, and closes the trade when it equals the lowest value:\nstrategy(\"Commission Demo\", overlay=true, default_qty_value = 2, default_qty_type = strategy.percent_of_equity)\nlength = input.int(10, \"Length\")\nfloat highest = ta.highest(close, length)\nfloat lowest = ta.lowest(close, length)\nswitch close\nhighest => strategy.entry(\"Long\", strategy.long)\nlowest => strategy.close(\"Long\")\nplot(highest, color = color.new(color.lime, 50))\nplot(lowest, color = color.new(color.red, 50))\nUpon inspecting the results in the Strategy Tester, we see that the strategy had a positive equity growth of 17.61% over the testing range. However, the backtest results do not account for fees the broker/exchange may charge. Let’s see what happens to these results when we include a small commission on every trade in the strategy simulation. In this example, we’ve included commission_type = strategy.commission.percent and commission_value = 1 in the strategy() declaration, meaning it will simulate a commission of 1% on all executed orders:\nstrategy(\n\"Commission Demo\", overlay=true, default_qty_value = 2, default_qty_type = strategy.percent_of_equity,\ncommission_type = strategy.commission.percent, commission_value = 1\nlength = input.int(10, \"Length\")\nfloat highest = ta.highest(close, length)\nfloat lowest = ta.lowest(close, length)\nswitch close\nhighest => strategy.entry(\"Long\", strategy.long)\nlowest => strategy.close(\"Long\")\nplot(highest, color = color.new(color.lime, 50))\nplot(lowest, color = color.new(color.red, 50))\nAs we can see in the example above, after applying a 1% commission to the backtest, the strategy simulated a significantly reduced net profit of only 1.42% and a more volatile equity curve with an elevated max drawdown, highlighting the impact commission simulation can have on a strategy’s test results.\nSlippage and unfilled limits¶\nIn real-life trading, a broker/exchange may fill orders at slightly different prices than a trader intended due to volatility, liquidity, order size, and other market factors, which can profoundly impact a strategy’s performance. The disparity between expected prices and the actual prices at which the broker/exchange executes trades is what we refer to as slippage. Slippage is dynamic and unpredictable, making it impossible to simulate precisely. However, factoring in a small amount of slippage on each trade during a backtest or forward test may help the results better align with reality. Users can model slippage in their strategy results, sized as a fixed number of ticks, by including a slippage argument in the strategy() declaration or by setting the “Slippage” input in the “Properties” tab of the strategy settings.\nThe following example demonstrates how slippage simulation affects the fill prices of market orders in a strategy test. The script below places a “Buy” market order of 2% equity when the market price is above an EMA while the EMA is rising and closes the position when the price dips below the EMA while it’s falling. We’ve included slippage = 20 in the strategy() function, which declares that the price of each simulated order will slip 20 ticks in the direction of the trade. The script uses strategy.opentrades.entry_bar_index() and strategy.closedtrades.exit_bar_index() to get the entryIndex and exitIndex, which it utilizes to obtain the fillPrice of the order. When the bar index is at the entryIndex, the fillPrice is the first strategy.opentrades.entry_price() value. At the exitIndex, fillPrice is the strategy.closedtrades.exit_price() value from the last closed trade. The script plots the expected fill price along with the simulated fill price after slippage to visually compare the difference:\nstrategy(\n\"Slippage Demo\", overlay = true, slippage = 20,\ndefault_qty_value = 2, default_qty_type = strategy.percent_of_equity\nint length = input.int(5, \"Length\")\n//@variable Exponential moving average with an input `length`.\nfloat ma = ta.ema(close, length)\n//@variable Returns `true` when `ma` has increased and `close` is greater than it, `false` otherwise.\nbool longCondition = close > ma and ma > ma[1]\n//@variable Returns `true` when `ma` has decreased and `close` is less than it, `false` otherwise.\nbool shortCondition = close < ma and ma < ma[1]\n// Enter a long market position on `longCondition`, close the position on `shortCondition`.\nif longCondition\nstrategy.entry(\"Buy\", strategy.long)\nif shortCondition\nstrategy.close(\"Buy\")\n//@variable The `bar_index` of the position's entry order fill.\nint entryIndex = strategy.opentrades.entry_bar_index(0)\n//@variable The `bar_index` of the position's close order fill.\nint exitIndex = strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1)\n//@variable The fill price simulated by the strategy.\nfloat fillPrice = switch bar_index\nentryIndex => strategy.opentrades.entry_price(0)\nexitIndex => strategy.closedtrades.exit_price(strategy.closedtrades - 1)\n//@variable The expected fill price of the open market position.\nfloat expectedPrice = fillPrice ? open : na\ncolor expectedColor = na\ncolor filledColor = na\nif bar_index == entryIndex\nexpectedColor := color.green\nfilledColor := color.blue\nelse if bar_index == exitIndex\nexpectedColor := color.red\nfilledColor := color.fuchsia\nplot(ma, color = color.new(color.orange, 50))\nplotchar(fillPrice ? open : na, \"Expected fill price\", \"—\", location.absolute, expectedColor)\nplotchar(fillPrice, \"Fill price after slippage\", \"—\", location.absolute, filledColor)\nSince the strategy applies constant slippage to all order fills, some orders can fill outside the candle range in the simulation. Thus users should exercise caution with this setting, as excessive simulated slippage can produce unrealistically worse testing results.\nSome traders may assume that they can avoid the adverse effects of slippage by using limit orders, as unlike market orders, they cannot execute at a worse price than the specified value. However, depending on the state of the real-life market, even if the market price reaches an order price, there’s a chance that a limit order may not fill, as limit orders can only fill if a security has sufficient liquidity and price action around the value. To account for the possibility of unfilled orders in a backtest, users can specify the backtest_fill_limits_assumption value in the declaration statement or use the “Verify price for limit orders” input in the “Properties” tab to instruct the strategy to fill limit orders only after prices move a defined number of ticks past order prices.\nThe following example places a limit order of 2% equity at a bar’s hlcc4 when the high is the highest value over the past length bars and there are no pending entries. The strategy closes the market position and cancels all orders when the low is the lowest value. Each time the strategy triggers an order, it draws a horizontal line at the limitPrice, which it updates on each bar until closing the position or canceling the order:\n\"Verify price for limits example\", overlay = true,\ndefault_qty_type = strategy.percent_of_equity, default_qty_value = 2\nint length = input.int(25, title = \"Length\")\n//@variable Draws a line at the limit price of the most recent entry order.\nvar line limitLine = na\n// Highest high and lowest low\nhighest = ta.highest(length)\nlowest = ta.lowest(length)\n// Place an entry order and draw a new line when the the `high` equals the `highest` value and `limitLine` is `na`.\nif high == highest and na(limitLine)\nfloat limitPrice = hlcc4\nstrategy.entry(\"Long\", strategy.long, limit = limitPrice)\nlimitLine := line.new(bar_index, limitPrice, bar_index + 1, limitPrice)\n// Close the open market position, cancel orders, and set `limitLine` to `na` when the `low` equals the `lowest` value.\nif low == lowest\nstrategy.cancel_all()\nlimitLine := na\nstrategy.close_all()\n// Update the `x2` value of `limitLine` if it isn't `na`.\nif not na(limitLine)\nlimitLine.set_x2(bar_index + 1)\nplot(highest, \"Highest High\", color = color.new(color.green, 50))\nplot(lowest, \"Lowest Low\", color = color.new(color.red, 50))\nBy default, the script assumes that all limit orders are guaranteed to fill. However, this is often not the case in real-life trading. Let’s add price verification to our limit orders to account for potentially unfilled ones. In this example, we’ve included backtest_fill_limits_assumption = 3 in the strategy() function call. As we can see, using limit verification omits some simulated order fills and changes the times of others since the entry orders can now only fill after the price penetrates the limit price by three ticks:\nIt’s important to notice that although the limit verification changed the times of some order fills, the strategy simulated them at the same prices. This “time-warping” effect is a compromise that preserves the prices of verified limit orders, but it can cause the strategy to simulate their fills at times that wouldn’t necessarily be possible in the real world. Users should exercise caution with this setting and understand its limitations when analyzing strategy results.\nRisk management¶\nDesigning a strategy that performs well, let alone one that does so in a broad class of markets, is a challenging task. Most are designed for specific market patterns/conditions and may produce uncontrollable losses when applied to other data. Therefore, a strategy’s risk management qualities can be critical to its performance. Users can set risk management criteria in their strategy scripts using the special commands with the strategy.risk prefix.\nStrategies can incorporate any number of risk management criteria in any combination. All risk management commands execute on every tick and order execution event, regardless of any changes to the strategy’s calculation behavior. There is no way to disable any of these commands at a script’s runtime. Irrespective of the risk rule’s location, it will always apply to the strategy unless the user removes the call from the code.\nstrategy.risk.allow_entry_in() This command overrides the market direction allowed for strategy.entry() commands. When a user specifies the trade direction with this function (e.g., strategy.direction.long), the strategy will only enter trades in that direction. However, it’s important to note that if a script calls an entry command in the opposite direction while there’s an open market position, the strategy will simulate a market order to exit the position. strategy.risk.max_cons_loss_days() This command cancels all pending orders, closes the open market position, and stops all additional trade actions after the strategy simulates a defined number of trading days with consecutive losses. strategy.risk.max_drawdown() This command cancels all pending orders, closes the open market position, and stops all additional trade actions after the strategy’s drawdown reaches the amount specified in the function call. strategy.risk.max_intraday_filled_orders() This command specifies the maximum number of filled orders per trading day (or per chart bar if the timeframe is higher than daily). Once the strategy executes the maximum number of orders for the day, it cancels all pending orders, closes the open market position, and halts trading activity until the end of the current session. strategy.risk.max_intraday_loss() This command controls the maximum loss the strategy will tolerate per trading day (or per chart bar if the timeframe is higher than daily). When the strategy’s losses reach this threshold, it will cancel all pending orders, close the open market position, and stop all trading activity until the end of the current session. strategy.risk.max_position_size() This command specifies the maximum possible position size when using strategy.entry() commands. If the quantity of an entry command results in a market position that exceeds this threshold, the strategy will reduce the order quantity so that the resulting position does not exceed the limitation. \nMargin¶\nMargin is the minimum percentage of a market position a trader must hold in their account as collateral to receive and sustain a loan from their broker to achieve their desired leverage. The margin_long and margin_short parameters of the strategy() declaration and the “Margin for long/short positions” inputs in the “Properties” tab of the script settings allow strategies to specify margin percentages for long and short positions. For example, if a trader sets the margin for long positions to 25%, they must have enough funds to cover 25% of an open long position. This margin percentage also means the trader can potentially spend up to 400% of their equity on their trades.\nIf a strategy’s simulated funds cannot cover the losses from a margin trade, the broker emulator triggers a margin call, which forcibly liquidates all or part of the position. The exact number of contracts/shares/lots/units that the emulator liquidates is four times what is required to cover a loss to prevent constant margin calls on subsequent bars. The emulator calculates the amount using the following algorithm:\nCalculate the amount of capital spent on the position: Money Spent = Quantity * Entry Price\nCalculate the Market Value of Security (MVS): MVS = Position Size * Current Price\nCalculate the Open Profit as the difference between MVS and Money Spent. If the position is short, we multiply this by -1.\nCalculate the strategy’s equity value: Equity = Initial Capital + Net Profit + Open Profit\nCalculate the margin ratio: Margin Ratio = Margin Percent / 100\nCalculate the margin value, which is the cash required to cover the trader’s portion of the position: Margin = MVS * Margin Ratio\nCalculate the available funds: Available Funds = Equity - Margin\nCalculate the total amount of money the trader has lost: Loss = Available Funds / Margin Ratio\nCalculate how many contracts/shares/lots/units the trader would need to liquidate to cover the loss. We truncate this value to the same decimal precision as the minimum position size for the current symbol: Cover Amount = TRUNCATE(Loss / Current Price).\nCalculate how many units the broker will liquidate to cover the loss: Margin Call = Cover Amount * 4\nTo examine this calculation in detail, let’s add the built-in Supertrend Strategy to the NASDAQ:TSLA chart on the 1D timeframe and set the “Order size” to 300% of equity and the “Margin for long positions” to 25% in the “Properties” tab of the strategy settings:\nThe first entry happened at the bar’s opening price on 16 Sep 2010. The strategy bought 682,438 shares (Position size) at 4.43 USD (Entry price). Then, on 23 Sep 2010, when the price dipped to 3.9 (Current price), the emulator forcibly liquidated 111,052 shares via margin call.\nMoney spent: 682438 * 4.43 = 3023200.34\nMVS: 682438 * 3.9 = 2661508.2\nOpen Profit: −361692.14\nEquity: 1000000 + 0 − 361692.14 = 638307.86\nMargin Ratio: 25 / 100 = 0.25\nMargin: 2661508.2 * 0.25 = 665377.05\nAvailable Funds: 638307.86 - 665377.05 = -27069.19\nMoney Lost: -27069.19 / 0.25 = -108276.76\nCover Amount: TRUNCATE(-108276.76 / 3.9) = TRUNCATE(-27763.27) = -27763\nMargin Call Size: -27763 * 4 = - 111052\nStrategy Alerts¶\nRegular Pine Script™ indicators have two different mechanisms to set up custom alert conditions: the alertcondition() function, which tracks one specific condition per function call, and the alert() function, which tracks all its calls simultaneously, but provides greater flexibility in the number of calls, alert messages, etc.\nPine Script™ strategies do not work with alertcondition() calls, but they do support the generation of custom alerts via the alert() function. Along with this, each function that creates orders also comes with its own built-in alert functionality that does not require any additional code to implement. As such, any strategy that uses an order placement command can issue alerts upon order execution. The precise mechanics of such built-in strategy alerts are described in the Order Fill events section of the Alerts page in our User Manual.\nWhen a strategy uses functions that create orders and the alert() function together, the alert creation dialogue provides a choice between the conditions that it will trigger upon: it can trigger on alert() events, order fill events, or both.\nFor many trading strategies, the latency between a triggered condition and a live trade can be a critical performance factor. By default, strategy scripts can only execute alert() function calls on the close of real-time bars, considering them to use alert.freq_once_per_bar_close, regardless of the freq argument in the call. Users can change the alert frequency by also including calc_on_every_tick = true in the strategy() call or selecting the “Recalculate on every tick” option in the “Properties” tab of the strategy settings before creating the alert. However, depending on the script, this may also adversely impact a strategy’s behavior, so exercise caution and be aware of the limitations when using this approach.\nWhen sending alerts to a third party for strategy automation, we recommend using order fill alerts rather than the alert() function since they don’t suffer the same limitations; alerts from order fill events execute immediately, unaffected by a script’s calc_on_every_tick setting. Users can set the default message for order fill alerts via the @strategy_alert_message compiler annotation. The text provided with this annotation will populate the “Message” field for order fills in the alert creation dialogue.\nThe following script shows a simple example of a default order fill alert message. Above the strategy() declaration statement, it uses @strategy_alert_message with placeholders for the trade action, position size, ticker, and fill price values in the message text:\n//@strategy_alert_message {{strategy.order.action}} {{strategy.position_size}} {{ticker}} @ {{strategy.order.price}}\nstrategy(\"Alert Message Demo\", overlay = true)\nfloat fastMa = ta.sma(close, 5)\nfloat slowMa = ta.sma(close, 10)\nif ta.crossover(fastMa, slowMa)\nif ta.crossunder(fastMa, slowMa)\nstrategy.entry(\"sell\", strategy.short)\nplot(fastMa, \"Fast MA\", color.aqua)\nplot(slowMa, \"Slow MA\", color.orange)\nThis script will populate the alert creation dialogue with its default message when the user selects its name from the “Condition” dropdown tab:\nUpon the alert trigger, the strategy will populate the placeholders in the alert message with their corresponding values. For example:\nNotes on testing strategies¶\nIt’s common for traders to test and tune their strategies in historical and real-time market conditions because many believe that analyzing the results may provide valuable insight into a strategy’s characteristics, potential weaknesses, and possibly its future potential. However, traders should always be aware of the biases and limitations of simulated strategy results, especially when using the results to support live trading decisions. This section outlines some caveats associated with strategy validation and tuning and possible solutions to mitigate their effects.\nWhile testing strategies on existing data may give traders helpful information about a strategy’s qualities, it’s important to note that neither the past nor the present guarantees the future. Financial markets can change rapidly and unpredictably, which may cause a strategy to sustain uncontrollable losses. Additionally, simulated results may not fully account for other real-world factors that can impact trading performance. Therefore, we recommend that traders thoroughly understand the limitations and risks when evaluating backtests and forward tests and consider them “parts of the whole” in their validation processes rather than basing decisions solely on the results.\nBacktesting and forward testing¶\nBacktesting is a technique that traders use to evaluate the historical performance of a trading strategy or model by simulating and analyzing its past results on historical market data; this technique assumes that analysis of a strategy’s results on past data may provide insight into its strengths and weaknesses. When backtesting, many traders tweak the parameters of a strategy in an attempt to optimize its results. Analysis and optimization of historical results may help traders to gain a deeper understanding of a strategy. However, traders should always understand the risks and limitations when basing their decisions on optimized backtest results.\nParallel to backtesting, prudent trading system development often also involves incorporating real-time analysis as a tool for evaluating a trading system on a forward-looking basis. Forward testing aims to gauge the performance of a strategy in real-time, real-world market conditions, where factors such as trading costs, slippage, and liquidity can meaningfully affect its performance. Forward testing has the distinct advantage of not being affected by certain types of biases (e.g., lookahead bias or “future data leakage”) but carries the disadvantage of being limited in the quantity of data to test. Therefore, it’s not typically a standalone solution for strategy validation, but it can provide helpful insights into a strategy’s performance in current market conditions.\nBacktesting and forward testing are two sides of the same coin, as both approaches aim to validate the effectiveness of a strategy and identify its strengths and weaknesses. By combining backtesting and forward testing, traders may be able to compensate for some limitations and gain a clearer perspective on their strategy’s performance. However, it’s up to traders to sanitize their strategies and evaluation processes to ensure that insights align with reality as closely as possible.\nLookahead bias¶\nOne typical issue in backtesting some strategies, namely ones that request alternate timeframe data, use repainting variables such as timenow, or alter calculation behavior for intrabar order fills, is the leakage of future data into the past during evaluation, which is known as lookahead bias. Not only is this bias a common cause of unrealistic strategy results since the future is never actually knowable beforehand, but it is also one of the typical causes of strategy repainting. Traders can often confirm this bias by forward testing their systems, as lookahead bias does not apply to real-time data where no known data exists beyond the current bar. Users can eliminate this bias in their strategies by ensuring that they don’t use repainting variables that leak the future into the past, request.*() functions don’t include barmerge.lookahead_on without offsetting the data series as described on this section of our page on repainting, and they use realistic calculation behavior.\nSelection bias¶\nSelection bias is a common issue that many traders experience when testing their strategies. It occurs when a trader only analyzes results on specific instruments or timeframes while ignoring others. This bias can result in a distorted perspective of the strategy’s robustness, which may impact trading decisions and performance optimizations. Traders can reduce the effects of selection bias by evaluating their strategies on multiple, ideally diverse, symbols and timeframes, making it a point not to ignore poor performance results in their analysis or cherry-pick testing ranges.\nOverfitting¶\nA common pitfall when optimizing a backtest is the potential for overfitting (“curve fitting”), which occurs when the strategy is tailored for specific data and fails to generalize well on new, unseen data. One widely-used approach to help reduce the potential for overfitting and promote better generalization is to split an instrument’s data into two or more parts to test the strategy outside the sample used for optimization, otherwise known as “in-sample” (IS) and “out-of-sample” (OOS) backtesting. In this approach, traders use the IS data for strategy optimization, while the OOS portion is used for testing and evaluating IS-optimized performance on new data without further optimization. While this and other, more robust approaches may provide a glimpse into how a strategy might fare after optimization, traders should exercise caution, as the future is inherently unknowable. No trading strategy can guarantee future performance, regardless of the data used for testing and optimization."
},
{
  "text": "Tables are objects that can be used to position information in specific and fixed locations in a script’s visual space. Contrary to all other plots or objects drawn in Pine Script™, tables are not anchored to specific bars; they float in a script’s space, whether in overlay or pane mode, in studies or strategies, independently of the chart bars being viewed or the zoom factor used.\nTables contain cells arranged in columns and rows, much like a spreadsheet. They are created and populated in two distincts steps:\nA table’s structure and key attributes are defined using table.new(), which returns a table ID that acts like a pointer to the table, just like label, line, or array IDs do. The table.new() call will create the table object but does not display it.\nOnce created, and for it to display, the table must be populated using one table.cell() call for each cell. Table cells can contain text, or not. This second step is when the width and height of cells are defined.\nMost attributes of a previously created table can be changed using table.set_*() setter functions. Attributes of previously populated cells can be modified using table.cell_set_*() functions.\nA table is positioned in an indicator’s space by anchoring it to one of nine references: the four corners or midpoints, including the center. Tables are positioned by expanding the table from its anchor, so a table anchored to the position.middle_right reference will be drawn by expanding up, down and left from that anchor.\nTwo modes are available to determine the width/height of table cells:\nA default automatic mode calculates the width/height of cells in a column/row using the widest/highest text in them.\nAn explicit mode allows programmers to define the width/height of cells using a percentage of the indicator’s available x/y space.\nDisplayed table contents always represent the last state of the table, as it was drawn on the script’s last execution, on the dataset’s last bar. Contrary to values displayed in the Data Window or in indicator values, variable contents displayed in tables will thus not change as a script user moves his cursor over specific chart bars. For this reason, it is strongly recommended to always restrict execution of all table.*() calls to either the first or last bars of the dataset. Accordingly:\nUse the var keyword to declare tables.\nEnclose all other calls inside an if barstate.islast block.\nMultiple tables can be used in one script, as long as they are each anchored to a different position. Each table object is identified by its own ID. Limits on the quantity of cells in all tables are determined by the total number of cells used in one script.\nCreating tables¶\nWhen creating a table using table.new(), three parameters are mandatory: the table’s position and its number of columns and rows. Five other parameters are optional: the table’s background color, the color and width of the table’s outer frame, and the color and width of the borders around all cells, excluding the outer frame. All table attributes except its number of columns and rows can be modified using setter functions: table.set_position(), table.set_bgcolor(), table.set_frame_color(), table.set_frame_width(), table.set_border_color() and table.set_border_width().\nTables can be deleted using table.delete(), and their content can be selectively removed using table.clear().\nWhen populating cells using table.cell(), you must supply an argument for four mandatory parameters: the table id the cell belongs to, its column and row index using indices that start at zero, and the text string the cell contains, which can be null. Seven other parameters are optional: the width and height of the cell, the text’s attributes (color, horizontal and vertical alignment, size), and the cell’s background color. All cell attributes can be modified using setter functions: table.cell_set_text(), table.cell_set_width(), table.cell_set_height(), table.cell_set_text_color(), table.cell_set_text_halign(), table.cell_set_text_valign(), table.cell_set_text_size() and table.cell_set_bgcolor().\nKeep in mind that each successive call to table.cell() redefines all the cell’s properties, deleting any properties set by previous table.cell() calls on the same cell.\nPlacing a single value in a fixed position¶\nLet’s create our first table, which will place the value of ATR in the upper-right corner of the chart. We first create a one-cell table, then populate that cell:\nindicator(\"ATR\", \"\", true)\n// We use `var` to only initialize the table on the first bar.\nvar table atrDisplay = table.new(position.top_right, 1, 1)\n// We call `ta.atr()` outside the `if` block so it executes on each bar.\nmyAtr = ta.atr(14)\nif barstate.islast\n// We only populate the table on the last bar.\ntable.cell(atrDisplay, 0, 0, str.tostring(myAtr))\nWe use the var keyword when creating the table with table.new().\nWe populate the cell inside an if barstate.islast block using table.cell().\nWhen populating the cell, we do not specify the width or height. The width and height of our cell will thus adjust automatically to the text it contains.\nWe call ta.atr(14) prior to entry in our if block so that it evaluates on each bar. Had we used str.tostring(ta.atr(14)) inside the if block, the function would not have evaluated correctly because it would be called on the dataset’s last bar without having calculated the necessary values from the previous bars.\nLet’s improve the usability and aesthethics of our script:\nindicator(\"ATR\", \"\", true)\natrPeriodInput = input.int(14, \"ATR period\", minval = 1, tooltip = \"Using a period of 1 yields True Range.\")\nvar table atrDisplay = table.new(position.top_right, 1, 1, bgcolor = color.gray, frame_width = 2, frame_color = color.black)\nmyAtr = ta.atr(atrPeriodInput)\nif barstate.islast\ntable.cell(atrDisplay, 0, 0, str.tostring(myAtr, format.mintick), text_color = color.white)\nWe used table.new() to define a background color, a frame color and its width.\nWhen populating the cell with table.cell(), we set the text to display in white.\nWe pass format.mintick as a second argument to the str.tostring() function to restrict the precision of ATR to the chart’s tick precision.\nWe now use an input to allow the script user to specify the period of ATR. The input also includes a tooltip, which the user can see when he hovers over the “i” icon in the script’s “Settings/Inputs” tab.\nColoring the chart’s background¶\nThis example uses a one-cell table to color the chart’s background on the bull/bear state of RSI:\nindicator(\"Chart background\", \"\", true)\nbullColorInput = input.color(color.new(color.green, 95), \"Bull\", inline = \"1\")\nbearColorInput = input.color(color.new(color.red, 95), \"Bear\", inline = \"1\")\n// ————— Function colors chart bg on RSI bull/bear state.\ncolorChartBg(bullColor, bearColor) =>\nvar table bgTable = table.new(position.middle_center, 1, 1)\nfloat r = ta.rsi(close, 20)\ncolor bgColor = r > 50 ? bullColor : r < 50 ? bearColor : na\ntable.cell(bgTable, 0, 0, width = 100, height = 100, bgcolor = bgColor)\ncolorChartBg(bullColorInput, bearColorInput)\nWe provide users with inputs allowing them to specify the bull/bear colors to use for the background, and send those input colors as arguments to our colorChartBg() function.\nWe create a new table only once, using the var keyword to declare the table.\nWe use table.cell() on the last bar only, to specify the cell’s properties. We make the cell the width and height of the indicator’s space, so it covers the whole chart.\nCreating a display panel¶\nTables are ideal to create sophisticated display panels. Not only do they make it possible for display panels to always be visible in a constant position, they provide more flexible formatting because each cell’s properties are controlled separately: background, text color, size and alignment, etc.\nHere, we create a basic display panel showing a user-selected quantity of MAs values. We display their period in the first column, then their value with a green/red/gray background that varies with price’s position with regards to each MA. When price is above/below the MA, the cell’s background is colored with the bull/bear color. When the MA falls between the current bar’s open and close, the cell’s background is of the neutral color:\nindicator(\"Price vs MA\", \"\", true)\nvar string GP1 = \"Moving averages\"\nint masQtyInput = input.int(20, \"Quantity\", minval = 1, maxval = 40, group = GP1, tooltip = \"1-40\")\nint masStartInput = input.int(20, \"Periods begin at\", minval = 2, maxval = 200, group = GP1, tooltip = \"2-200\")\nint masStepInput = input.int(20, \"Periods increase by\", minval = 1, maxval = 100, group = GP1, tooltip = \"1-100\")\nvar string GP2 = \"Display\"\nstring tableYposInput = input.string(\"top\", \"Panel position\", inline = \"11\", options = [\"top\", \"middle\", \"bottom\"], group = GP2)\nstring tableXposInput = input.string(\"right\", \"\", inline = \"11\", options = [\"left\", \"center\", \"right\"], group = GP2)\ncolor bullColorInput = input.color(color.new(color.green, 30), \"Bull\", inline = \"12\", group = GP2)\ncolor bearColorInput = input.color(color.new(color.red, 30), \"Bear\", inline = \"12\", group = GP2)\ncolor neutColorInput = input.color(color.new(color.gray, 30), \"Neutral\", inline = \"12\", group = GP2)\nvar table panel = table.new(tableYposInput + \"_\" + tableXposInput, 2, masQtyInput + 1)\n// Table header.\ntable.cell(panel, 0, 0, \"MA\", bgcolor = neutColorInput)\ntable.cell(panel, 1, 0, \"Value\", bgcolor = neutColorInput)\nint period = masStartInput\nfor i = 1 to masQtyInput\n// ————— Call MAs on each bar.\nfloat ma = ta.sma(close, period)\n// ————— Only execute table code on last bar.\n// Period in left column.\ntable.cell(panel, 0, i, str.tostring(period), bgcolor = neutColorInput)\n// If MA is between the open and close, use neutral color. If close is lower/higher than MA, use bull/bear color.\nbgColor = close > ma ? open < ma ? neutColorInput : bullColorInput : open > ma ? neutColorInput : bearColorInput\n// MA value in right column.\ntable.cell(panel, 1, i, str.tostring(ma, format.mintick), text_color = color.black, bgcolor = bgColor)\nperiod += masStepInput\nUsers can select the table’s position from the inputs, as well as the bull/bear/neutral colors to be used for the background of the right column’s cells.\nThe table’s quantity of rows is determined using the number of MAs the user chooses to display. We add one row for the column headers.\nEven though we populate the table cells on the last bar only, we need to execute the calls to ta.sma() on every bar so they produce the correct results. The compiler warning that appears when you compile the code can be safely ignored.\nWe separate our inputs in two sections using group, and join the relevant ones on the same line using inline. We supply tooltips to document the limits of certain fields using tooltip.\nDisplaying a heatmap¶\nOur next project is a heatmap, which will indicate the bull/bear relationship of the current price relative to its past values. To do so, we will use a table positioned at the bottom of the chart. We will display colors only, so our table will contain no text; we will simply color the background of its cells to produce our heatmap. The heatmap uses a user-selectable lookback period. It loops across that period to determine if price is above/below each bar in that past, and displays a progressively lighter intensity of the bull/bear color as we go further in the past:\nindicator(\"Price vs Past\", \"\", true)\nvar int MAX_LOOKBACK = 300\nint lookBackInput = input.int(150, minval = 1, maxval = MAX_LOOKBACK, step = 10)\ncolor bullColorInput = input.color(#00FF00ff, \"Bull\", inline = \"11\")\ncolor bearColorInput = input.color(#FF0080ff, \"Bear\", inline = \"11\")\n// ————— Function draws a heatmap showing the position of the current `_src` relative to its past `_lookBack` values.\ndrawHeatmap(src, lookBack) =>\n// float src : evaluated price series.\n// int lookBack: number of past bars evaluated.\n// Dependency: MAX_LOOKBACK\n// Force historical buffer to a sufficient size.\nmax_bars_back(src, MAX_LOOKBACK)\n// Only run table code on last bar.\nvar heatmap = table.new(position.bottom_center, lookBack, 1)\nfor i = 1 to lookBackInput\nfloat transp = 100. * i / lookBack\nif src > src[i]\ntable.cell(heatmap, lookBack - i, 0, bgcolor = color.new(bullColorInput, transp))\ntable.cell(heatmap, lookBack - i, 0, bgcolor = color.new(bearColorInput, transp))\ndrawHeatmap(high, lookBackInput)\nWe define a maximum lookback period as a MAX_LOOKBACK constant. This is an important value and we use it for two purposes: to specify the number of columns we will create in our one-row table, and to specify the lookback period required for the _src argument in our function, so that we force Pine Script™ to create a historical buffer size that will allow us to refer to the required quantity of past values of _src in our for loop.\nWe offer users the possibility of configuring the bull/bear colors in the inputs and we use inline to place the color selections on the same line.\nInside our function, we enclose our table-creation code in an if barstate.islast construct so that it only runs on the last bar of the chart.\nThe initialization of the table is done inside the if statement. Because of that, and the fact that it uses the var keyword, initialization only occurs the first time the script executes on a last bar. Note that this behavior is different from the usual var declarations in the script’s global scope, where initialization occurs on the first bar of the dataset, at bar_index zero.\nWe do not specify an argument to the text parameter in our table.cell() calls, so an empty string is used.\nWe calculate our transparency in such a way that the intensity of the colors decreases as we go further in history.\nWe use dynamic color generation to create different transparencies of our base colors as needed.\nContrary to other objects displayed in Pine scripts, this heatmap’s cells are not linked to chart bars. The configured lookback period determines how many table cells the heatmap contains, and the heatmap will not change as the chart is panned horizontally, or scaled.\nThe maximum number of cells that can be displayed in the scritp’s visual space will depend on your viewing device’s resolution and the portion of the display used by your chart. Higher resolution screens and wider windows will allow more table cells to be displayed."
},
{
  "text": "Timestamps can be formatted using str.format(). These are examples of various formats:\nprint(txt, styl) =>\nvar alignment = styl == label.style_label_right ? text.align_right : text.align_left\nvar lbl = label.new(na, na, \"\", xloc.bar_index, yloc.price, color(na), styl, color.black, size.large, alignment)\nlabel.set_xy(lbl, bar_index, hl2[1])\nlabel.set_text(lbl, txt)\nvar string format =\n\"{0,date,yyyy.MM.dd hh:mm:ss}\\n\" +\n\"{1,date,short}\\n\" +\n\"{2,date,medium}\\n\" +\n\"{3,date,long}\\n\" +\n\"{4,date,full}\\n\" +\n\"{5,date,h a z (zzzz)}\\n\" +\n\"{6,time,short}\\n\" +\n\"{7,time,medium}\\n\" +\n\"{8,date,'Month 'MM, 'Week' ww, 'Day 'DD}\\n\" +\n\"{9,time,full}\\n\" +\n\"{10,time,hh:mm:ss}\\n\" +\n\"{11,time,HH:mm:ss}\\n\" +\n\"{12,time,HH:mm:ss} Left in bar\\n\"\nprint(format, label.style_label_right)\nprint(str.format(format,\ntime, time, time, time, time, time, time,\ntimenow, timenow, timenow, timenow,\ntimenow - time, time_close - timenow), label.style_label_left)"
},
{
  "text": "Style guide¶\nNaming Conventions\nScript organization\n<license>\n<version>\n<declaration_statement>\n<import_statements>\n<constant_declarations>\n<inputs>\n<function_declarations>\n<calculations>\n<strategy_calls>\n<visuals>\n<alerts>\nSpacing\nLine wrapping\nVertical alignment\nExplicit typing\nThis style guide provides recommendations on how to name variables and organize your Pine scripts in a standard way that works well. Scripts that follow our best practices will be easier to read, understand and maintain.\nYou can see scripts using these guidelines published from the TradingView and PineCoders accounts on the platform.\nNaming Conventions¶\nWe recommend the use of:\ncamelCase for all identifiers, i.e., variable or function names: ma, maFast, maLengthInput, maColor, roundedOHLC(), pivotHi().\nAll caps SNAKE_CASE for constants: BULL_COLOR, BEAR_COLOR, MAX_LOOKBACK.\nThe use of qualifying suffixes when it provides valuable clues about the type or provenance of a variable: maShowInput, bearColor, bearColorInput, volumesArray, maPlotID, resultsTable, levelsColorArray.\nScript organization¶\nThe Pine Script™ compiler is quite forgiving of the positioning of specific statements or the version compiler annotation in the script. While other arrangements are syntactically correct, this is how we recommend organizing scripts:\n<license>\n<version>\n<declaration_statement>\n<import_statements>\n<constant_declarations>\n<inputs>\n<function_declarations>\n<calculations>\n<strategy_calls>\n<visuals>\n<alerts>\n<license>¶\nIf you publish your open-source scripts publicly on TradingView (scripts can also be published privately), your open-source code is by default protected by the Mozilla license. You may choose any other license you prefer.\nThe reuse of code from those scripts is governed by our House Rules on Script Publishing which preempt the author’s license.\nThe standard license comments appearing at the beginning of scripts are:\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// © username\n<version>¶\nThis is the compiler annotation defining the version of Pine Script™ the script will use. If none is present, v1 is used. For v5, use:\n<import_statements>¶\nIf your script uses one or more Pine Script™ libraries, your import statements belong here.\n<constant_declarations>¶\nScripts can declare variables qualified as “const”, i.e., ones referencing a constant value.\nWe refer to variables as “constants” when they meet these criteria:\nTheir declaration uses the optional const keyword (see our User Manual’s section on type qualifiers for more information).\nThey are initialized using a literal (e.g., 100 or \"AAPL\") or a built-in qualified as “const” (e.g., color.green).\nTheir value does not change during the script’s execution.\nWe use SNAKE_CASE to name these variables and group their declaration near the top of the script. For example:\n// ————— Constants\nint MS_IN_MIN = 60 * 1000\nint MS_IN_HOUR = MS_IN_MIN * 60\nint MS_IN_DAY = MS_IN_HOUR * 24\ncolor GRAY = #808080ff\ncolor LIME = #00FF00ff\ncolor MAROON = #800000ff\ncolor ORANGE = #FF8000ff\ncolor PINK = #FF0080ff\ncolor TEAL = #008080ff\ncolor BG_DIV = color.new(ORANGE, 90)\ncolor BG_RESETS = color.new(GRAY, 90)\nstring RST1 = \"No reset; cumulate since the beginning of the chart\"\nstring RST2 = \"On a stepped higher timeframe (HTF)\"\nstring RST3 = \"On a fixed HTF\"\nstring RST4 = \"At a fixed time\"\nstring RST5 = \"At the beginning of the regular session\"\nstring RST6 = \"At the first visible chart bar\"\nstring RST7 = \"Fixed rolling period\"\nstring LTF1 = \"Least precise, covering many chart bars\"\nstring LTF2 = \"Less precise, covering some chart bars\"\nstring LTF3 = \"More precise, covering less chart bars\"\nstring LTF4 = \"Most precise, 1min intrabars\"\nstring TT_TOTVOL = \"The 'Bodies' value is the transparency of the total volume candle bodies. Zero is opaque, 100 is transparent.\"\nstring TT_RST_HTF = \"This value is used when '\" + RST3 +\"' is selected.\"\nstring TT_RST_TIME = \"These values are used when '\" + RST4 +\"' is selected.\nA reset will occur when the time is greater or equal to the bar's open time, and less than its close time.\\nHour: 0-23\\nMinute: 0-59\"\nstring TT_RST_PERIOD = \"This value is used when '\" + RST7 +\"' is selected.\"\nIn this example:\nThe RST* and LTF* constants will be used as tuple elements in the options argument of input.*() calls.\nThe TT_* constants will be used as tooltip arguments in input.*() calls. Note how we use a line continuation for long string literals.\nWe do not use var to initialize constants. The Pine Script™ runtime is optimized to handle declarations on each bar, but using var to initialize a variable only the first time it is declared incurs a minor penalty on script performance because of the maintenance that var variables require on further bars.\nLiterals used in more than one place in a script should always be declared as a constant. Using the constant rather than the literal makes it more readable if it is given a meaningful name, and the practice makes code easier to maintain. Even though the quantity of milliseconds in a day is unlikely to change in the future, MS_IN_DAY is more meaningful than 1000 * 60 * 60 * 24.\nConstants only used in the local block of a function or if, while, etc., statement for example, can be declared in that local block.\n<inputs>¶\nIt is much easier to read scripts when all their inputs are in the same code section. Placing that section at the beginning of the script also reflects how they are processed at runtime, i.e., before the rest of the script is executed.\nSuffixing input variable names with input makes them more readily identifiable when they are used later in the script: maLengthInput, bearColorInput, showAvgInput, etc.\n// ————— Inputs\nstring resetInput = input.string(RST2, \"CVD Resets\", inline = \"00\", options = [RST1, RST2, RST3, RST4, RST5, RST6, RST7])\nstring fixedTfInput = input.timeframe(\"D\", \" Fixed HTF: \", tooltip = TT_RST_HTF)\nint hourInput = input.int(9, \" Fixed time hour: \", inline = \"01\", minval = 0, maxval = 23)\nint minuteInput = input.int(30, \"minute\", inline = \"01\", minval = 0, maxval = 59, tooltip = TT_RST_TIME)\nint fixedPeriodInput = input.int(20, \" Fixed period: \", inline = \"02\", minval = 1, tooltip = TT_RST_PERIOD)\nstring ltfModeInput = input.string(LTF3, \"Intrabar precision\", inline = \"03\", options = [LTF1, LTF2, LTF3, LTF4])\n<function_declarations>¶\nAll user-defined functions must be defined in the script’s global scope; nested function definitions are not allowed in Pine Script™.\nOptimal function design should minimize the use of global variables in the function’s scope, as they undermine function portability. When it can’t be avoided, those functions must follow the global variable declarations in the code, which entails they can’t always be placed in the <function_declarations> section. Such dependencies on global variables should ideally be documented in the function’s comments.\nIt will also help readers if you document the function’s objective, parameters and result. The same syntax used in libraries can be used to document your functions. This can make it easier to port your functions to a library should you ever decide to do so:\nindicator(\"<function_declarations>\", \"\", true)\nstring SIZE_LARGE = \"Large\"\nstring SIZE_NORMAL = \"Normal\"\nstring SIZE_SMALL = \"Small\"\nstring sizeInput = input.string(SIZE_NORMAL, \"Size\", options = [SIZE_LARGE, SIZE_NORMAL, SIZE_SMALL])\n// @function Used to produce an argument for the `size` parameter in built-in functions.\n// @param userSize (simple string) User-selected size.\n// @returns One of the `size.*` built-in constants.\n// Dependencies: SIZE_LARGE, SIZE_NORMAL, SIZE_SMALL\ngetSize(simple string userSize) =>\nresult =\nswitch userSize\nSIZE_LARGE => size.large\nSIZE_NORMAL => size.normal\nSIZE_SMALL => size.small\n=> size.auto\nif ta.rising(close, 3)\nlabel.new(bar_index, na, yloc = yloc.abovebar, style = label.style_arrowup, size = getSize(sizeInput))\n<calculations>¶\nThis is where the script’s core calculations and logic should be placed. Code can be easier to read when variable declarations are placed near the code segment using the variables. Some programmers prefer to place all their non-constant variable declarations at the beginning of this section, which is not always possible for all variables, as some may require some calculations to have been executed before their declaration.\n<strategy_calls>¶\nStrategies are easier to read when strategy calls are grouped in the same section of the script.\n<visuals>¶\nThis section should ideally include all the statements producing the script’s visuals, whether they be plots, drawings, background colors, candle-plotting, etc. See the Pine Script™ User Manual’s section on here for more information on how the relative depth of visuals is determined.\n<alerts>¶\nAlert code will usually require the script’s calculations to have executed before it, so it makes sense to put it at the end of the script.\nSpacing¶\nA space should be used on both sides of all operators, except unary operators (-1). A space is also recommended after all commas and when using named function arguments, as in plot(series = close):\nint a = close > open ? 1 : -1\nvar int newLen = 2\nnewLen := min(20, newlen + 1)\nfloat a = -b\nfloat c = d > e ? d - e : d\nint index = bar_index % 2 == 0 ? 1 : 2\nplot(close, color = color.red)\nLine wrapping¶\nLine wrapping can make long lines easier to read. Line wraps are defined by using an indentation level that is not a multiple of four, as four spaces or a tab are used to define local blocks. Here we use two spaces:\nplot(\nseries = close,\ntitle = \"Close\",\ncolor = color.blue,\nshow_last = 10\nVertical alignment¶\nVertical alignment using tabs or spaces can be useful in code sections containing many similar lines such as constant declarations or inputs. They can make mass edits much easier using the Pine Editor’s multi-cursor feature (ctrl + alt + 🠅/🠇):\n// Colors used as defaults in inputs.\ncolor COLOR_AQUA = #0080FFff\ncolor COLOR_BLACK = #000000ff\ncolor COLOR_BLUE = #013BCAff\ncolor COLOR_CORAL = #FF8080ff\ncolor COLOR_GOLD = #CCCC00ff\nExplicit typing¶\nIncluding the type of variables when declaring them is not required and is usually overkill for small scripts; we do not systematically use it. It can be useful to make the type of a function’s result clearer, and to distinguish a variable’s declaration (using =) from its reassignments (using :=). Using explicit typing can also make it easier for readers to find their way in larger scripts."
},
{
  "text": "Timeframes¶\nTimeframe string specifications\nComparing timeframes\nThe timeframe of a chart is sometimes also referred to as its interval or resolution. It is the unit of time represented by one bar on the chart. All standard chart types use a timeframe: “Bars”, “Candles”, “Hollow Candles”, “Line”, “Area” and “Baseline”. One non-standard chart type also uses timeframes: “Heikin Ashi”.\nProgrammers interested in accessing data from multiple timeframes will need to become familiar with how timeframes are expressed in Pine Script™, and how to use them.\nTimeframe strings come into play in different contexts:\nThey must be used in request.security() when requesting data from another symbol and/or timeframe. See the page on Other timeframes and data to explore the use of request.security().\nThey can be used as an argument to time() and time_close() functions, to return the time of a higher timeframe bar. This, in turn, can be used to detect changes in higher timeframes from the chart’s timeframe without using request.security(). See the Testing for changes in higher timeframes section to see how to do this.\nThe input.timeframe() function provides a way to allow script users to define a timeframe through a script’s “Inputs” tab (see the Timeframe input section for more information).\nThe indicator() declaration statement has an optional timeframe parameter that can be used to provide multi-timeframe capabilities to simple scripts without using request.security().\nMany built-in variables provide information on the timeframe used by the chart the script is running on. See the Chart timeframe section for more information on them, including timeframe.period which returns a string in Pine Script™’s timeframe specification format.\nTimeframe string specifications¶\nTimeframe strings follow these rules:\nThey are composed of the multiplier and the timeframe unit, e.g., “1S”, “30” (30 minutes), “1D” (one day), “3M” (three months).\nThe unit is represented by a single letter, with no letter used for minutes: “S” for seconds, “D” for days, “W” for weeks and “M” for months.\nWhen no multiplier is used, 1 is assumed: “S” is equivalent to “1S”, “D” to “1D, etc. If only “1” is used, it is interpreted as “1min”, since no unit letter identifier is used for minutes.\nThere is no “hour” unit; “1H” is not valid. The correct format for one hour is “60” (remember no unit letter is specified for minutes).\nThe valid multipliers vary for each timeframe unit:\nFor seconds, only the discrete 1, 5, 10, 15 and 30 multipliers are valid.\nFor minutes, 1 to 1440.\nFor days, 1 to 365.\nFor weeks, 1 to 52.\nFor months, 1 to 12.\nComparing timeframes¶\nIt can be useful to compare different timeframe strings to determine, for example, if the timeframe used on the chart is lower than the higher timeframes used in the script.\nConverting timeframe strings to a representation in fractional minutes provides a way to compare them using a universal unit. This script uses the timeframe.in_seconds() function to convert a timeframe into float seconds and then converts the result into minutes:\nindicator(\"Timeframe in minutes example\", \"\", true)\nstring tfInput = input.timeframe(defval = \"\", title = \"Input TF\")\nfloat chartTFInMinutes = timeframe.in_seconds() / 60\nfloat inputTFInMinutes = timeframe.in_seconds(tfInput) / 60\nvar table t = table.new(position.top_right, 1, 1)\nstring txt = \"Chart TF: \" + str.tostring(chartTFInMinutes, \"#.##### minutes\") +\n\"\\nInput TF: \" + str.tostring(inputTFInMinutes, \"#.##### minutes\")\nif barstate.isfirst\ntable.cell(t, 0, 0, txt, bgcolor = color.yellow)\nelse if barstate.islast\ntable.cell_set_text(t, 0, 0, txt)\nif chartTFInMinutes > inputTFInMinutes\nruntime.error(\"The chart's timeframe must not be higher than the input's timeframe.\")\nWe use the built-in timeframe.in_seconds() function to convert the chart and the input.timeframe() function into seconds, then divide by 60 to convert into minutes.\nWe use two calls to the timeframe.in_seconds() function in the initialization of the chartTFInMinutes and inputTFInMinutes variables. In the first instance, we do not supply an argument for its timeframe parameter, so the function returns the chart’s timeframe in seconds. In the second call, we supply the timeframe selected by the script’s user through the call to input.timeframe().\nNext, we validate the timeframes to ensure that the input timeframe is equal to or higher than the chart’s timeframe. If it is not, we generate a runtime error.\nWe finally print the two timeframe values converted to minutes."
},
{
  "text": "Text and shapes¶\n`plotchar()`\n`plotshape()`\n`plotarrow()`\nLabels\nCreating and modifying labels\nPositioning labels\nReading label properties\nCloning labels\nDeleting labels\nRealtime behavior\nYou may display text or shapes using five different ways with Pine Script™:\nplotchar()\nplotshape()\nplotarrow()\nLabels created with label.new()\nTables created with table.new() (see Tables)\nWhich one to use depends on your needs:\nTables can display text in various relative positions on charts that will not move as users scroll of zoom the chart horizontally. Their content is not tethered to bars. In contrast, text displayed with plotchar(), plotshape() or label.new() is always tethered to a specific bar, so it will move with the bar’s position on the chart. See the page on Tables for more information on them.\nThree function include are able to display pre-defined shapes: plotshape(), plotarrow() and Labels created with label.new().\nplotarrow() cannot display text, only up or down arrows.\nplotchar() and plotshape() can display non-dynamic text on any bar or all bars of the chart.\nplotchar() can only display one character while plotshape() can display strings, including line breaks.\nlabel.new() can display a maximum of 500 labels on the chart. Its text can contain dynamic text, or “series strings”. Line breaks are also supported in label text.\nWhile plotchar() and plotshape() can display text at a fixed offset in the past or the future, which cannot change during the script’s execution, each label.new() call can use a “series” offset that can be calculated on the fly.\nThese are a few things to keep in mind concerning Pine Script™ strings:\nSince the text parameter in both plotchar() and plotshape() require a “const string” argument, it cannot contain values such as prices that can only be known on the bar (“series string”).\nTo include “series” values in text displayed using label.new(), they will first need to be converted to strings using str.tostring().\nThe concatenation operator for strings in Pine is +. It is used to join string components into one string, e.g., msg = \"Chart symbol: \" + syminfo.tickerid (where syminfo.tickerid is a built-in variable that returns the chart’s exchange and symbol information in string format).\nCharacters displayed by all these functions can be Unicode characters, which may include Unicode symbols. See this Exploring Unicode script to get an idea of what can be done with Unicode characters.\nThe color or size of text can sometimes be controlled using function parameters, but no inline formatting (bold, italics, monospace, etc.) is possible.\nText from Pine scripts always displays on the chart in the Trebuchet MS font, which is used in many TradingView texts, including this one.\nThis script displays text using the four methods available in Pine Script™:\nindicator(\"Four displays of text\", overlay = true)\nplotchar(ta.rising(close, 5), \"`plotchar()`\", \"🠅\", location.belowbar, color.lime, size = size.small)\nplotshape(ta.falling(close, 5), \"`plotchar()`\", location = location.abovebar, color = na, text = \"•`plotshape()•`\\n🠇\", textcolor = color.fuchsia, size = size.huge)\nif bar_index % 25 == 0\nlabel.new(bar_index, na, \"•LABEL•\\nHigh = \" + str.tostring(high, format.mintick) + \"\\n🠇\", yloc = yloc.abovebar, style = label.style_none, textcolor = color.black, size = size.normal)\nprintTable(txt) => var table t = table.new(position.middle_right, 1, 1), table.cell(t, 0, 0, txt, bgcolor = color.yellow)\nprintTable(\"•TABLE•\\n\" + str.tostring(bar_index + 1) + \" bars\\nin the dataset\")\nThe method used to display each text string is shown with the text, except for the lime up arrows displayed using plotchar(), as it can only display one character.\nLabel and table calls can be inserted in conditional structures to control when their are executed, whereas plotchar() and plotshape() cannot. Their conditional plotting must be controlled using their first argument, which is a “series bool” whose true or false value determines when the text is displayed.\nNumeric values displayed in the table and labels is first converted to a string using str.tostring().\nWe use the + operator to concatenate string components.\nplotshape() is designed to display a shape with accompanying text. Its size parameter controls the size of the shape, not of the text. We use na for its color argument so that the shape is not visible.\nContrary to other texts, the table text will not move as you scroll or scale the chart.\nSome text strings contain the 🠇 Unicode arrow (U+1F807).\nSome text strings contain the \\n sequence that represents a new line.\n`plotchar()`¶\nThis function is useful to display a single character on bars. It has the following syntax:\nplotchar(series, title, char, location, color, offset, text, textcolor, editable, size, show_last, display) → void\nSee the Reference Manual entry for plotchar() for details on its parameters.\nAs explained in the When the script’s scale must be preserved section of our page on Debugging, the function can be used to display and inspect values in the Data Window or in the indicator values displayed to the right of the script’s name on the chart:\nplotchar(bar_index, \"Bar index\", \"\", location.top)\nThe cursor is on the chart’s last bar.\nThe value of bar_index on that bar is displayed in indicator values (1) and in the Data Window (2).\nWe use location.top because the default location.abovebar will put the price into play in the script’s scale, which will often interfere with other plots.\nplotchar() also works well to identify specific points on the chart or to validate that conditions are true when we expect them to be. This example displays an up arrow under bars where close, high and volume have all been rising for two bars:\nbool longSignal = ta.rising(close, 2) and ta.rising(high, 2) and (na(volume) or ta.rising(volume, 2))\nplotchar(longSignal, \"Long\", \"▲\", location.belowbar, color = na(volume) ? color.gray : color.blue, size = size.tiny)\nWe use (na(volume) or ta.rising(volume, 2)) so our script will work on symbols without volume data. If we did not make provisions for when there is no volume data, which is what na(volume) does by being true when there is no volume, the longSignal variable’s value would never be true because ta.rising(volume, 2) yields false in those cases.\nWe display the arrow in gray when there is no volume, to remind us that all three base conditions are not being met.\nBecause plotchar() is now displaying a character on the chart, we use size = size.tiny to control its size.\nWe have adapted the location argument to display the character under bars.\nIf you don’t mind plotting only circles, you could also use plot() to achieve a similar effect:\nlongSignal = ta.rising(close, 2) and ta.rising(high, 2) and (na(volume) or ta.rising(volume, 2))\nplot(longSignal ? low - ta.tr : na, \"Long\", color.blue, 2, plot.style_circles)\nThis method has the inconvenience that, since there is no relative positioning mechanism with plot() one must shift the circles down using something like ta.tr (the bar’s “True Range”):\n`plotshape()`¶\nThis function is useful to display pre-defined shapes and/or text on bars. It has the following syntax:\nplotshape(series, title, style, location, color, offset, text, textcolor, editable, size, show_last, display) → void\nSee the Reference Manual entry for plotshape() for details on its parameters.\nLet’s use the function to achieve more or less the same result as with our second example of the previous section:\nlongSignal = ta.rising(close, 2) and ta.rising(high, 2) and (na(volume) or ta.rising(volume, 2))\nplotshape(longSignal, \"Long\", shape.arrowup, location.belowbar)\nNote that here, rather than using an arrow character, we are using the shape.arrowup argument for the style parameter.\nIt is possible to use different plotshape() calls to superimpose text on bars. You will need to use \\n followed by a special non-printing character that doesn’t get stripped out to preserve the newline’s functionality. Here we’re using a Unicode Zero-width space (U+200E). While you don’t see it in the following code’s strings, it is there and can be copy/pasted. The special Unicode character needs to be the last one in the string for text going up, and the first one when you are plotting under the bar and text is going down:\nindicator(\"Lift text\", \"\", true)\nplotshape(true, \"\", shape.arrowup, location.abovebar, color.green, text = \"A\")\nplotshape(true, \"\", shape.arrowup, location.abovebar, color.lime, text = \"B\\n​\")\nplotshape(true, \"\", shape.arrowdown, location.belowbar, color.red, text = \"C\")\nplotshape(true, \"\", shape.arrowdown, location.belowbar, color.maroon, text = \"​\\nD\")\nThe available shapes you can use with the style parameter are:\n`plotarrow()`¶\nThe plotarrow function displays up or down arrows of variable length, based on the relative value of the series used in the function’s first argument. It has the following syntax:\nplotarrow(series, title, colorup, colordown, offset, minheight, maxheight, editable, show_last, display) → void\nSee the Reference Manual entry for plotarrow() for details on its parameters.\nThe series parameter in plotarrow() is not a “series bool” as in plotchar() and plotshape(); it is a “series int/float” and there’s more to it than a simple true or false value determining when the arrows are plotted. This is the logic governing how the argument supplied to series affects the behavior of plotarrow():\nseries > 0: An up arrow is displayed, the length of which will be proportional to the relative value of the series on that bar in relation to other series values.\nseries < 0: A down arrow is displayed, proportionally-sized using the same rules.\nseries == 0 or na(series): No arrow is displayed.\nThe maximum and minimum possible sizes for the arrows (in pixels) can be controlled using the minheight and maxheight parameters.\nHere is a simple script illustrating how plotarrow() works:\nbody = close - open\nplotarrow(body, colorup = color.teal, colordown = color.orange)\nNote how the heigth of arrows is proportional to the relative size of the bar bodies.\nYou can use any series to plot the arrows. Here we use the value of the “Chaikin Oscillator” to control the location and size of the arrows:\nindicator(\"Chaikin Oscillator Arrows\", overlay = true)\nfastLengthInput = input.int(3, minval = 1)\nslowLengthInput = input.int(10, minval = 1)\nosc = ta.ema(ta.accdist, fastLengthInput) - ta.ema(ta.accdist, slowLengthInput)\nplotarrow(osc)\nNote that we display the actual “Chaikin Oscillator” in a pane below the chart, so you can see what values are used to determine the position and size of the arrows.\nLabels¶\nLabels are only available in v4 and higher versions of Pine Script™. They work very differently than plotchar() and plotshape().\nLabels are objects, like lines and boxes, or tables. Like them, they are referred to using an ID, which acts like a pointer. Label IDs are of “label” type. As with other objects, labels IDs are “time series” and all the functions used to manage them accept “series” arguments, which makes them very flexible.\nOn TradingView charts, a complete set of Drawing Tools allows users to create and modify drawings using mouse actions. While they may sometimes look similar to drawing objects created with Pine Script™ code, they are unrelated entities. Drawing objects created using Pine code cannot be modified with mouse actions, and hand-drawn drawings from the chart user interface are not visible from Pine scripts.\nLabels are advantageous because:\nThey allow “series” values to be converted to text and placed on charts. This means they are ideal to display values that cannot be known before time, such as price values, support and resistance levels, of any other values that your script calculates.\nTheir positioning options are more flexible that those of the plot*() functions.\nThey offer more display modes.\nContrary to plot*() functions, label-handling functions can be inserted in conditional or loop structures, making it easier to control their behavior.\nYou can add tooltips to labels.\nOne drawback to using labels versus plotchar() and plotshape() is that you can only draw a limited quantity of them on the chart. The default is ~50, but you can use the max_labels_count parameter in your indicator() or strategy() declaration statement to specify up to 500. Labels, like lines and boxes, are managed using a garbage collection mechanism which deletes the oldest ones on the chart, such that only the most recently drawn labels are visible.\nYour toolbox of built-ins to manage labels are all in the label namespace. They include:\nlabel.new() to create labels.\nlabel.set_*() functions to modify the properties of an existing label.\nlabel.get_*() functions to read the properties of an existing label.\nlabel.delete() to delete labels\nThe label.all array which always contains the IDs of all the visible labels on the chart. The array’s size will depend on the maximum label count for your script and how many of those you have drawn. aray.size(label.all) will return the array’s size.\nCreating and modifying labels¶\nThe label.new() function creates a new label. It has the following signature:\nlabel.new(x, y, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip) → series label\nThe setter functions allowing you to change a label’s properties are:\nlabel.set_x()\nlabel.set_y()\nlabel.set_xy()\nlabel.set_text()\nlabel.set_xloc()\nlabel.set_yloc()\nlabel.set_color()\nlabel.set_style()\nlabel.set_textcolor()\nlabel.set_size()\nlabel.set_textalign()\nlabel.set_tooltip()\nThey all have a similar signature. The one for label.set_color() is:\nlabel.set_color(id, color) → void\nwhere:\nid is the ID of the label whose property is to be modified.\nThe next parameter is the property of the label to modify. It depends on the setter function used. label.set_xy() changes two properties, so it has two such parameters.\nThis is how you can create labels in their simplest form:\nlabel.new(bar_index, high)\nThe label is created with the parameters x = bar_index (the index of the current bar, bar_index) and y = high (the bar’s high value).\nWe do not supply an argument for the function’s text parameter. Its default value being an empty string, no text is displayed.\nNo logic controls our label.new() call, so labels are created on every bar.\nOnly the last 54 labels are displayed because our indicator() call does not use the max_labels_count parameter to specify a value other than the ~50 default.\nLabels persist on bars until your script deletes them using label.delete(), or garbage collection removes them.\nIn the next example we display a label on the bar with the highest high value in the last 50 bars:\n// Find the highest `high` in last 50 bars and its offset. Change it's sign so it is positive.\nLOOKBACK = 50\nhi = ta.highest(LOOKBACK)\nhighestBarOffset = - ta.highestbars(LOOKBACK)\n// Create label on bar zero only.\nvar lbl = label.new(na, na, \"\", color = color.orange, style = label.style_label_lower_left)\n// When a new high is found, move the label there and update its text and tooltip.\nif ta.change(hi)\n// Build label and tooltip strings.\nlabelText = \"High: \" + str.tostring(hi, format.mintick)\ntooltipText = \"Offest in bars: \" + str.tostring(highestBarOffset) + \"\\nLow: \" + str.tostring(low[highestBarOffset], format.mintick)\n// Update the label's position, text and tooltip.\nlabel.set_xy(lbl, bar_index[highestBarOffset], hi)\nlabel.set_text(lbl, labelText)\nlabel.set_tooltip(lbl, tooltipText)\nWe create the label on the first bar only by using the var keyword to declare the lbl variable that contains the label’s ID. The x, y and text arguments in that label.new() call are irrelevant, as the label will be updated on further bars. We do, however, take care to use the color and style we want for the labels, so they don’t need updating later.\nOn every bar, we detect if a new high was found by testing for changes in the value of hi\nWhen a change in the high value occurs, we update our label with new information. To do this, we use three label.set*() calls to change the label’s relevant information. We refer to our label using the lbl variable, which contains our label’s ID. The script is thus maintaining the same label throughout all bars, but moving it and updating its information when a new high is detected.\nHere we create a label on each bar, but we set its properties conditionally, depending on the bar’s polarity:\nlbl = label.new(bar_index, na)\nif close >= open\nlabel.set_text( lbl, \"green\")\nlabel.set_color(lbl, color.green)\nlabel.set_yloc( lbl, yloc.belowbar)\nlabel.set_style(lbl, label.style_label_up)\nlabel.set_text( lbl, \"red\")\nlabel.set_color(lbl, color.red)\nlabel.set_yloc( lbl, yloc.abovebar)\nlabel.set_style(lbl, label.style_label_down)\nPositioning labels¶\nLabels are positioned on the chart according to x (bars) and y (price) coordinates. Five parameters affect this behavior: x, y, xloc, yloc and style:\nx Is either a bar index or a time value. When a bar index is used, the value can be offset in the past or in the future (maximum of 500 bars in the future). Past or future offsets can also be calculated when using time values. The x value of an existing label can be modified using label.set_x() or label.set_xy(). xloc Is either xloc.bar_index (the default) or xloc.bar_time. It determines which type of argument must be used with x. With xloc.bar_index, x must be an absolute bar index. With xloc.bar_time, x must be a UNIX time in milliseconds corresponding to the time value of a bar’s open. The xloc value of an existing label can be modified using label.set_xloc(). y Is the price level where the label is positioned. It is only taken into account with the default yloc value of yloc.price. If yloc is yloc.abovebar or yloc.belowbar then the y argument is ignored. The y value of an existing label can be modified using label.set_y() or label.set_xy(). yloc Can be yloc.price (the default), yloc.abovebar or yloc.belowbar. The argument used for y is only taken into account with yloc.price. The yloc value of an existing label can be modified using label.set_yloc(). style The argument used has an impact on the visual appearance of the label and on its position relative to the reference point determined by either the y value or the top/bottom of the bar when yloc.abovebar or yloc.belowbar are used. The style of an existing label can be modified using label.set_style(). \nThese are the available style arguments:\nWhen using xloc.bar_time, the x value must be a UNIX timestamp in milliseconds. See the page on Time for more information. The start time of the current bar can be obtained from the time built-in variable. The bar time of previous bars is time[1], time[2] and so on. Time can also be set to an absolute value with the timestamp function. You may add or subtract periods of time to achieve relative time offset.\nLet’s position a label one day ago from the date on the last bar:\ndaysAgoInput = input.int(1, tooltip = \"Use negative values to offset in the future\")\nMS_IN_ONE_DAY = 24 * 60 * 60 * 1000\noneDayAgo = time - (daysAgoInput * MS_IN_ONE_DAY)\nlabel.new(oneDayAgo, high, xloc = xloc.bar_time, style = label.style_label_right)\nNote that because of varying time gaps and missing bars when markets are closed, the positioning of the label may not always be exact. Time offsets of the sort tend to be more reliable on 24x7 markets.\nYou can also offset using a bar index for the x value, e.g.:\nlabel.new(bar_index + 10, high)\nlabel.new(bar_index - 10, high[10])\nlabel.new(bar_index[10], high[10])\nDeleting labels¶\nThe label.delete() function is used to delete labels. Its syntax is:\nTo keep only a user-defined quantity of labels on the chart, one could use code like this:\nMAX_LABELS = 500\nindicator(\"\", max_labels_count = MAX_LABELS)\nqtyLabelsInput = input.int(5, \"Labels to keep\", minval = 0, maxval = MAX_LABELS)\nmyRSI = ta.rsi(close, 20)\nif myRSI > ta.highest(myRSI, 20)[1]\nlabel.new(bar_index, myRSI, str.tostring(myRSI, \"#.00\"), style = label.style_none)\nif array.size(label.all) > qtyLabelsInput\nlabel.delete(array.get(label.all, 0))\nplot(myRSI)\nWe define a MAX_LABELS constant to hold the maximum quantity of labels a script can accommodate. We use that value to set the max_labels_count parameter’s value in our indicator() call, and also as the maxval value in our input.int() call to cap the user value.\nWe create a new label when our RSI breaches its highest value of the last 20 bars. Note the offset of [1] we use in if myRSI > ta.highest(myRSI, 20)[1]. This is necessary. Without it, the value returned by ta.highest() would always include the current value of myRSI, so myRSI would never be higher than the function’s return value.\nAfter that, we delete the oldest label in the label.all array that is automatically maintained by the Pine Script™ runtime and contains the ID of all the visible labels drawn by our script. We use the array.get() function to retrieve the array element at index zero (the oldest visible label ID). We then use label.delete() to delete the label linked with that ID.\nNote that if one wants to position a label on the last bar only, it is unnecessary and inefficent to create and delete the label as the script executes on all bars, so that only the last label remains:\n// INEFFICENT!\nlbl = label.new(bar_index, high, str.tostring(high, format.mintick))\nlabel.delete(lbl[1])\nThis is the efficient way to realize the same task:\n// Create the label once, the first time the block executes on the last bar.\nvar lbl = label.new(na, na)\n// On all iterations of the script on the last bar, update the label's information.\nlabel.set_xy(lbl, bar_index, high)\nlabel.set_text(lbl, str.tostring(high, format.mintick))\nRealtime behavior¶\nLabels are subject to both commit and rollback actions, which affect the behavior of a script when it executes in the realtime bar. See the page on Pine Script™’s Execution model.\nThis script demonstrates the effect of rollback when running in the realtime bar:\nlabel.new(bar_index, high)\nOn realtime bars, label.new() creates a new label on every script update, but because of the rollback process, the label created on the previous update on the same bar is deleted. Only the last label created before the realtime bar’s close will be committed, and thus persist."
},
{
  "text": "Debugging¶\nThe lay of the land\nDisplaying numeric values\nWhen the script’s scale is unimportant\nWhen the script’s scale must be preserved\nDisplaying strings\nLabels on each bar\nLabels on last bar\nDebugging conditions\nSingle conditions\nCompound conditions\nDebugging from inside functions\nDebugging from inside `for` loops\nExtracting a single value\nUsing lines and labels\nExtracting multiple values\nTips\nTradingView’s close integration between the Pine Script™ Editor and charts allows for efficient and interactive debugging of Pine Script™ code. Once a programmer understands the most appropriate technique to use in each situation, they will be able to debug scripts quickly and thoroughly. This page demonstrates the most useful techniques to debug Pine Script™ code.\nIf you are not yet familiar with Pine Script™’s execution model, it is important that you read the Execution model page of this User Manual so you understand how your debugging code will behave in the Pine Script™ environment.\nThe lay of the land¶\nValues plotted by Pine scripts can be displayed in four distinct places:\nNext to the script’s name (controlled by the “Indicator Values” checkbox in the “Chart settings/Status Line” tab).\nIn the script’s pane, whether your script is a chart overlay or in a separate pane.\nIn the scale (only displays the last bar’s value and is controlled by the “Indicator Last Value Label” checkbox in the “Chart settings/Scale” tab).\nIn the Data Window (which you can bring up using the fourth icon down, to the right of your chart).\nNote the following in the preceding screenshot:\nThe chart’s cursor is on the dataset’s first bar, where bar_index is zero. That value is reflected next to the indicator’s name and in the Data Window. Moving your cursor on other bars would update those values so they always represent the value of the plot on that bar. This is a good way to inspect the value of a variable as the script’s execution progresses from bar to bar.\nThe title argument of our plot() call, “Bar Index”, is used as the value’s legend in the Data Window.\nThe precision of the values displayed in the Data Window is dependent on the chart symbol’s tick value. You can modify it in two ways:\nBy changing the value of the “Precision” field in the script’s “Settings/Style” tab. You can obtain up to eight digits of precision using this method.\nBy using the precision parameter in your script’s indicator() or strategy() declaration statement. This method allows specifying up to 16 digits precision.\nThe plot() call in our script plots the value of bar_index in the indicator’s pane, which shows the increasing value of the variable.\nThe scale of the script’s pane is automatically sized to accommodate the smallest and largest values plotted by all plot() calls in the script.\nDisplaying numeric values¶\nWhen the script’s scale is unimportant¶\nThe script in the preceding screenshot used the simplest way to inspect numerical values: a plot() call, which plots a line corresponding to the variable’s value in the script’s display area. Our example script plotted the value of the bar_index built-in variable, which contains the bar’s number, a value beginning at zero on the dataset’s first bar and increased by one on each subsequent bar. We used a plot() call to plot the variable to inspect because our script was not plotting anything else; we were not preoccupied with preserving the scale for other plots to continue to plot normally. This is the script we used:\nindicator(\"Plot `bar_index`\")\nplot(bar_index, \"Bar Index\")\nWhen the script’s scale must be preserved¶\nPlotting values in the script’s display area is not always possible. When we already have other plots going on and adding debugging plots of variables whose values fall outside the script’s plotting boundaries would make the plots unreadable, another technique must be used to inspect values if we want to preserve the scale of the other plots.\nSuppose we want to continue inspecting the value of bar_index, but this time in a script where we are also plotting RSI:\nindicator(\"Plot RSI and `bar_index`\")\nr = ta.rsi(close, 20)\nplot(r, \"RSI\", color.black)\nplot(bar_index, \"Bar Index\")\nRunning the script on a dataset containing a large number of bars yields the following display:\nwhere:\nThe RSI line in black is flat because it varies between zero and 100, but the indicator’s pane is scaled to show the maximum value of bar_index, which is 25692.0000.\nThe value of bar_index on the bar the cursor is on is displayed next to the indicator’s name, and its blue plot in the script’s pane is flat.\nThe 25692.0000 value of bar_index shown in the scale represents its value on the last bar, so the dataset contains 25693 bars.\nThe value of bar_index on the bar the cursor is on is also displayed in the Data Window, along with that bar’s value for RSI just above it.\nIn order to preserve our plot of RSI while still being able to inspect the value or bar_index, we will plot the variable using plotchar() like this:\nindicator(\"Plot RSI and `bar_index`\")\nr = ta.rsi(close, 20)\nplot(r, \"RSI\", color.black)\nplotchar(bar_index, \"Bar index\", \"\", location.top)\nwhere:\nBecause the value of bar_index is no longer being plotted in the script’s pane, the pane’s boundaries are now those of RSI, which displays normally.\nThe value plotted using plotchar() is displayed next to the script’s name and in the Data Window.\nWe are not plotting a character with our plotchar() call, so the third argument is an empty string (\"\"). We are also specifying location.top as the location argument, so that we do not put the symbol’s price in play in the calculation of the display area’s boundaries.\nDisplaying strings¶\nPine Script™ labels must be used to display strings. Labels only appear in the script’s display area; strings shown in labels do not appear in the Data Window or anywhere else.\nLabels on each bar¶\nThe following script demonstrates the simplest way to repetitively draw a label showing the symbol’s name:\nindicator(\"Simple label\", \"\", true)\nlabel.new(bar_index, high, syminfo.ticker)\nBy default, only the last 50 labels will be shown on the chart. You can increase this amount up to a maximum of 500 by using the max_labels_count parameter in your script’s indicator() or strategy() declaration statement. For example:\nindicator(\"Simple label\", \"\", true, max_labels_count = 500)\nLabels on last bar¶\nAs strings manipulated in Pine scripts often do not change bar to bar, the method most frequently used to visualize them is to draw a label on the dataset’s last bar. Here, we use a function to create a label that only appears on the chart’s last bar. Our f_print() function has only one parameter, the text string to be displayed:\nindicator(\"print()\", \"\", true)\nprint(txt) =>\n// Create label on the first bar.\nvar lbl = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, color.gray, size.large, text.align_left)\n// On next bars, update the label's x and y position, and the text it displays.\nlabel.set_xy(lbl, bar_index, ta.highest(10)[1])\nlabel.set_text(lbl, txt)\nprint(\"Multiplier = \" + str.tostring(timeframe.multiplier) + \"\\nPeriod = \" + timeframe.period + \"\\nHigh = \" + str.tostring(high))\nprint(\"Hello world!\\n\\n\\n\\n\")\nNote the following in our last code example:\nWe use the print() function to enclose the label-drawing code. While the function is called on each bar, the label is only created on the dataset’s first bar because of our use of the var keyword when declaring the lbl variable inside the function. After creating it, we only update the label’s x and y coordinates and its text on each successive bar. If we did not update those values, the label would remain on the dataset’s first bar and would only display the text string’s value on that bar. Lastly, note that we use ta.highest(10)[1] to position the label vertically, By using the highest high of the previous 10 bars, we prevent the label from moving during the realtime bar. You may need to adapt this y position in other contexts.\nWe call the print() function twice to show that if you make multiple calls because it makes debugging multiple strings easier, you can superimpose their text by using the correct amount of newlines (\\n) to separate each one.\nWe use the str.tostring() function to convert numeric values to a string for inclusion in the text to be displayed.\nDebugging conditions¶\nSingle conditions¶\nMany methods can be used to display occurrences where a condition is met. This code shows six ways to identify bars where RSI is smaller than 30:\nindicator(\"Single conditions\")\nr = ta.rsi(close, 20)\nrIsLow = r < 30\nhline(30)\n// Method #1: Change the plot's color.\nplot(r, \"RSI\", rIsLow ? color.fuchsia : color.black)\n// Method #2: Plot a character in the bottom region of the display.\nplotchar(rIsLow, \"rIsLow char at bottom\", \"▲\", location.bottom, size = size.small)\n// Method #3: Plot a character on the RSI line.\nplotchar(rIsLow ? r : na, \"rIsLow char on line\", \"•\", location.absolute, color.red, size = size.small)\n// Method #4: Plot a shape in the top region of the display.\nplotshape(rIsLow, \"rIsLow shape\", shape.arrowup, location.top)\n// Method #5: Plot an arrow.\nplotarrow(rIsLow ? 1 : na, \"rIsLow arrow\")\n// Method #6: Change the background's color.\nbgcolor(rIsLow ? color.new(color.green, 90) : na)\nWe define our condition in the rIsLow boolean variable and it is evaluated on each bar. The r < 30 expression used to assign a value to the variable evaluates to true or false (or na when r is na, as is the case in the first bars of the dataset).\nMethod #1 uses a change in the color of the RSI plot on the condition. Whenever a plot’s color changes, it colors the plot starting from the preceding bar.\nMethod #2 uses plotchar() to plot an up triangle in the bottom part of the indicator’s display. Using different combinations of positions and characters allows the simultaneous identification of multiple conditions on a single bar. This is one of our preferred methods to identify conditions on the chart.\nMethod #3 also uses a plotchar() call, but this time the character is positioned on the RSI line. In order to achieve this, we use location.absolute and Pine Script™’s ?: ternary conditional operator to define a conditional expression where a y position is used only when our rIsLow condition is true. When it is not true, na is used, so no character is displayed.\nMethod #4 uses plotshape() to plot a blue up arrow in the top part of the indicator’s display area when our condition is met.\nMethod #5 uses plotarrow() to plot a green up arrow at the bottom of the display when our condition is met.\nMethod #6 uses bgcolor() to change the color of the background when our condition is met. The ternary operator is used once again to evaluate our condition. It will return color.green when rIsLow is true, and the na color (which does not color the background) when rIsLow is false or na.\nLastly, note how a boolean variable with a true value displays as 1 in the Data Window. false values are denoted by a zero value.\nCompound conditions¶\nProgrammers needing to identify situations where more than one condition is met must build compound conditions by aggregating individual conditions using the and logical operator. Because compound conditions will only perform as expected if their individual conditions trigger correctly, you will save yourself many headaches if you validate the behavior of individual conditions before using a compound condition in your code.\nThe state of multiple individual conditions can be displayed using a technique like this one, where four individual conditions are used to build our bull compound condition:\nindicator(\"Compound conditions\")\nperiodInput = input.int(20)\nbullLevelInput = input.int(55)\nr = ta.rsi(close, periodInput)\n// Condition #1.\nrsiBull = r > bullLevelInput\n// Condition #2.\nhiChannel = ta.highest(r, periodInput * 2)[1]\naboveHiChannel = r > hiChannel\n// Condition #3.\nchannelIsOld = hiChannel >= hiChannel[periodInput]\n// Condition #4.\nhistoryIsBull = math.sum(rsiBull ? 1 : -1, periodInput * 3) > 0\n// Compound condition.\nbull = rsiBull and aboveHiChannel and channelIsOld and historyIsBull\nhline(bullLevelInput)\nplot(r, \"RSI\", color.black)\nplot(hiChannel, \"High Channel\")\nplotchar(rsiBull ? bullLevelInput : na, \"rIsBull\", \"1\", location.absolute, color.green, size = size.tiny)\nplotchar(aboveHiChannel ? r : na, \"aboveHiChannel\", \"2\", location.absolute, size = size.tiny)\nplotchar(channelIsOld, \"channelIsOld\", \"3\", location.bottom, size = size.tiny)\nplotchar(historyIsBull, \"historyIsBull\", \"4\", location.top, size = size.tiny)\nbgcolor(bull ? not bull[1] ? color.new(color.green, 50) : color.new(color.green, 90) : na)\nWe use a plotchar() call to display each condition’s number, taking care to spread them over the indicator’s y space so they don’t overlap.\nThe first two plotchar() calls use absolute positioning to place the condition number so that it helps us remember the corresponding condition. The first one which displays “1” when RSI is higher than the user-defined bull level for example, positions the “1” on the bull level.\nWe use two different shades of green to color the background: the brighter one indicates the first bar where our compound condition becomes true, the lighter green identifies subsequent bars where our compound condition continues to be true.\nWhile it is not always strictly necessary to assign individual conditions to a variable because they can be used directly in boolean expressions, it makes for more readable code when you assign a condition to a variable name that will remind you and your readers of what it represents. Readability considerations should always prevail in cases like this one, where the hit on performance of assigning conditions to variable names is minimal or null.\nDebugging from inside functions¶\nVariables in function are local to the function, so not available for plotting from the script’s global scope. In this script we have written the hlca() function to calculate a weighed average:\nindicator(\"Debugging from inside functions\", \"\", true)\nhlca() =>\nvar float avg = na\nhlca = math.avg(high, low, close, nz(avg, close))\navg := ta.sma(hlca, 20)\nh = hlca()\nplot(h)\nWe need to inspect the value of hlca in the function’s local scope as the function calculates, bar to bar. We cannot access the hlca variable used inside the function from the script’s global scope. We thus need another mechanism to pull that variable’s value from inside the function’s local scope, while still being able to use the function’s result. We can use Pine Script™’s ability to have functions return a tuple to gain access to the variable:\nindicator(\"Debugging from inside functions\", \"\", true)\nhlca() =>\nvar float avg = na\ninstantVal = math.avg(high, low, close, nz(avg, close))\navg := ta.sma(instantVal, 20)\n// Return two values instead of one.\n[avg, instantVal]\n[h, instantVal] = hlca()\nplot(h, \"h\")\nplot(instantVal, \"instantVal\", color.black)\nContrary to global scope variables, array elements of globally defined arrays can be modified from within functions. We can use this feature to write a functionally equivalent script:\nindicator(\"Debugging from inside functions\", \"\", true)\n// Create an array containing only one float element.\ninstantValGlobal = array.new_float(1)\nhlca() =>\nvar float avg = na\ninstantVal = math.avg(high, low, close, nz(avg, close))\n// Set the array's only element to the current value of `_instantVal`.\narray.set(instantValGlobal, 0, instantVal)\navg := ta.sma(instantVal, 20)\nh = hlca()\nplot(h, \"h\")\n// Retrieve the value of the array's only element which was set from inside the function.\nplot(array.get(instantValGlobal, 0), \"instantValGlobal\", color.black)\nDebugging from inside `for` loops¶\nValues inside for loops cannot be plotted using plot() calls in the loop. As in functions, such variables are also local to the loop’s scope. Here, we explore three different techniques to inspect variable values originating from for loops, starting from this code example, which calculates the balance of bars in the lookback period which have a higher/lower true range value than the current bar:\nindicator(\"Debugging from inside `for` loops\")\nlookbackInput = input.int(20, minval = 0)\nfloat trBalance = 0\nfor i = 1 to lookbackInput\ntrBalance := trBalance + math.sign(ta.tr - ta.tr[i])\nhline(0)\nplot(trBalance)\nUsing lines and labels¶\nWhen we want to extract values from more than one loop iteration we can use lines and labels. Here we draw a line corresponding to the value of ta.tr used in each loop iteration. We also use a label to display, for each line, the loop’s index and the line’s value. This gives us a general idea of the values being used in each loop iteration:\nindicator(\"Debugging from inside `for` loops\", max_lines_count = 500, max_labels_count = 500)\nlookbackInput = input.int(20, minval = 0)\nfloat trBalance = 0\nfor i = 1 to lookbackInput\ntrBalance := trBalance + math.sign(ta.tr - ta.tr[i])\nline.new(bar_index[1], ta.tr[i], bar_index, ta.tr[i], color = color.black)\nlabel.new(bar_index, ta.tr[i], str.tostring(i) + \"•\" + str.tostring(ta.tr[i]), style = label.style_none, size = size.small)\nhline(0)\nplot(trBalance)\nTo show more detail, the scale in the preceding screenshot has been manually expanded by clicking and dragging the scale area.\nWe use max_lines_count = 500, max_labels_count = 500 in our indicator() declaration statement to display the maximum number of lines and labels.\nEach loop iteration does not necessarily produce a distinct ta.tr value, which is why we may not see 20 distinct lines for each bar.\nIf we wanted to show only one level, we could use the same technique while isolating a specific loop iteration as we did in the preceding example.\nTips¶\nThe two techniques we use most frequently to debug our Pine Script™ code are:\nplotchar(v, \"v\", \"\", location.top, size = size.tiny)\nto plot variables of type float, int or bool in the indicator’s values and the Data Window, and the one-line version of our print() function to debug strings:\nprint(txt) => var _label = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, color.gray, size.large, text.align_left), label.set_xy(_label, bar_index, ta.highest(10)[1]), label.set_text(_label, txt)\nprint(stringName)\nAs we use AutoHotkey for Windows to speed repetitive tasks, we include these lines in our AutoHotkey script (this is not Pine Script™ code):\n; ————— This is AHK code, not Pine Script™. ————— ^+f:: SendInput plotchar(^v, \"^v\", \"\", location.top, size = size.tiny){Return} ^+p:: SendInput print(txt) => var lbl = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, color.gray, size.large, text.align_left), label.set_xy(lbl, bar_index, highest(10)[1]), label.set_text(lbl, txt)`nprint(){Left} \nThe second line will type a debugging plotchar() call including an expression or variable name previously copied to the clipboard when we use ctrl + shift + f. Copying the variableName variable name or the close > open conditional expression to the clipboard and hitting ctrl + shift + f will, respectively, yield:\nplotchar(variableName, \"variableName\", \"\", location.top, size = size.tiny)\nplotchar(close > open, \"close > open\", \"\", location.top, size = size.tiny)\nThe third line triggers on ctrl + shift + p. It types our one-line print() function in a script and on a second line, an empty call to the function with the cursor placed so all that’s left to do is type the string we want to display:\nprint(txt) => var lbl = label.new(bar_index, na, txt, xloc.bar_index, yloc.price, color(na), label.style_none, color.gray, size.large, text.align_left), label.set_xy(lbl, bar_index, ta.highest(10)[1]), label.set_text(lbl, txt)\nprint()\nNote: AutoHotkey works only on Windows systems. Keyboard Maestro or others can be substituted on Apple systems."
},
{
  "text": "Publishing scripts¶\nScript visibility and access\nWhen you publish a script\nVisibility\nPublic\nPrivate\nAccess\nOpen\nProtected\nInvite-only\nPreparing a publication\nPublishing a script\nUpdating a publication\nProgrammers who wish to share their Pine scripts with other traders can publish them.\nIf you write scripts for your personal use, there is no need to publish them; you can save them in the Pine Editor and use the “Add to Chart” button to add your script to your chart.\nScript visibility and access¶\nWhen you publish a script, you control its visibility and access:\nVisibility is controlled by choosing to publish publicly or privately. See How do private ideas and scripts differ from public ones? in the Help Center for more details. Publish publicly when you have written a script you think can be useful to TradingViewers. Public scripts are subject to moderation. To avoid moderation, ensure your publication complies with our House Rules and Script Publishing Rules. Publish privately when you don’t want your script visible to all other users, but want to share it with a few friends.\nAccess determines if users will see your source code, and how they will be able to use your script. There are three access types: open, protected (reserved to paid accounts) or invite-only (reserved to Premium accounts). See What are the different types of published scripts? in the Help Center for more details.\nWhen you publish a script¶\nThe publication’s title is determined by the argument used for the title parameter in the script’s indicator() or strategy() declaration statement. That title is also used when TradingViewers search for script names.\nThe name of your script on the chart will be the argument used for the shorttitle parameter in the script’s indicator() or strategy() declaration statement, or the title argument in library().\nYour script must have a description explaining what your script does and how to use it.\nThe chart you are using when you publish will become visible in your publication, including any other scripts or drawings on it. Remove unrelated scripts or drawings from your chart before publishing your script.\nYour script’s code can later be updated. Each update can include release notes which will appear, dated, under your original description.\nScripts can be liked, shared, commented on or reported by other users.\nYour published scripts appear under the “SCRIPTS” tab of your user profile.\nA script widget and a script page are created for your script. The script widget is your script’s placeholder showing in script feeds on the platform. It contains your script’s title, chart and the first few lines of your description. When users click on your script widget, the script’s page opens. It contains all the information relating to your script.\nVisibility¶\nPublic¶\nWhen you publish a public script:\nYour script will be inluded in our Community Scripts where it becomes visible to the millions of TradingViewers on all internationalized versions of the site.\nYour publication must comply with House Rules and Script Publishing Rules.\nIf your script is an invite-only script, you must comply with our Vendor Requirements.\nIt becomes accessible through the search functions for scripts.\nYou will not be able to edit your original description or its title, nor change its public/private visibility, nor its access type (open-source, protected, invite-only).\nYou will not be able to delete your publication.\nPrivate¶\nWhen you publish a private script:\nIt will not be visible to other users unless you share its url with them.\nIt is visible to you from your user profile’s “SCRIPTS” tab.\nPrivate scripts are identifiable by the “X” and “lock” icons in the top-right of their widget. The “X” is used to delete it.\nIt is not moderated, unless you sell access to it or make it available publicly, as it is then no longer “private”.\nYou can update its original description and title.\nYou cannot link to or mentioned it from any public TradingView content (ideas, script descriptions, comments, chats, etc.).\nIt is not accessible through the search functions for scripts.\nAccess¶\nPublic or private scripts can be published using one of three access types: open, protected or invite-only. The access type you can select from will vary with the type of account you hold.\nOpen¶\nThe Pine Script™ code of scripts published open is visible to all users. Open-source scripts on TradingView use the Mozilla license by default, but you may choose any license you want. You can find information on licensing at GitHub.\nProtected¶\nThe code of protected scripts is hidden from view and no one but its author can access it. While the script’s code is not accessible, protected scripts can be used freely by any user. Only Pro, Pro+ or Premium accounts may publish public protected scripts.\nInvite-only¶\nThe invite-only access type protects both the script’s code and its use. The publisher of an invite-only script must explicitly grant access to individual users. Invite-only scripts are mostly used by script vendors providing paid access to their scripts. Only Premium accounts can publish invite-only scripts, and they must comply with our Vendor Requirements.\nTradingView does not benefit from script sales. Transactions concerning invite-only scripts are strictly between users and vendors; they do not involve TradingView.\nPublic invite-only scripts are the only scripts for which vendors are allowed to ask for payment on TradingView.\nOn their invite-only script’s page, authors will see a “Manage Access” button. The “Manage Access” window allows authors to control who has access to their script.\nPreparing a publication¶\nEven if you intend to publish publicly, it is always best to start with a private publication because you can use it to validate what your final publication will look like. You can edit the title, description, code or chart of private publications, and contrary to public scripts, you can delete private scripts when you don’t need them anymore, so they are the perfect way to practice before sharing a script publicly. You can read more about preparing script descriptions in the How We Write and Format Script Descriptions publication.\nPrepare your chart. Load your script on the chart and remove other scripts or drawings that won’t help users understand your script. Your script’s plots should be easy to identify on the chart that will be published with it.\nLoad your code in the Pine Editor if it isn’t already. In the Editor, click the “Publish Script” button: \nA popup appears to remind you that if you publish publicly, it’s important that your publication comply with House Rules. Once you’re through the popup, place your description in the field below the script’s title. The default title proposed for your publication is the title field from your script’s code. It is always best to use that title; it makes it easier for users to search for your script if it is public. Select the visibility of your publication. We want to publish a private publication, so we check the “Private Script” checkbox at the bottom-right of the “Publish Script” window: \nSelect the access type you want for your script: Open, Protected or Invite-only. We have selected “Open” for open-source. \nSelect the appropriate categories for your script (at least one is mandatory) and enter optional custom tags. \nClick the “Publish Private Script” button in the lower-right of the window. When the publication is complete, your published script’s page will appear. You are done! You can confirm the publication by going to your User Profile and viewing your “SCRIPTS” tab. From there, you will be able to open your script’s page and edit your private publication by using the “Edit” button in the top-right of your script’s page. Note that you can also update private publications, just like you can public ones. If you want to share your private publication with a friend, privately send her the url from your script’s page. Remember you are not allowed to share links to private publications in public TradingView content.\nPublishing a script¶\nWhether you intend to publish privately or publicly, first follow the steps in the previous section. If you intend to publish privately, you will be done. If you intend to publish publicly and are satisfied with the preparatory process of validating your private publication, follow the same steps as above but do not check the “Private Script” checkbox and click the “Publish Public Script” button at the bottom-right of the “Publish Script” page.\nWhen you publish a new public script, you have a 15-minute window to make changes to your description or delete the publication. After that you will no longer be able to change your publication’s title, description, visiblity or access type. If you make an error, send a message to the PineCoders moderator account; they moderate script publications and will help.\nUpdating a publication¶\nYou can update both public or private script publications. When you update a script, its code must be different than the previously published version’s code. You can add release notes with your update. They will appear after your script’s original description in the script’s page.\nBy default, the chart used when you update will replace the previous chart in your script’s page. You can choose not to update your script page’s chart, however. Note that while you can update the chart displayed in the script’s page, the chart from the script’s widget will not update.\nIn the same way you can validate a public publication by first publishing a private script, you can also validate an update on a private publication before proceeding with it on your public one. The process of updating a published script is the same for public and private scripts.\nIf you intend to update both the code and chart of your published script, prepare your chart the same way you would for a new publication. In the following example, we will not be updating the publication’s chart:\nAs you would for a new publication, load your script in the Editor and click the “Publish Script” button.\nOnce in the “Publish Script” window, select the “Update Existing Script” button. Then select the script to update from the “Choose script” dropdown menu: \nEnter your release notes in the text field. The differences in your code are highlighted below your release notes.\nWe do not want to update the publication’s chart, so we check the “Don’t update the chart” checkbox: \nClick the “Publish New Version” button. You’re done."
},
{
  "text": "v4 to v5 converter\nRenamed functions and variables\nRenamed function parameters\nRemoved an `rsi()` overload\nReserved keywords\nRemoved `iff()` and `offset()`\nSplit of `input()` into several functions\nSome function parameters now require built-in arguments\nDeprecated the `transp` parameter\nChanged the default session days for `time()` and `time_close()`\n`strategy.exit()` now must do something\nCommon script conversion errors\nAll variable, function, and parameter name changes\nThis guide documents the changes made to Pine Script™ from v4 to v5. It will guide you in the adaptation of existing Pine scripts to Pine Script™ v5. See our Release notes for a list of the new features in Pine Script™ v5.\nThe most frequent adaptations required to convert older scripts to v5 are:\nChanging study() for indicator() (the function’s signature has not changed).\nRenaming built-in function calls to include their new namespace (e.g., highest() in v4 becomes ta.highest() in v5).\nRestructuring inputs to use the more specialized input.*() functions.\nEliminating uses of the deprecated transp parameter by using color.new() to simultaneously define color and transparency for use with the color parameter.\nIf you used the resolution and resolution_gaps parameters in v4’s study(), they will require changing to timeframe and timeframe_gaps in v5’s indicator().\nv4 to v5 converter¶\nThe Pine Editor includes a utility to automatically convert v4 scripts to v5. To access it, open a script with //@version=4 in it and select the “Convert to v5” option in the “More” menu identified by three dots at the top-right of the Editor’s pane:\nNot all scripts can be automatically converted from v4 to v5. If you want to convert the script manually or if your indicator returns a compilation error after conversion, use the following sections to determine how to complete the conversion. A list of some errors you can encounter during the automatic conversion and how to fix them can be found in the Common script conversion errors section of this guide.\nRenamed functions and variables¶\nFor clarity and consistency, many built-in functions and variables were renamed in v5. The inclusion of v4 function names in a new namespace is the cause of most changes. For example, the sma() function in v4 is moved to the ta. namespace in v5: ta.sma(). Remembering the new namespaces is not necessary; if you type the older name of a function without its namespace in the Editor and press the ‘Auto-complete’ hotkey (Ctrl + Space, or Cmd + Space on MacOS), a popup showing matching suggestions appears:\nNot counting functions moved to new namespaces, only two functions have been renamed:\nstudy() is now indicator().\ntickerid() is now ticker.new().\nThe full list of renamed functions and variables can be found in the All variable, function, and parameter name changes section of this guide.\nRenamed function parameters¶\nThe parameter names of some built-in functions were changed to improve the nomenclature. This has no bearing on most scripts, but if you used these parameter names when calling functions, they will require adaptation. For example, we have standardized all mentions:\n// Valid in v4. Not valid in v5.\ntimev4 = time(resolution = \"1D\")\n// Valid in v5.\ntimev5 = time(timeframe = \"1D\")\n// Valid in v4 and v5.\ntimeBoth = time(\"1D\")\nThe full list of renamed function parameters can be found in the All variable, function, and parameter name changes section of this guide.\nRemoved an `rsi()` overload¶\nIn v4, the rsi() function had two different overloads:\nrsi(series float, simple int) for the normal RSI calculation, and\nrsi(series float, series float) for an overload used in the MFI indicator, which did a calculation equivalent to 100.0 - (100.0 / (1.0 + arg1 / arg2)).\nThis caused a single built-in function to behave in two very different ways, and it was difficult to distinguish which one applied because it depended on the type of the second argument. As a result, a number of indicators misused the function and were displaying incorrect results. To avoid this, the second overload was removed in v5.\nThe ta.rsi() function in v5 only accepts a “simple int” argument for its length parameter. If your v4 code used the now deprecated overload of the function with a float second argument, you can replace the whole rsi() call with the following formula, which is equivalent:\n100.0 - (100.0 / (1.0 + arg1 / arg2))\nNote that when your v4 code used a “series int” value as the second argument to rsi(), it was automatically cast to “series float” and the second overload of the function was used. While this was syntactically correct, it most probably did not yield the result you expected. In v5, ta.rsi() requires a “simple int” for the argument to length, which precludes dynamic (or “series”) lengths. The reason for this is that RSI calculations use the ta.rma() moving average, which is similar to ta.ema() in that it relies on a length-dependent recursive process using the values of previous bars. This makes it impossible to achieve correct results with a “series” length that could vary bar to bar.\nIf your v4 code used a length that was “const int”, “input int” or “simple int”, no changes are required.\nReserved keywords¶\nA number of words are reserved and cannot be used for variable or function names. They are: catch, class, do, ellipse, in, is, polygon, range, return, struct, text, throw, try. If your v4 indicator uses any of these, rename your variable or function for the script to work in v5.\nRemoved `iff()` and `offset()`¶\nThe iff() and offset() functions have been removed. Code using the iff() function can be rewritten using the ternary operator:\n// iff(<condition>, <return_when_true>, <return_when_false>)\n// Valid in v4, not valid in v5\nbarColorIff = iff(close >= open, color.green, color.red)\n// <condition> ? <return_when_true> : <return_when_false>\n// Valid in v4 and v5\nbarColorTernary = close >= open ? color.green : color.red\nNote that the ternary operator is evaluated “lazily”; only the required value is calculated (depending on the condition’s evaluation to true or false). This is different from iff(), which always evaluated both values but returned only the relevant one.\nSome functions require evaluation on every bar to correctly calculate, so you will need to make special provisions for these by pre-evaluating them before the ternary:\n// `iff()` in v4: `highest()` and `lowest()` are calculated on every bar\nv1 = iff(close > open, highest(10), lowest(10))\nplot(v1)\n// In v5: forced evaluation on every bar prior to the ternary statement.\nh1 = ta.highest(10)\nl1 = ta.lowest(10)\nv1 = close > open ? h1 : l1\nplot(v1)\nThe offset() function was deprecated because the more readable [] operator is equivalent:\n// Valid in v4. Not valid in v5.\nprevClosev4 = offset(close, 1)\n// Valid in v4 and v5.\nprevClosev5 = close[1]\nSplit of `input()` into several functions¶\nThe v4 input() function was becoming crowded with a plethora of overloads and parameters. We split its functionality into different functions to clear that space and provide a more robust structure to accommodate the additions planned for inputs. Each new function uses the name of the input.* type of the v4 input() call it replaces. E.g., there is now a specialized input.float() function replacing the v4 input(1.0, type = input.float) call. Note that you can still use input(1.0) in v5, but because only input.float() allows for parameters such as minval, maxval, etc., it is more powerful. Also note that input.int() is the only specialized input function that does not use its equivalent v4 input.integer name. The input.* constants have been removed because they were used as arguments for the type parameter, which was deprecated.\nTo convert, for example, a v4 script using an input of type input.symbol, the input.symbol() function must be used in v5:\n// Valid in v4. Not valid in v5.\naaplTicker = input(\"AAPL\", type = input.symbol)\n// Valid in v5\naaplTicker = input.symbol(\"AAPL\")\nThe input() function persists in v5, but in a simpler form, with less parameters. It has the advantage of automatically detecting input types “bool/color/int/float/string/source” from the argument used for defval:\n// Valid in v4 and v5.\n// While \"AAPL\" is a valid symbol, it is only a string here because `input.symbol()` is not used.\ntickerString = input(\"AAPL\", title = \"Ticker string\")\nSome function parameters now require built-in arguments¶\nIn v4, built-in constants such as plot.style_area used as arguments when calling Pine Script™ functions corresponded to pre-defined values of a specific type. For example, the value of barmerge.lookahead_on was true, so you could use true instead of the named constant when supplying an argument to the lookahead parameter in a security() function call. We found this to be a common source of confusion, which caused unsuspecting programmers to produce code yielding unintended results.\nIn v5, the use of correct built-in named constants as arguments to function parameters requiring them is mandatory:\n// Not valid in v5: `true` is used as an argument for `lookahead`.\nrequest.security(syminfo.tickerid, \"1D\", close, lookahead = true)\n// Valid in v5: uses a named constant instead of `true`.\nrequest.security(syminfo.tickerid, \"1D\", close, lookahead = barmerge.lookahead_on)\n// Would compile in v4 because `plot.style_columns` was equal to 5.\n// Won't compile in v5.\na = 2 * plot.style_columns\nplot(a)\nTo convert your script from v4 to v5, make sure you use the correct named built-in constants as function arguments.\nDeprecated the `transp` parameter¶\nThe transp= parameter used in the signature of many v4 plotting functions was deprecated because it interfered with RGB functionality. Transparency must now be specified along with the color as an argument to parameters such as color, textcolor, etc. The color.new() or color.rgb() functions will be needed in those cases to join a color and its transparency.\nNote that in v4, the bgcolor() and fill() functions had an optional transp parameter that used a default value of 90. This meant that the code below could display Bollinger Bands with a semi-transparent fill between two bands and a semi-transparent backround color where bands cross price, even though no argument is used for the transp parameter in its bgcolor() and fill() calls:\nstudy(\"Bollinger Bands\", overlay = true)\n[middle, upper, lower] = bb(close, 5, 4)\nplot(middle, color=color.blue)\np1PlotID = plot(upper, color=color.green)\np2PlotID = plot(lower, color=color.green)\ncrossUp = crossover(high, upper)\ncrossDn = crossunder(low, lower)\n// Both `fill()` and `bgcolor()` have a default `transp` of 90\nfill(p1PlotID, p2PlotID, color = color.green)\nbgcolor(crossUp ? color.green : crossDn ? color.red : na)\nIn v5 we need to explictly mention the 90 transparency with the color, yielding:\nindicator(\"Bollinger Bands\", overlay = true)\n[middle, upper, lower] = ta.bb(close, 5, 4)\nplot(middle, color=color.blue)\np1PlotID = plot(upper, color=color.green)\np2PlotID = plot(lower, color=color.green)\ncrossUp = ta.crossover(high, upper)\ncrossDn = ta.crossunder(low, lower)\nvar TRANSP = 90\n// We use `color.new()` to explicitly pass transparency to both functions\nfill(p1PlotID, p2PlotID, color = color.new(color.green, TRANSP))\nbgcolor(crossUp ? color.new(color.green, TRANSP) : crossDn ? color.new(color.red, TRANSP) : na)\nChanged the default session days for `time()` and `time_close()`¶\nThe default set of days for session strings used in the time() and time_close() functions, and returned by input.session(), has changed from \"23456\" (Monday to Friday) to \"1234567\" (Sunday to Saturday):\n// On symbols that are traded during weekends, this will behave differently in v4 and v5.\nt0 = time(\"1D\", \"1000-1200\")\n// v5 equivalent of the behavior of `t0` in v4.\nt1 = time(\"1D\", \"1000-1200:23456\")\n// v5 equivalent of the behavior of `t0` in v5.\nt2 = time(\"1D\", \"1000-1200:1234567\")\nThis change in behavior should not have much impact on scripts running on conventional markets that are closed during weekends. If it is important for you to ensure your session definitions preserve their v4 behavior in v5 code, add \":23456\" to your session strings. See this manual’s page on Sessions for more information.\n`strategy.exit()` now must do something¶\nGone are the days when the strategy.exit() function was allowed to loiter. Now it must actually have an effect on the strategy by using at least one of the following parameters: profit, limit, loss, stop, or one of the following pairs: trail_offset combined with either trail_price or trail_points. When uses of strategy.exit() not meeting these criteria trigger an error while converting a strategy to v5, you can safely eliminate these lines, as they didn’t do anything in your code anyway.\nCommon script conversion errors¶\nInvalid argument ‘style’/’linestyle’ in ‘plot’/’hline’ call¶\nTo make this work, you need to change the “int” arguments used for the style and linestyle arguments in plot() and hline() for built-in constants:\n// Will cause an error during conversion\nplotStyle = input(1)\nhlineStyle = input(1)\nplot(close, style = plotStyle)\nhline(100, linestyle = hlineStyle)\n// Will work in v5\nplotStyleInput = input.string(\"Line\", options = [\"Line\", \"Stepline\", \"Histogram\", \"Cross\", \"Area\", \"Columns\", \"Circles\"])\nhlineStyleInput = input.string(\"Solid\", options = [\"Solid\", \"Dashed\", \"Dotted\"])\nplotStyle = plotStyleInput == \"Line\" ? plot.style_line :\nplotStyleInput == \"Stepline\" ? plot.style_stepline :\nplotStyleInput == \"Histogram\" ? plot.style_histogram :\nplotStyleInput == \"Cross\" ? plot.style_cross :\nplotStyleInput == \"Area\" ? plot.style_area :\nplotStyleInput == \"Columns\" ? plot.style_columns :\nplot.style_circles\nhlineStyle = hlineStyleInput == \"Solid\" ? hline.style_solid :\nhlineStyleInput == \"Dashed\" ? hline.style_dashed :\nhline.style_dotted\nplot(close, style = plotStyle)\nhline(100, linestyle = hlineStyle)\nSee the Some function parameters now require built-in arguments section of this guide for more information.\nUndeclared identifier ‘input.%input_name%’¶\nTo fix this issue, remove the input.* constants from your code:\n// Will cause an error during conversion\n_integer = input.integer\n_bool = input.bool\ni1 = input(1, \"Integer\", _integer)\ni2 = input(true, \"Boolean\", _bool)\n// Will work in v5\ni1 = input.int(1, \"Integer\")\ni2 = input.bool(true, \"Boolean\")\nSee the User Manual’s page on Inputs, and the Some function parameters now require built-in arguments section of this guide for more information.\nInvalid argument ‘when’ in ‘strategy.close’ call¶\nThis is caused by a confusion between strategy.entry() and strategy.close().\nThe second parameter of strategy.close() is when, which expects a “bool” argument. In v4, it was allowed to use strategy.long an argument because it was a “bool”. With v5, however, named built-in constants must be used as arguments, so strategy.long is no longer allowed as an argument to the when parameter.\nThe strategy.close(\"Short\", strategy.long) call in this code is equivalent to strategy.close(\"Short\"), which is what must be used in v5:\n// Will cause an error during conversion\nif (longCondition)\nstrategy.close(\"Short\", strategy.long)\nstrategy.entry(\"Long\", strategy.long)\n// Will work in v5:\nif (longCondition)\nstrategy.close(\"Short\")\nstrategy.entry(\"Long\", strategy.long)\nSee the Some function parameters now require built-in arguments section of this guide for more information.\nCannot call ‘input.int’ with argument ‘minval’=’%value%’. An argument of ‘literal float’ type was used but a ‘const int’ is expected¶\nIn v4, it was possible to pass a “float” argument to minval when an “int” value was being input. This is no longer possible in v5; “int” values are required for “int” inputs:\n// Works in v4, will break on conversion because minval is a 'float' value\nint_input = input(1, \"Integer\", input.integer, minval = 1.0)\n// Works in v5\nint_input = input.int(1, \"Integer\", minval = 1)\nSee the User Manual’s page on Inputs, and the Some function parameters now require built-in arguments section of this guide for more information.\nAll variable, function, and parameter name changes¶\nRemoved functions and variables¶\nv4\tv5\t\ninput.bool input\tReplaced by input.bool()\t\ninput.color input\tReplaced by input.color()\t\ninput.float input\tReplaced by input.float()\t\ninput.integer input\tReplaced by input.int()\t\ninput.resolution input\tReplaced by input.timeframe()\t\ninput.session input\tReplaced by input.session()\t\ninput.source input\tReplaced by input.source()\t\ninput.string input\tReplaced by input.string()\t\ninput.symbol input\tReplaced by input.symbol()\t\ninput.time input\tReplaced by input.time()\t\niff()\tUse the ?: operator instead\t\noffset()\tUse the [] operator instead\t\nRenamed functions and parameters¶\nNo namespace change¶\nv4\tv5\t\nstudy(<...>, resolution, resolution_gaps, <...>)\tindicator(<...>, timeframe, timeframe_gaps, <...>)\t\nstrategy.entry(long)\tstrategy.entry(direction)\t\nstrategy.order(long)\tstrategy.order(direction)\t\ntime(resolution)\ttime(timeframe)\t\ntime_close(resolution)\ttime_close(timeframe)\t\nnz(x, y)\tnz(source, replacement)\t\n“ta” namespace for technical analysis functions and variables¶\nv4\tv5\t\nIndicator functions and variables\t\naccdist\tta.accdist\t\nalma()\tta.alma()\t\natr()\tta.atr()\t\nbb()\tta.bb()\t\nbbw()\tta.bbw()\t\ncci()\tta.cci()\t\ncmo()\tta.cmo()\t\ncog()\tta.cog()\t\ndmi()\tta.dmi()\t\nema()\tta.ema()\t\nhma()\tta.hma()\t\niii\tta.iii\t\nkc()\tta.kc()\t\nkcw()\tta.kcw()\t\nlinreg()\tta.linreg()\t\nmacd()\tta.macd()\t\nmfi()\tta.mfi()\t\nmom()\tta.mom()\t\nnvi\tta.nvi\t\nobv\tta.obv\t\npvi\tta.pvi\t\npvt\tta.pvt\t\nrma()\tta.rma()\t\nroc()\tta.roc()\t\nrsi(x, y)\tta.rsi(source, length)\t\nsar()\tta.sar()\t\nsma()\tta.sma()\t\nstoch()\tta.stoch()\t\nsupertrend()\tta.supertrend()\t\nswma(x)\tta.swma(source)\t\ntr\tta.tr\t\ntr()\tta.tr()\t\ntsi()\tta.tsi()\t\nvwap\tta.vwap\t\nvwap(x)\tta.vwap(source)\t\nvwma()\tta.vwma()\t\nwad\tta.wad\t\nwma()\tta.wma()\t\nwpr()\tta.wpr()\t\nwvad\tta.wvad\t\nSupporting functions\t\nbarsince()\tta.barsince()\t\nchange()\tta.change()\t\ncorrelation(source_a, source_b, length)\tta.correlation(source1, source2, length)\t\ncross(x, y)\tta.cross(source1, source2)\t\ncrossover(x, y)\tta.crossover(source1, source2)\t\ncrossunder(x, y)\tta.crossunder(source1, source2)\t\ncum(x)\tta.cum(source)\t\ndev()\tta.dev()\t\nfalling()\tta.falling()\t\nhighest()\tta.highest()\t\nhighestbars()\tta.highestbars()\t\nlowest()\tta.lowest()\t\nlowestbars()\tta.lowestbars()\t\nmedian()\tta.median()\t\nmode()\tta.mode()\t\npercentile_linear_interpolation()\tta.percentile_linear_interpolation()\t\npercentile_nearest_rank()\tta.percentile_nearest_rank()\t\npercentrank()\tta.percentrank()\t\npivothigh()\tta.pivothigh()\t\npivotlow()\tta.pivotlow()\t\nrange()\tta.range()\t\nrising()\tta.rising()\t\nstdev()\tta.stdev()\t\nvaluewhen()\tta.valuewhen()\t\nvariance()\tta.variance()\t\n“request” namespace for functions that request external data¶\nv4\tv5\t\nfinancial()\trequest.financial()\t\nquandl()\trequest.quandl()\t\nsecurity(<...>, resolution, <...>)\trequest.security(<...>, timeframe, <...>)\t\nsplits()\trequest.splits()\t\ndividends()\trequest.dividends()\t\nearnings()\trequest.earnings()\t\n“ticker” namespace for functions that help create tickers¶\nheikinashi()\tticker.heikinashi()\t\nkagi()\tticker.kagi()\t\nlinebreak()\tticker.linebreak()\t\npointfigure()\tticker.pointfigure()\t\nrenko()\tticker.renko()\t\ntickerid()\tticker.new()\t\n“str” namespace for functions that manipulate strings¶\ntostring(x, y)\tstr.tostring(value, format)\t\ntonumber(x)\tstr.tonumber(string)"
},
{
  "text": "As is mentioned in our Welcome page:\nBecause each script uses computational resources in the cloud, we must impose limits in order to share these resources fairly among our users. We strive to set as few limits as possible, but will of course have to implement as many as needed for the platform to run smoothly. Limitations apply to the amount of data requested from additional symbols, execution time, memory usage and script size.\nIf you develop complex scripts using Pine Script™, sooner or later you will run into some of the limitations we impose. This section provides you with an overview of the limitations that you may encounter. There are currently no means for Pine Script™ programmers to get data on the resources consumed by their scripts. We hope this will change in the future.\nIn the meantime, when you are considering large projects, it is safest to make a proof of concept in order to assess the probability of your script running into limitations later in your project.\nBelow, we describe the limits imposed in the Pine Script™ environment.\nTime¶\nScript compilation¶\nScripts must compile before they are executed on charts. Compilation occurs when you save a script from the Pine Editor or when you add a script to the chart. A two-minute limit is imposed on compilation time, which will depend on the size and complexity of your script, and whether or not a cached version of a previous compilation is available. When a compile exceeds the two-minute limit, a warning is issued. Heed that warning by shortening your script because after three consecutives warnings a one-hour ban on compilation attempts is enforced. The first thing to consider when optimizing code is to avoid repetitions by using functions to encapsulate oft-used segments, and call functions instead of repeating code.\nScript execution¶\nOnce a script is compiled it can be executed. See the Events triggering the execution of a script for a list of the events triggering the execution of a script. The time allotted for the script to execute on all bars of a dataset varies with account types. The limit is 20 seconds for basic accounts, 40 for others.\nLoop execution¶\nThe execution time for any loop on any single bar is limited to 500 milliseconds. The outer loop of embedded loops counts as one loop, so it will time out first. Keep in mind that even though a loop may execute under the 500 ms time limit on a given bar, the time it takes to execute on all the dataset’s bars may nonetheless cause your script to exceed the total execution time limit. For example, the limit on total execution time will make it impossible for you script to execute a 400 ms loop on each bar of a 20,000-bar dataset because your script would then need 8000 seconds to execute.\nChart visuals¶\nPlot limits¶\nA maximum of 64 plot counts are allowed per script. The functions that generate plot counts are:\nplot()\nplotarrow()\nplotbar()\nplotcandle()\nplotchar()\nplotshape()\nalertcondition()\nbgcolor()\nfill(), but only if its color is of the series form.\nThe following functions do not generate plot counts:\nhline()\nline.new()\nlabel.new()\ntable.new()\nbox.new()\nOne function call can generate up to seven plot counts, depending on the function and how it is called. When your script exceeds the maximum of 64 plot counts, the runtime error message will display the plot count generated by your script. Once you reach that point, you can determine how many plot counts a function call generates by commenting it out in a script. As long as your script still throws an error, you will be able to see how the actual plot count decreases after you have commented out a line.\nThe following example shows different function calls and the number of plot counts each one will generate:\nindicator(\"Plot count example\")\nbool isUp = close > open\ncolor isUpColor = isUp ? color.green : color.red\nbool isDn = not isUp\ncolor isDnColor = isDn ? color.red : color.green\n// Uses one plot count each.\np1 = plot(close, color = color.white)\np2 = plot(open, color = na)\n// Uses two plot counts for the `close` and `color` series.\nplot(close, color = isUpColor)\n// Uses one plot count for the `close` series.\nplotarrow(close, colorup = color.green, colordown = color.red)\n// Uses two plot counts for the `close` and `colorup` series.\nplotarrow(close, colorup = isUpColor)\n// Uses three plot counts for the `close`, `colorup`, and the `colordown` series.\nplotarrow(close - open, colorup = isUpColor, colordown = isDnColor)\n// Uses four plot counts for the `open`, `high`, `low`, and `close` series.\nplotbar(open, high, low, close, color = color.white)\n// Uses five plot counts for the `open`, `high`, `low`, `close`, and `color` series.\nplotbar(open, high, low, close, color = isUpColor)\n// Uses four plot counts for the `open`, `high`, `low`, and `close` series.\nplotcandle(open, high, low, close, color = color.white, wickcolor = color.white, bordercolor = color.purple)\n// Uses five plot counts for the `open`, `high`, `low`, `close`, and `color` series.\nplotcandle(open, high, low, close, color = isUpColor, wickcolor = color.white, bordercolor = color.purple)\n// Uses six plot counts for the `open`, `high`, `low`, `close`, `color`, and `wickcolor` series.\nplotcandle(open, high, low, close, color = isUpColor, wickcolor = isUpColor , bordercolor = color.purple)\n// Uses seven plot counts for the `open`, `high`, `low`, `close`, `color`, `wickcolor`, and `bordercolor` series.\nplotcandle(open, high, low, close, color = isUpColor, wickcolor = isUpColor , bordercolor = isUp ? color.lime : color.maroon)\n// Uses one plot count for the `close` series.\nplotchar(close, color = color.white, text = \"|\", textcolor = color.white)\n// Uses two plot counts for the `close`` and `color` series.\nplotchar(close, color = isUpColor, text = \"—\", textcolor = color.white)\n// Uses three plot counts for the `close`, `color`, and `textcolor` series.\nplotchar(close, color = isUpColor, text = \"O\", textcolor = isUp ? color.yellow : color.white)\n// Uses one plot count for the `close` series.\nplotshape(close, color = color.white, textcolor = color.white)\n// Uses two plot counts for the `close` and `color` series.\nplotshape(close, color = isUpColor, textcolor = color.white)\n// Uses three plot counts for the `close`, `color`, and `textcolor` series.\nplotshape(close, color = isUpColor, textcolor = isUp ? color.yellow : color.white)\n// Uses one plot count.\nalertcondition(close > open, \"close > open\", \"Up bar alert\")\n// Uses one plot count.\nbgcolor(isUp ? color.yellow : color.white)\n// Uses one plot count for the `color` series.\nfill(p1, p2, color = isUpColor)\nThis example generates a plot count of 56. If we were to add two more instances of the last call to plotcandle(), the script would throw an error stating that the script now uses 70 plot counts, as each additional call to plotcandle() generates seven plot counts, and 56 + (7 * 2) is 70.\nLine, box, polyline, and label limits¶\nContrary to plots, which can cover the chart’s entire dataset, scripts will only show the last 50 lines, boxes, polylines, and labels on the chart by default. One can increase the maximum number for each of these drawing types via the max_lines_count, max_boxes_count, max_polylines_count, and max_labels_count parameters of the script’s indicator() or strategy() declaration statement. The maximum number of line, box, and label IDs is 500, and the maximum number of polyline IDs is 100.\nIn this example, we set the maximum number of recent labels shown on the chart to 100:\nindicator(\"Label limits example\", max_labels_count = 100, overlay = true)\nlabel.new(bar_index, high, str.tostring(high, format.mintick))\nIt’s important to note when setting any of a drawing object’s properties to na that its ID still exists and thus contributes to a script’s drawing totals. To demonstrate this behavior, the following script draws a “Buy” and “Sell” label on each bar, with x values determined by the longCondition and shortCondition variables.\nThe “Buy” label’s x value is na when the bar index is even, and the “Sell” label’s x value is na when the bar index is odd. Although the max_labels_count is 10 in this example, we can see that the script displays fewer than 10 labels on the chart since the ones with na values also count toward the total:\n// Approximate maximum number of label drawings\nMAX_LABELS = 10\nindicator(\"labels with na\", overlay = false, max_labels_count = MAX_LABELS)\n// Add background color for the last MAX_LABELS bars.\nbgcolor(bar_index > last_bar_index - MAX_LABELS ? color.new(color.green, 80) : na)\nlongCondition = bar_index % 2 != 0\nshortCondition = bar_index % 2 == 0\n// Add \"Buy\" and \"Sell\" labels on each new bar.\nlabel.new(longCondition ? bar_index : na, 0, text = \"Buy\", color = color.new(color.green, 0), style = label.style_label_up)\nlabel.new(shortCondition ? bar_index : na, 0, text = \"Sell\", color = color.new(color.red, 0), style = label.style_label_down)\nplot(longCondition ? 1 : 0)\nplot(shortCondition ? 1 : 0)\nTo display the desired number of labels, we must eliminate label drawings we don’t want to show rather than setting their properties to na. The example below uses an if structure to conditionally draw the “Buy” and “Sell” labels, preventing the script from creating new label IDs when it isn’t necessary:\n// Approximate maximum number of label drawings\nMAX_LABELS = 10\nindicator(\"conditional labels\", overlay = false, max_labels_count = MAX_LABELS)\n// Add background color for the last MAX_LABELS bars.\nbgcolor(bar_index > last_bar_index - MAX_LABELS ? color.new(color.green, 80) : na)\nlongCondition = bar_index % 2 != 0\nshortCondition = bar_index % 2 == 0\n// Add a \"Buy\" label when `longCondition` is true.\nif longCondition\nlabel.new(bar_index, 0, text = \"Buy\", color = color.new(color.green, 0), style = label.style_label_up)\n// Add a \"Sell\" label when `shortCondition` is true.\nif shortCondition\nlabel.new(bar_index, 0, text = \"Sell\", color = color.new(color.red, 0), style = label.style_label_down)\nplot(longCondition ? 1 : 0)\nplot(shortCondition ? 1 : 0)\nTable limits¶\nScripts can display a maximum of nine tables on the chart, one for each of the possible locations: position.bottom_center, position.bottom_left, position.bottom_right, position.middle_center, position.middle_left, position.middle_right, position.top_center, position.top_left, and position.top_right. When attempting to place two tables in the same location, only the newest instance will show on the chart.\n`request.*()` calls¶\nIntrabars¶\nScripts can retrieve up to the most recent 100,000 intrabars (lower-timeframe bars) via the request.security() or request.security_lower_tf() functions.\nThe number of bars on the chart’s timeframe covered by 100,000 intrabars varies with the number of intrabars each chart bar contains. For example, requesting data from the 1-minute timeframe while running the script on a 60-minute chart means each chart bar can contain up to 60 intrabars. In this case, the minimum number of chart bars covered by the intrabar request is 1,666, as 100,000 / 60 = 1,666.67. It’s important to note, however, that a provider may not report data for every minute within an hour. Therefore, such a request may cover more chart bars, depending on the available data.\nTuple element limit¶\nAll the request.*() function calls in a script taken together cannot return more than 127 tuple elements. When the combined tuple size of all request.*() calls will exceed 127 elements, one can instead utilize user-defined types (UDTs) to request a greater number of values.\nThe example below outlines this limitation and the way to work around it. The first request.security() call represents using a tuple with 128 elements as the expression argument. Since the number of elements is greater than 127, it would result in an error.\nTo avoid the error, we can use those same values as fields within an object of a UDT and pass its ID to the expression instead:\nindicator(\"Tuple element limit\")\ns1 = close\ns2 = close * 2\n...\ns128 = close * 128\n// Causes an error.\n[v1, v2, v3, ..., v128] = request.security(syminfo.tickerid, \"1D\", [s1, s2, s3, ..., s128])\n// Works fine:\ntype myType\nfloat v1\nfloat v2\nfloat v3\n...\nfloat v128\nmyObj = request.security(syminfo.tickerid, \"1D\", myType.new(s1, s2, s3, ..., s128))\nThis example outlines a scenario where the script tries to evaluate 128 tuple elements in a single request.security() call. The same limitation applies if we were to split the tuple request across multiple calls. For example, two request.security() calls that each retrieve a tuple with 64 elements will also cause an error.\nScript size and memory¶\nCompiled tokens¶\nBefore the execution of a script, the compiler translates it into a tokenized Intermediate Language (IL). Using an IL allows Pine Script™ to accommodate larger scripts by applying various memory and performance optimizations. The compiler determines the size of a script based on the number of tokens in its IL form, not the number of characters or lines in the code viewable in the Pine Editor.\nThe compiled form of each indicator, strategy, and library script is limited to 68,000 tokens. When a script imports libraries, the total number of tokens from all imported libraries cannot exceed 1 million. There is no way to inspect a script’s compiled form, nor its IL token count. As such, you will only know your script exceeds the size limit when the compiler reaches it.\nIn most cases, a script’s compiled size will likely not reach the limit. However, if a compiled script does reach the token limit, the most effective ways to decrease compiled tokens are to reduce repetitive code, encapsulate redundant calls within functions, and utilize libraries when possible.\nIt’s important to note that the compilation process omits any unused variables, functions, types, etc. from the final IL form, where “unused” refers to anything that does not affect the script’s outputs. This optimization prevents superfluous elements in the code from contributing to the script’s IL token count.\nFor example, the script below declares a user-defined type and a user-defined method and defines a sequence of calls using them:\nplot(close)\ntype myType\nfloat field = 10.0\nmethod m(array<myType> a, myType v) =>\na.push(v)\nvar arr = array.new<myType>()\narr.push(myType.new(25))\narr.m(myType.new())\nDespite the inclusion of array.new<myType>(), myType.new(), and arr.m() calls in the script, the only thing actually output by the script is plot(close). The rest of the code does not affect the output. Therefore, the compiled form of this script will have the same number of tokens as:\nplot(close)\nVariables per scope¶\nScripts can contain up to 1,000 variables in each of its scopes. Pine scripts always contain one global scope, represented by non-indented code, and they may contain zero or more local scopes. Local scopes are sections of indented code representing procedures executed within functions and methods, as well as if, switch, for, for…in, and while structures, which allow for one or more local blocks. Each local block counts as one local scope.\nThe branches of a conditional expression using the ?: ternary operator do not count as local blocks.\nScope count¶\nThe total number of scopes in a script, including its global scope and each local scope from the user-defined functions, methods, conditional structures, or loops it uses, cannot exceed 500.\nIt’s important to note that the request.security(), request.security_lower_tf(), and request.seed() functions duplicate the scopes required to evaluate the values of their expression argument in another context. The scopes produced by each call to these request.*() functions also count toward the script’s scope limit.\nFor example, suppose we created a script with a global variable that depends on the local scopes of 250 if structures. The total scope count for this script is 251 (1 global scope + 250 local scopes):\nindicator(\"Scopes demo\")\nvar x = 0\nif close > 0\nx += 0\nif close > 1\nx += 1\n// ... Repeat this `if close > n` pattern until `n = 249`.\nif close > 249\nx += 249\nplot(x)\nSince the total number of scopes is within the limit, it will compile successfully. Now, suppose we call request.security() to evaluate the value of x from another context and plot its value as well. In this case, it will effectively double the script’s scope count since the value of x depends on all the script’s scopes:\nindicator(\"Scopes demo\")\nvar x = 0\nif close > 0\nx += 0\nif close > 1\nx += 1\n// ... Repeat this `if close > n` pattern until `n = 249`.\nif close > 249\nx += 249\nplot(x)\nplot(request.security(syminfo.tickerid, \"1D\", x) // Causes compilation error since the scope count is now 502.\nWe can resolve this issue by encapsulating the if blocks within a user-defined function, as the scope of a function counts as one embedded scope:\nindicator(\"Scopes demo\")\nf() =>\nvar x = 0\nif close > 0\nx += 0\nif close > 1\nx += 1\n// ... Repeat this `if close > n` pattern until `n = 249`.\nif close > 249\nx += 249\nplot(f())\nplot(request.security(syminfo.tickerid, \"1D\", f()) // No compilation error.\nCollections¶\nPine Script™ collections (arrays, matrices, and maps) can have a maximum of 100,000 elements. Each key-value pair in a map contains two elements, meaning maps can contain a maximum of 50,000 key-value pairs.\nOther limitations¶\nMaximum bars back¶\nReferences to past values using the [] history-referencing operator are dependent on the size of the historical buffer maintained by the Pine Script™ runtime, which is limited to a maximum of 5000 bars. This Help Center page discusses the historical buffer and how to change its size using either the max_bars_back parameter or the max_bars_back() function.\nMaximum bars forward¶\nWhen positioning drawings using xloc.bar_index, it is possible to use bar index values greater than that of the current bar as x coordinates. A maximum of 500 bars in the future can be referenced.\nThis example shows how we use the maxval parameter in our input.int() function call to cap the user-defined number of bars forward we draw a projection line so that it never exceeds the limit:\nindicator(\"Max bars forward example\", overlay = true)\n// This function draws a `line` using bar index x-coordinates.\ndrawLine(bar1, y1, bar2, y2) =>\n// Only execute this code on the last bar.\n// Create the line only the first time this function is executed on the last bar.\nvar line lin = line.new(bar1, y1, bar2, y2, xloc.bar_index)\n// Change the line's properties on all script executions on the last bar.\nline.set_xy1(lin, bar1, y1)\nline.set_xy2(lin, bar2, y2)\n// Input determining how many bars forward we draw the `line`.\nint forwardBarsInput = input.int(10, \"Forward Bars to Display\", minval = 1, maxval = 500)\n// Calculate the line's left and right points.\nint leftBar = bar_index[2]\nfloat leftY = high[2]\nint rightBar = leftBar + forwardBarsInput\nfloat rightY = leftY + (ta.change(high)[1] * forwardBarsInput)\n// This function call is executed on all bars, but it only draws the `line` on the last bar.\ndrawLine(leftBar, leftY, rightBar, rightY)\nChart bars¶\nThe number of bars appearing on charts is dependent on the amount of historical data available for the chart’s symbol and timeframe, and on the type of account you hold. When the required historical date is available, the minimum number of chart bars is:\n20,000 bars for the Premium plan.\n10,000 bars for Pro and Pro+ plans.\n5000 bars for other plans.\nTrade orders in backtesting¶\nA maximum of 9000 orders can be placed when backtesting strategies. When using Deep Backtesting, the limit is 200,000."
},
{
  "text": "This is a guide to converting Pine Script™ code from @version=3 to @version=4.\nConverter¶\nThe Pine Editor comes with a utility to automatically convert v3 indicators and strategies to v4. To access it, open a script with //@version=3 in it and select the Convert to v4 option in the More dropdown menu:\nNot all scripts can be automatically converted from v3 to v4. If you want to convert the script manually or if your indicator returns a compilation error after conversion, consult the guide below for more information.\nRenaming of built-in constants, variables, and functions¶\nIn Pine Script™ v4 the following built-in constants, variables, and functions were renamed:\nColor constants (e.g red) are moved to the color.* namespace (e.g. color.red).\nThe color function has been renamed to color.new.\nConstants for input() types (e.g. integer) are moved to the input.* namespace (e.g. input.integer).\nThe plot style constants (e.g. histogram style) are moved to the plot.style_* namespace (e.g. plot.style_histogram).\nStyle constants for the hline function (e.g. the dotted style) are moved to the hline.style_* namespace (e.g. hline.style_dotted).\nConstants of days of the week (e.g. sunday) are moved to the dayofweek.* namespace (e.g. dayofweek.sunday).\nThe variables of the current chart timeframe (e.g. period, isintraday) are moved to the timeframe.* namespace (e.g. timeframe.period, timeframe.isintraday).\nThe interval variable was renamed to timeframe.multiplier.\nThe ticker and tickerid variables are renamed to syminfo.ticker and syminfo.tickerid respectively.\nThe n variable that contains the bar index value has been renamed to bar_index.\nThe reason behind renaming all of the above was to structure the standard language tools and make working with code easier. New names are grouped according to assignments under common prefixes. For example, you will see a list with all available color constants if you type ‘color’ in the editor and press Ctrl + Space.\nExplicit variable type declaration¶\nIn Pine Script™ v4 it’s no longer possible to create variables with an unknown data type at the time of their declaration. This was done to avoid a number of issues that arise when the variable type changes after its initialization with the na value. From now on, you need to explicitly specify their type using keywords or type functions (for example, float) when declaring variables with the na value:\nstudy(\"Green Candle Close\")\n// We expect `src` to hold float values, so we declare in with the `float` keyword\nfloat src = na\nif close > open\nsrc := close\nplot(src)"
},
{
  "text": "This document helps to migrate Pine Script™ code from @version=2 to @version=3.\nDefault behaviour of security function has changed¶\nLet’s look at the simple security function use case. Add this indicator on an intraday chart:\n// Add this indicator on an intraday (e.g., 30 minutes) chart\n//@version=2\nstudy(\"My Script\", overlay=true)\ns = security(tickerid, 'D', high, false)\nplot(s)\nThis indicator is calculated based on historical data and looks somewhat into the future. At the first bar of every session an indicator plots the high price of the entire day. This could be useful in some cases for analysis, but doesn’t work for backtesting strategies.\nWe worked on this and made changes in Pine Script™ version 3. If this indicator is compiled with //@version=3 directive, we get a completely different picture: \nThe old behaviour is still available though. We added a parameter to the security function (the fifth one) called lookahead.\nIt can take on the form of two different values: barmerge.lookahead_off (and this is the default for Pine Script™ version 3) or barmerge.lookahead_on (which is the default for Pine Script™ version 2).\nSelf-referenced variables are removed¶\nPine Script™ version 2 pieces of code, containing a self-referencing variable:\n//@version=2\n//...\ns = nz(s[1]) + close\nCompiling this piece of code with Pine Script™ version 3 will give you an Undeclared identifier 's' error. It should be rewritten as:\n//@version=3\n//...\ns = 0.0\ns := nz(s[1]) + close\ns is now a mutable variable that is initialized at line 3. At line 3 the initial value gives the Pine Script™ compiler the information about the variable type. It’s a float in this example.\nIn some cases you may initialize that mutable variable (like s) with a na value. But in complex cases that won’t work.\nForward-referenced variables are removed¶\n//@version=2\n//...\nd = nz(f[1])\ne = d + 1\nf = e + close\nIn this example f is a forward-referencing variable, because it’s referenced at line 3 before it was declared and initialized. In Pine Script™ version 3 this will give you an error Undeclared identifier 'f'. This example should be rewritten in Pine Script™ version 3 as follows:\n//@version=3\nf = 0.0\nd = nz(f[1])\ne = d + 1\nf := e + close\nResolving a problem with a mutable variable in a security expression¶\nWhen you migrate script to version 3 it’s possible that after removing self-referencing and forward-referencing variables the Pine Script™ compiler will give you an error:\n//@version=3\ns = 0.0\ns := nz(s[1]) + close\nt = security(tickerid, period, s)\nCannot use mutable variable as an argument for security function!\nThis limitation exists since mutable variables were introduced in Pine Script™, i.e., in version 2. It can be resolved as before: wrap the code with a mutable variable in a function:\ncalcS() =>\ns = 0.0\ns := nz(s[1]) + close\nt = security(tickerid, period, calcS())\nMath operations with booleans are forbidden¶\nIn Pine Script™ v2 there were rules of implicit conversion of booleans into numeric types. In v3 this is forbidden. There is a conversion of numeric types into booleans instead (0 and na values are false, all the other numbers are true). Example (In v2 this code compiles fine):\n//@version=2\nstudy(\"My Script\")\ns = close >= open\ns1 = close[1] >= open[1]\ns2 = close[2] >= open[2]\nsum = s + s1 + s2\ncol = sum == 1 ? white : sum == 2 ? blue : sum == 3 ? red : na\nbgcolor(col)\nVariables s, s1 and s2 are of bool type. But at line 6 we add three of them and store the result in a variable sum. sum is a number, since we cannot add booleans. Booleans were implicitly converted to numbers (true values to 1.0 and false to 0.0) and then they were added.\nThis approach leads to unintentional errors in more complicated scripts. That’s why we no longer allow implicit conversion of booleans to numbers.\nIf you try to compile this example as a Pine Script™ v3 code, you’ll get an error: Cannot call `operator +` with arguments (series__bool, series__bool); <...> It means that you cannot use the addition operator with boolean values. To make this example work in Pine Script™ v3 you can do the following:\nbton(b) =>\nb ? 1 : 0\ns = close >= open\ns1 = close[1] >= open[1]\ns2 = close[2] >= open[2]\nsum = bton(s) + bton(s1) + bton(s2)\ncol = sum == 1 ? white : sum == 2 ? blue : sum == 3 ? red : na\nbgcolor(col)\nFunction bton (abbreviation of boolean-to-number) explicitly converts any boolean value to a number if you really need this."
},
{
  "text": "Execution model¶\nCalculation based on historical bars\nCalculation based on realtime bars\nEvents triggering the execution of a script\nMore information\nHistorical values of functions\nWhy this behavior?\nExceptions\nThe execution model of the Pine Script™ runtime is intimately linked to Pine Script™’s time series and type system. Understanding all three is key to making the most of the power of Pine Script™.\nThe execution model determines how your script is executed on charts, and thus how the code you write in scripts works. Your code would do nothing were it not for Pine Script™’s runtime, which kicks in after your code has compiled and it is executed on your chart because one of the events triggering the execution of a script has occurred.\nWhen a Pine script is loaded on a chart it executes once on each historical bar using the available OHLCV (open, high, low, close, volume) values for each bar. Once the script’s execution reaches the rightmost bar in the dataset, if trading is currently active on the chart’s symbol, then Pine Script™ indicators will execute once every time an update occurs, i.e., price or volume changes. Pine Script™ strategies will by default only execute when the rightmost bar closes, but they can also be configured to execute on every update, like indicators do.\nAll symbol/timeframe pairs have a dataset comprising a limited number of bars. When you scroll a chart to the left to see the dataset’s earlier bars, the corresponding bars are loaded on the chart. The loading process stops when there are no more bars for that particular symbol/timeframe pair or the maximum number of bars your account type permits has been loaded. You can scroll the chart to the left until the very first bar of the dataset, which has an index value of 0 (see bar_index).\nWhen the script first runs on a chart, all bars in a dataset are historical bars, except the rightmost one if a trading session is active. When trading is active on the rightmost bar, it is called the realtime bar. The realtime bar updates when a price or volume change is detected. When the realtime bar closes, it becomes an elapsed realtime bar and a new realtime bar opens.\nCalculation based on historical bars¶\nLet’s take a simple script and follow its execution on historical bars:\nindicator(\"My Script\", overlay = true)\nsrc = close\na = ta.sma(src, 5)\nb = ta.sma(src, 50)\nc = ta.cross(a, b)\nplot(a, color = color.blue)\nplot(b, color = color.black)\nplotshape(c, color = color.red)\nOn historical bars, a script executes at the equivalent of the bar’s close, when the OHLCV values are all known for that bar. Prior to execution of the script on a bar, the built-in variables such as open, high, low, close, volume and time are set to values corresponding to those from that bar. A script executes once per historical bar.\nOur example script is first executed on the very first bar of the dataset at index 0. Each statement is executed using the values for the current bar. Accordingly, on the first bar of the dataset, the following statement:\ninitializes the variable src with the close value for that first bar, and each of the next lines is executed in turn. Because the script only executes once for each historical bar, the script will always calculate using the same close value for a specific historical bar.\nThe execution of each line in the script produces calculations which in turn generate the indicator’s output values, which can then be plotted on the chart. Our example uses the plot and plotshape calls at the end of the script to output some values. In the case of a strategy, the outcome of the calculations can be used to plot values or dictate the orders to be placed.\nAfter execution and plotting on the first bar, the script is executed on the dataset’s second bar, which has an index of 1. The process then repeats until all historical bars in the dataset are processed and the script reaches the rightmost bar on the chart.\nCalculation based on realtime bars¶\nThe behavior of a Pine script on the realtime bar is very different than on historical bars. Recall that the realtime bar is the rightmost bar on the chart when trading is active on the chart’s symbol. Also, recall that strategies can behave in two different ways in the realtime bar. By default, they only execute when the realtime bar closes, but the calc_on_every_tick parameter of the strategy declaration statement can be set to true to modify the strategy’s behavior so that it executes each time the realtime bar updates, as indicators do. The behavior described here for indicators will thus only apply to strategies using calc_on_every_tick=true.\nThe most important difference between execution of scripts on historical and realtime bars is that while they execute only once on historical bars, scripts execute every time an update occurs during a realtime bar. This entails that built-in variables such as high, low and close which never change on a historical bar, can change at each of a script’s iteration in the realtime bar. Changes in the built-in variables used in the script’s calculations will, in turn, induce changes in the results of those calculations. This is required for the script to follow the realtime price action. As a result, the same script may produce different results every time it executes during the realtime bar.\nNote: In the realtime bar, the close variable always represents the current price. Similarly, the high and low built-in variables represent the highest high and lowest low reached since the realtime bar’s beginning. Pine Script™’s built-in variables will only represent the realtime bar’s final values on the bar’s last update.\nLet’s follow our script example in the realtime bar.\nWhen the script arrives on the realtime bar it executes a first time. It uses the current values of the built-in variables to produce a set of results and plots them if required. Before the script executes another time when the next update happens, its user-defined variables are reset to a known state corresponding to that of the last commit at the close of the previous bar. If no commit was made on the variables because they are initialized every bar, then they are reinitialized. In both cases their last calculated state is lost. The state of plotted labels and lines is also reset. This resetting of the script’s user-defined variables and drawings prior to each new iteration of the script in the realtime bar is called rollback. Its effect is to reset the script to the same known state it was in when the realtime bar opened, so calculations in the realtime bar are always performed from a clean state.\nThe constant recalculation of a script’s values as price or volume changes in the realtime bar can lead to a situation where variable c in our example becomes true because a cross has occurred, and so the red marker plotted by the script’s last line would appear on the chart. If on the next price update the price has moved in such a way that the close value no longer produces calculations making c true because there is no longer a cross, then the marker previously plotted will disappear.\nWhen the realtime bar closes, the script executes a last time. As usual, variables are rolled back prior to execution. However, since this iteration is the last one on the realtime bar, variables are committed to their final values for the bar when calculations are completed.\nTo summarize the realtime bar process:\nA script executes at the open of the realtime bar and then once per update.\nVariables are rolled back before every realtime update.\nVariables are committed once at the closing bar update.\nEvents triggering the execution of a script¶\nA script is executed on the complete set of bars on the chart when one of the following events occurs:\nA new symbol or timeframe is loaded on a chart.\nA script is saved or added to the chart, from the Pine Script™ Editor or the chart’s “Indicators & strategies” dialog box.\nA value is modified in the script’s “Settings/Inputs” dialog box.\nA value is modified in a strategy’s “Settings/Properties” dialog box.\nA browser refresh event is detected.\nA script is executed on the realtime bar when trading is active and:\nOne of the above conditions occurs, causing the script to execute on the open of the realtime bar, or\nThe realtime bar updates because a price or volume change was detected.\nNote that when a chart is left untouched when the market is active, a succession of realtime bars which have been opened and then closed will trail the current realtime bar. While these elapsed realtime bars will have been confirmed because their variables have all been committed, the script will not yet have executed on them in their historical state, since they did not exist when the script was last run on the chart’s dataset.\nWhen an event triggers the execution of the script on the chart and causes it to run on those bars which have now become historical bars, the script’s calculation can sometimes vary from what they were when calculated on the last closing update of the same bars when they were realtime bars. This can be caused by slight variations between the OHLCV values saved at the close of realtime bars and those fetched from data feeds when the same bars have become historical bars. This behavior is one of the possible causes of repainting.\nMore information¶\nThe built-in barstate.* variables provide information on the type of bar or the event where the script is executing. The page where they are documented also contains a script that allows you to visualize the difference between elapsed realtime and historical bars, for example.\nThe Strategies page explains the details of strategy calculations, which are not identical to those of indicators.\nHistorical values of functions¶\nEvery function call in Pine leaves a trail of historical values that a script can access on subsequent bars using the [] operator. The historical series of functions depend on successive calls to record the output on every bar. When a script does not call functions on each bar, it can produce an inconsistent history that may impact calculations and results, namely when it depends on the continuity of their historical series to operate as expected. The compiler warns users in these cases to make them aware that the values from a function, whether built-in or user-defined, might be misleading.\nTo demonstrate, let’s write a script that calculates the index of the current bar and outputs that value on every second bar. In the following script, we’ve defined a calcBarIndex() function that adds 1 to the previous value of its internal index variable on every bar. The script calls the function on each bar that the condition returns true on (every other bar) to update the customIndex value. It plots this value alongside the built-in bar_index to validate the output:\nindicator(\"My script\")\n//@function Calculates the index of the current bar by adding 1 to its own value from the previous bar.\n// The first bar will have an index of 0.\ncalcBarIndex() =>\nint index = na\nindex := nz(index[1], replacement = -1) + 1\n//@variable Returns `true` on every other bar.\ncondition = bar_index % 2 == 0\nint customIndex = na\n// Call `calcBarIndex()` when the `condition` is `true`. This prompts the compiler to raise a warning.\nif condition\ncustomIndex := calcBarIndex()\nplot(bar_index, \"Bar index\", color = color.green)\nplot(customIndex, \"Custom index\", color = color.red, style = plot.style_cross)\nThe nz() function replaces na values with a specified replacement value (0 by default). On the first bar of the script, when the index series has no history, the na value is replaced with -1 before adding 1 to return an initial value of 0.\nUpon inspecting the chart, we see that the two plots differ wildly. The reason for this behavior is that the script called calcBarIndex() within the scope of an if structure on every other bar, resulting in a historical output inconsistent with the bar_index series. When calling the function once every two bars, internally referencing the previous value of index gets the value from two bars ago, i.e., the last bar the function executed on. This behavior results in a customIndex value of half that of the built-in bar_index.\nTo align the calcBarIndex() output with the bar_index, we can move the function call to the script’s global scope. That way, the function will execute on every bar, allowing its entire history to be recorded and referenced rather than only the results from every other bar. In the code below, we’ve defined a globalScopeBarIndex variable in the global scope and assigned it to the return from calcBarIndex() rather than calling the function locally. The script sets the customIndex to the value of globalScopeBarIndex on the occurrence of the condition:\n//@function Calculates the index of the current bar by adding 1 to its own value from the previous bar.\n// The first bar will have an index of 0.\ncalcBarIndex() =>\nint index = na\nindex := nz(index[1], replacement = -1) + 1\n//@variable Returns `true` on every second bar.\ncondition = bar_index % 2 == 0\nglobalScopeBarIndex = calcBarIndex()\nint customIndex = na\n// Assign `customIndex` to `globalScopeBarIndex` when the `condition` is `true`. This won't produce a warning.\nif condition\ncustomIndex := globalScopeBarIndex\nplot(bar_index, \"Bar index\", color = color.green)\nplot(customIndex, \"Custom index\", color = color.red, style = plot.style_cross)\nThis behavior can also radically impact built-in functions that reference history internally. For example, the ta.sma() function references its past values “under the hood”. If a script calls this function conditionally rather than on every bar, the values within the calculation can change significantly. We can ensure calculation consistency by assigning ta.sma() to a variable in the global scope and referencing that variable’s history as needed.\nThe following example calculates three SMA series: controlSMA, localSMA, and globalSMA. The script calculates controlSMA in the global scope and localSMA within the local scope of an if structure. Within the if structure, it also updates the value of globalSMA using the controlSMA value. As we can see, the values from the globalSMA and controlSMA series align, whereas the localSMA series diverges from the other two because it uses an incomplete history, which affects its calculations:\n//@variable Returns `true` on every second bar.\ncondition = bar_index % 2 == 0\ncontrolSMA = ta.sma(close, 20)\nfloat globalSMA = na\nfloat localSMA = na\n// Update `globalSMA` and `localSMA` when `condition` is `true`.\nif condition\nglobalSMA := controlSMA // No warning.\nlocalSMA := ta.sma(close, 20) // Raises warning. This function depends on its history to work as intended.\nplot(controlSMA, \"Control SMA\", color = color.green)\nplot(globalSMA, \"Global SMA\", color = color.blue, style = plot.style_cross)\nplot(localSMA, \"Local SMA\", color = color.red, style = plot.style_cross)\nWhy this behavior?¶\nThis behavior is required because forcing the execution of functions on each bar would lead to unexpected results in those functions that produce side effects, i.e., the ones that do something aside from returning the value. For example, the label.new() function creates a label on the chart, so forcing it to be called on every bar even when it is inside of an if structure would create labels where they should not logically appear.\nExceptions¶\nNot all built-in functions use their previous values in their calculations, meaning not all require execution on every bar. For example, math.max() compares all arguments passed into it to return the highest value. Such functions that do not interact with their history in any way do not require special treatment.\nIf the usage of a function within a conditional block does not cause a compiler warning, it’s safe to use without impacting calculations. Otherwise, move the function call to the global scope to force consistent execution. When keeping a function call within a conditional block despite the warning, ensure the output is correct at the very least to avoid unexpected results."
},
{
  "text": "Script structure¶\nVersion\nDeclaration statement\nCode\nComments\nLine wrapping\nCompiler annotations\nA Pine script follows this general structure:\n<version>\n<declaration_statement>\n<code>\nVersion¶\nA compiler annotation in the following form tells the compiler which of the versions of Pine Script™ the script is written in:\nThe version number can be 1 to 5.\nThe compiler annotation is not mandatory. When omitted, version 1 is assumed. It is strongly recommended to always use the latest version of the language.\nWhile it is synctactically correct to place the version compiler annotation anywhere in the script, it is much more useful to readers when it appears at the top of the script.\nNotable changes to the current version of Pine Script™ are documented in the Release notes.\nDeclaration statement¶\nAll Pine scripts must contain one declaration statement, which is a call to one of these functions:\nindicator()\nstrategy()\nlibrary()\nThe declaration statement:\nIdentifies the type of the script, which in turn dictates which content is allowed in it, and how it can be used and executed.\nSets key properties of the script such as its name, where it will appear when it is added to a chart, the precision and format of the values it displays, and certain values that govern its runtime behavior, such as the maximum number of drawing objects it will display on the chart. With strategies, the properties include parameters that control backtesting, such as initial capital, commission, slippage, etc.\nEach type of script has distinct requirements:\nIndicators must contain at least one function call which produces output on the chart (e.g., plot(), plotshape(), barcolor(), line.new(), etc.).\nStrategies must contain at least one strategy.*() call, e.g., strategy.entry().\nLibraries must contain at least one exported function or user-defined type.\nCode¶\nLines in a script that are not comments or compiler annotations are statements, which implement the script’s algorithm. A statement can be one of these:\nvariable declaration\nvariable reassignement\nfunction declaration\nbuilt-in function call, user-defined function call or a library function call\nif, for, while, switch or type structure.\nStatements can be arranged in multiple ways:\nSome statements can be expressed in one line, like most variable declarations, lines containing only a function call or single-line function declarations. Lines can also be wrapped (continued on multiple lines). Multiple one-line statements can be concatenated on a single line by using the comma as a separator.\nOthers statements such as structures or multi-line function declarations always require multiple lines because they require a local block. A local block must be indented by a tab or four spaces. Each local block defines a distinct local scope.\nStatements in the global scope of the script (i.e., which are not part of local blocks) cannot begin with white space (a space or a tab). Their first character must also be the line’s first character. Lines beginning in a line’s first position become by definition part of the script’s global scope.\nA simple valid Pine Script™ v5 indicator can be generated in the Pine Script™ Editor by using the “Open” button and choosing “New blank indicator”:\nThis indicator includes three local blocks, one in the f() function declaration, and two in the variable declaration using an if structure:\nindicator(\"\", \"\", true) // Declaration statement (global scope)\nbarIsUp() => // Function declaration (global scope)\nclose > open // Local block (local scope)\nplotColor = if barIsUp() // Variable declaration (global scope)\ncolor.green // Local block (local scope)\ncolor.red // Local block (local scope)\nbgcolor(color.new(plotColor, 70)) // Call to a built-in function (global scope)\nYou can bring up a simple Pine Script™ v5 strategy by selecting “New blank strategy” instead:\nstrategy(\"My Strategy\", overlay=true, margin_long=100, margin_short=100)\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\nstrategy.entry(\"My Long Entry Id\", strategy.long)\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\nif (shortCondition)\nstrategy.entry(\"My Short Entry Id\", strategy.short)\nLine wrapping¶\nLong lines can be split on multiple lines, or “wrapped”. Wrapped lines must be indented with any number of spaces, provided it’s not a multiple of four (those boundaries are used to indent local blocks):\na = open + high + low + close\nmay be wrapped as:\na = open +\nhigh +\nlow +\nclose\nA long plot() call may be wrapped as:\nplot(ta.correlation(src, ovr, length),\ncolor = color.new(color.purple, 40),\nstyle = plot.style_area,\ntrackprice = true)\nStatements inside user-defined function declarations can also be wrapped. However, since a local block must syntactically begin with an indentation (4 spaces or 1 tab), when splitting it onto the following line, the continuation of the statement must start with more than one indentation (not equal to a multiple of four spaces). For example:\nupdown(s) =>\nisEqual = s == s[1]\nisGrowing = s > s[1]\nud = isEqual ?\n0 :\nisGrowing ?\n(nz(ud[1]) <= 0 ?\n1 :\nnz(ud[1])+1) :\n(nz(ud[1]) >= 0 ?\n-1 :\nnz(ud[1])-1)\nYou can use comments in wrapped lines:\nc = open > close ? color.red :\nhigh > high[1] ? color.lime : // A comment\nlow < low[1] ? color.blue : color.black\nbgcolor(c)\nCompiler annotations¶\nCompiler annotations are comments that issue special instructions for a script:\n//@version= specifies the PineScript™ version that the compiler will use. The number in this annotation should not be confused with the script’s revision number, which updates on every saved change to the code.\n//@description sets a custom description for scripts that use the library() declaration statement.\n//@function, //@param and //@returns add custom descriptions for a user-defined function, its parameters, and its result when placed above the function declaration.\n//@type and //@field add custom descriptions for a user-defined type (UDT) and its fields when placed above the type declaration.\n//@variable adds a custom description for a variable when placed above its declaration.\n//@strategy_alert_message provides a default message for strategy scripts to pre-fill the “Message” field in the alert creation dialogue.\n//#region and //#endregion create collapsible code regions in the Pine Editor. Clicking the dropdown arrow next to //#region collapses the lines of code between the two annotations.\nThis script draws a rectangle using three interactively selected points on the chart. It illustrates how compiler annotations can be used:\nindicator(\"Triangle\", \"\", true)\nint TIME_DEFAULT = 0\nfloat PRICE_DEFAULT = 0.0\nx1Input = input.time(TIME_DEFAULT, \"Point 1\", inline = \"1\", confirm = true)\ny1Input = input.price(PRICE_DEFAULT, \"\", inline = \"1\", tooltip = \"Pick point 1\", confirm = true)\nx2Input = input.time(TIME_DEFAULT, \"Point 2\", inline = \"2\", confirm = true)\ny2Input = input.price(PRICE_DEFAULT, \"\", inline = \"2\", tooltip = \"Pick point 2\", confirm = true)\nx3Input = input.time(TIME_DEFAULT, \"Point 3\", inline = \"3\", confirm = true)\ny3Input = input.price(PRICE_DEFAULT, \"\", inline = \"3\", tooltip = \"Pick point 3\", confirm = true)\n// @type Used to represent the coordinates and color to draw a triangle.\n// @field time1 Time of first point.\n// @field time2 Time of second point.\n// @field time3 Time of third point.\n// @field price1 Price of first point.\n// @field price2 Price of second point.\n// @field price3 Price of third point.\n// @field lineColor Color to be used to draw the triangle lines.\ntype Triangle\nint time1\nint time2\nint time3\nfloat price1\nfloat price2\nfloat price3\ncolor lineColor\n//@function Draws a triangle using the coordinates of the `t` object.\n//@param t (Triangle) Object representing the triangle to be drawn.\n//@returns The ID of the last line drawn.\ndrawTriangle(Triangle t) =>\nline.new(t.time1, t.price1, t.time2, t.price2, xloc = xloc.bar_time, color = t.lineColor)\nline.new(t.time2, t.price2, t.time3, t.price3, xloc = xloc.bar_time, color = t.lineColor)\nline.new(t.time1, t.price1, t.time3, t.price3, xloc = xloc.bar_time, color = t.lineColor)\n// Draw the triangle only once on the last historical bar.\n//@variable Used to hold the Triangle object to be drawn.\nTriangle triangle = Triangle.new()\ntriangle.time1 := x1Input\ntriangle.time2 := x2Input\ntriangle.time3 := x3Input\ntriangle.price1 := y1Input\ntriangle.price2 := y2Input\ntriangle.price3 := y3Input\ntriangle.lineColor := color.purple\ndrawTriangle(triangle)"
},
{
  "text": "Time series¶\nMuch of the power of Pine Script™ stems from the fact that it is designed to process time series efficiently. Time series are not a qualified type; they are the fundamental structure Pine Script™ uses to store the successive values of a variable over time, where each value is tethered to a point in time. Since charts are composed of bars, each representing a particular point in time, time series are the ideal data structure to work with values that may change with time.\nThe notion of time series is intimately linked to Pine Script™’s execution model and type system concepts. Understanding all three is key to making the most of the power of Pine Script™.\nTake the built-in open variable, which contains the “open” price of each bar in the dataset, the dataset being all the bars on any given chart. If your script is running on a 5min chart, then each value in the open time series is the “open” price of the consecutive 5min chart bars. When your script refers to open, it is referring to the “open” price of the bar the script is executing on. To refer to past values in a time series, we use the [] history-referencing operator. When a script is executing on a given bar, open[1] refers to the value of the open time series on the previous bar.\nWhile time series may remind programmers of arrays, they are totally different. Pine Script™ does use an array data structure, but it is a completely different concept than a time series.\nTime series in Pine Script™, combined with its special type of runtime engine and built-in functions, are what makes it easy to compute the cumulative total of close values without using a for loop, with only ta.cum(close). This is possible because although ta.cum(close) appears rather static in a script, it is in fact executed on each bar, so its value becomes increasingly larger as the close value of each new bar is added to it. When the script reaches the rightmost bar of the chart, ta.cum(close) returns the sum of the close value from all bars on the chart.\nSimilarly, the mean of the difference between the last 14 high and low values can be expressed as ta.sma(high - low, 14), or the distance in bars since the last time the chart made five consecutive higher highs as barssince(rising(high, 5)).\nEven the result of function calls on successive bars leaves a trace of values in a time series that can be referenced using the [] history-referencing operator. This can be useful, for example, when testing the close of the current bar for a breach of the highest high in the last 10 bars, but excluding the current bar, which we could write as breach = close > highest(close, 10)[1]. The same statement could also be written as breach = close > highest(close[1], 10).\nThe same looping logic on all bars is applied to function calls such as plot(open) which will repeat on each bar, successively plotting on the chart the value of open for each bar.\nDo not confuse “time series” with the “series” qualifier. The time series concept explains how consecutive values of variables are stored in Pine Script™; the “series” qualifier denotes variables whose values can change bar to bar. Consider, for example, the timeframe.period built-in variable which has the “simple” qualifier and “string” type, meaning it is of the “simple string” qualified type. The “simple” qualifier entails that the variable’s value is established on bar zero (the first bar where the script executes) and will not change during the script’s execution on any of the chart’s bars. The variable’s value is the chart’s timeframe in string format, so \"D\" for a 1D chart, for example. Even though its value cannot change during the script, it would be syntactically correct in Pine Script™ (though not very useful) to refer to its value 10 bars ago using timeframe.period[10]. This is possible because the successive values of timeframe.period for each bar are stored in a time series, even though all the values in that particular time series are the same. Note, however, that when the [] operator is used to access past values of a variable, it yields a “series” qualified value, even when the variable without an offset uses a different qualifier, such as “simple” in the case of timeframe.period.\nWhen you grasp how time series can be efficiently handled using Pine Script™’s syntax and its execution model, you can define complex calculations using little code."
},
{
  "text": "Operators¶\nArithmetic operators\nComparison operators\nLogical operators\n`?:` ternary operator\n`[ ]` history-referencing operator\nOperator precedence\n`=` assignement operator\n`:=` reassignement operator\nSome operators are used to build expressions returning a result:\nArithmetic operators\nComparison operators\nLogical operators\nThe ?: ternary operator\nThe [] history-referencing operator\nOther operators are used to assign values to variables:\n= is used to assign a value to a variable, but only when you declare the variable (the first time you use it)\n:= is used to assign a value to a previously declared variable. The following operators can also be used in such a way: +=, -=, *=, /=, %=\nAs is explained in the Type system page, qualifiers and types play a critical role in determining the type of results that expressions yield. This, in turn, has an impact on how and with what functions you will be allowed to use those results. Expressions always return a value with the strongest qualifier used in the expression, e.g., if you multiply an “input int” with a “series int”, the expression will produce a “series int” result, which you will not be able to use as the argument to length in ta.ema().\nThis script will produce a compilation error:\nlenInput = input.int(14, \"Length\")\nfactor = year > 2020 ? 3 : 1\nadjustedLength = lenInput * factor\nma = ta.ema(close, adjustedLength) // Compilation error!\nplot(ma)\nThe compiler will complain: Cannot call ‘ta.ema’ with argument ‘length’=’adjustedLength’. An argument of ‘series int’ type was used but a ‘simple int’ is expected;. This is happening because lenInput is an “input int” but factor is a “series int” (it can only be determined by looking at the value of year on each bar). The adjustedLength variable is thus assigned a “series int” value. Our problem is that the Reference Manual entry for ta.ema() tells us that its length parameter requires a “simple” value, which is a weaker qualifier than “series”, so a “series int” value is not allowed.\nThe solution to our conundrum requires:\nUsing another moving average function that supports a “series int” length, such as ta.sma(), or\nNot using a calculation producing a “series int” value for our length.\nArithmetic operators¶\nThere are five arithmetic operators in Pine Script™:\n+\tAddition and string concatenation\t\n-\tSubtraction\t\n*\tMultiplication\t\n/\tDivision\t\n%\tModulo (remainder after division)\t\nThe arithmetic operators above are all binary (means they need two operands — or values — to work on, like in 1 + 2). The + and - also serve as unary operators (means they work on one operand, like -1 or +1).\nIf both operands are numbers but at least one of these is of float type, the result will also be a float. If both operands are of int type, the result will also be an int. If at least one operand is na, the result is also na.\nThe + operator also serves as the concatenation operator for strings. \"EUR\"+\"USD\" yields the \"EURUSD\" string.\nThe % operator calculates the modulo by rounding down the quotient to the lowest possible value. Here is an easy example that helps illustrate how the modulo is calculated behind the scenes:\nindicator(\"Modulo function\")\nmodulo(series int a, series int b) =>\na - b * math.floor(nz(a/b))\nplot(modulo(-1, 100))\nComparison operators¶\nThere are six comparison operators in Pine Script™:\n<\tLess Than\t\n<=\tLess Than or Equal To\t\n!=\tNot Equal\t\n==\tEqual\t\n>\tGreater Than\t\n>=\tGreater Than or Equal To\t\nComparison operations are binary. If both operands have a numerical value, the result will be of type bool, i.e., true, false or na.\nExamples:\n1 > 2 // false\n1 != 1 // false\nclose >= open // Depends on values of `close` and `open`\nLogical operators¶\nThere are three logical operators in Pine Script™:\nnot\tNegation\t\nand\tLogical Conjunction\t\nor\tLogical Disjunction\t\nThe operator not is unary. When applied to a true, operand the result will be false, and vice versa.\nand operator truth table:\na b a and b \ntrue\ttrue\ttrue\t\ntrue\tfalse\tfalse\t\nfalse\ttrue\tfalse\t\nfalse\tfalse\tfalse\t\nor operator truth table:\na b a or b \ntrue\ttrue\ttrue\t\ntrue\tfalse\ttrue\t\nfalse\ttrue\ttrue\t\nfalse\tfalse\tfalse\t\n`?:` ternary operator¶\nThe ?: ternary operator is used to create expressions of the form:\ncondition ? valueWhenConditionIsTrue : valueWhenConditionIsFalse\nThe ternary operator returns a result that depends on the value of condition. If it is true, then valueWhenConditionIsTrue is returned. If condition is false or na, then valueWhenConditionIsFalse is returned.\nA combination of ternary expressions can be used to achieve the same effect as a switch structure, e.g.:\ntimeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.ismonthly ? color.blue : na\nThe example is calculated from left to right:\nIf timeframe.isintraday is true, then color.red is returned. If it is false, then timeframe.isdaily is evaluated.\nIf timeframe.isdaily is true, then color.green is returned. If it is false, then timeframe.ismonthly is evaluated.\nIf timeframe.ismonthly is true, then color.blue is returned, otherwise na is returned.\nNote that the return values on each side of the : are expressions — not local blocks, so they will not affect the limit of 500 local blocks per scope.\n`[ ]` history-referencing operator¶\nIt is possible to refer to past values of time series using the [] history-referencing operator. Past values are values a variable had on bars preceding the bar where the script is currently executing — the current bar. See the Execution model page for more information about the way scripts are executed on bars.\nThe [] operator is used after a variable, expression or function call. The value used inside the square brackets of the operator is the offset in the past we want to refer to. To refer to the value of the volume built-in variable two bars away from the current bar, one would use volume[2].\nBecause series grow dynamically, as the script moves on sucessive bars, the offset used with the operator will refer to different bars. Let’s see how the value returned by the same offset is dynamic, and why series are very different from arrays. In Pine Script™, the close variable, or close[0] which is equivalent, holds the value of the current bar’s “close”. If your code is now executing on the third bar of the dataset (the set of all bars on your chart), close will contain the price at the close of that bar, close[1] will contain the price at the close of the preceding bar (the dataset’s second bar), and close[2], the first bar. close[3] will return na because no bar exists in that position, and thus its value is not available.\nWhen the same code is executed on the next bar, the fourth in the dataset, close will now contain the closing price of that bar, and the same close[1] used in your code will now refer to the “close” of the third bar in the dataset. The close of the first bar in the dataset will now be close[3], and this time close[4] will return na.\nIn the Pine Script™ runtime environment, as your code is executed once for each historical bar in the dataset, starting from the left of the chart, Pine Script™ is adding a new element in the series at index 0 and pushing the pre-existing elements in the series one index further away. Arrays, in comparison, can have constant or variable sizes, and their content or indexing structure is not modified by the runtime environment. Pine Script™ series are thus very different from arrays and only share familiarity with them through their indexing syntax.\nWhen the market for the chart’s symbol is open and the script is executing on the chart’s last bar, the realtime bar, close returns the value of the current price. It will only contain the actual closing price of the realtime bar the last time the script is executed on that bar, when it closes.\nPine Script™ has a variable that contains the number of the bar the script is executing on: bar_index. On the first bar, bar_index is equal to 0 and it increases by 1 on each successive bar the script executes on. On the last bar, bar_index is equal to the number of bars in the dataset minus one.\nThere is another important consideration to keep in mind when using the [] operator in Pine Script™. We have seen cases when a history reference may return the na value. na represents a value which is not a number and using it in any expression will produce a result that is also na (similar to NaN). Such cases often happen during the script’s calculations in the early bars of the dataset, but can also occur in later bars under certain conditions. If your code does not explicitly provide for handling these special cases, they can introduce invalid results in your script’s calculations which can ripple through all the way to the realtime bar. The na and nz functions are designed to allow for handling such cases.\nThese are all valid uses of the [] operator:\nhigh[10]\nta.sma(close, 10)[1]\nta.highest(high, 10)[20]\nclose > nz(close[1], open)\nNote that the [] operator can only be used once on the same value. This is not allowed:\nclose[1][2] // Error: incorrect use of [] operator\nOperator precedence¶\nThe order of calculations is determined by the operators’ precedence. Operators with greater precedence are calculated first. Below is a list of operators sorted by decreasing precedence:\nPrecedence Operator \n9\t[]\t\n8\tunary +, unary -, not\t\n7\t*, /, %\t\n6\t+, -\t\n5\t>, <, >=, <=\t\n4\t==, !=\t\n3\tand\t\n2\tor\t\n1\t?:\t\nIf in one expression there are several operators with the same precedence, then they are calculated left to right.\nIf the expression must be calculated in a different order than precedence would dictate, then parts of the expression can be grouped together with parentheses.\n`=` assignement operator¶\nThe = operator is used to assign a variable when it is initialized — or declared —, i.e., the first time you use it. It says this is a new variable that I will be using, and I want it to start on each bar with this value.\nThese are all valid variable declarations:\ni = 1\nMS_IN_ONE_MINUTE = 1000 * 60\nshowPlotInput = input.bool(true, \"Show plots\")\npHi = pivothigh(5, 5)\nplotColor = color.green\nSee the Variable declarations page for more information on how to declare variables.\n`:=` reassignement operator¶\nThe := is used to reassign a value to an existing variable. It says use this variable that was declared earlier in my script, and give it a new value.\nVariables which have been first declared, then reassigned using :=, are called mutable variables. All the following examples are valid variable reassignments. You will find more information on how var works in the section on the `var` declaration mode:\n// Declare `pHi` and initilize it on the first bar only.\nvar float pHi = na\n// Reassign a value to `pHi`\npHi := nz(ta.pivothigh(5, 5), pHi)\nplot(pHi)\nWe declare pHi with this code: var float pHi = na. The var keyword tells Pine Script™ that we only want that variable initialized with na on the dataset’s first bar. The float keyword tells the compiler we are declaring a variable of type “float”. This is necessary because, contrary to most cases, the compiler cannot automatically determine the type of the value on the right side of the = sign.\nWhile the variable declaration will only be executed on the first bar because it uses var, the pHi := nz(ta.pivothigh(5, 5), pHi) line will be executed on all the chart’s bars. On each bar, it evaluates if the pivothigh() call returns na because that is what the function does when it hasn’t found a new pivot. The nz() function is the one doing the “checking for na” part. When its first argument (ta.pivothigh(5, 5)) is na, it returns the second argument (pHi) instead of the first. When pivothigh() returns the price point of a newly found pivot, that value is assigned to pHi. When it returns na because no new pivot was found, we assign the previous value of pHi to itself, in effect preserving its previous value.\nThe output of our script looks like this:\nThe line preserves its previous value until a new pivot is found.\nPivots are detected five bars after the pivot actually occurs because our ta.pivothigh(5, 5) call says that we require five lower highs on both sides of a high point for it to be detected as a pivot.\nSee the Variable reassignment section for more information on how to reassign values to variables."
},
{
  "text": "Identifiers¶\nIdentifiers are names used for user-defined variables and functions:\nThey must begin with an uppercase (A-Z) or lowercase (a-z) letter, or an underscore (_).\nThe next characters can be letters, underscores or digits (0-9).\nThey are case-sensitive.\nHere are some examples:\nmyVar\n_myVar\nmy123Var\nfunctionName\nMAX_LEN\nmax_len\nmaxLen\n3barsDown // NOT VALID!\nThe Pine Script™ Style Guide recommends using uppercase SNAKE_CASE for constants, and camelCase for other identifiers:\nGREEN_COLOR = #4CAF50\nMAX_LOOKBACK = 100\nint fastLength = 7\n// Returns 1 if the argument is `true`, 0 if it is `false` or `na`.\nzeroOne(boolValue) => boolValue ? 1 : 0"
},
{
  "text": "Variable declarations¶\nInitialization with `na`\nTuple declarations\nVariable reassignment\nDeclaration modes\nOn each bar\n`var`\n`varip`\nVariables are identifiers that hold values. They must be declared in your code before you use them. The syntax of variable declarations is:\n[<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\nor\n<tuple_declaration> = <function_call> | <structure>\n| means “or”, and parts enclosed in square brackets ([]) can appear zero or one time.\n<declaration_mode> is the variable’s declaration mode. It can be var or varip, or nothing.\n<type> is optional, as in almost all Pine Script™ variable declarations (see types).\n<identifier> is the variable’s name.\n<expression> can be a literal, a variable, an expression or a function call.\n<structure> can be an if, for, while or switch structure.\n<tuple_declaration> is a comma-separated list of variable names enclosed in square brackets ([]), e.g., [ma, upperBand, lowerBand].\nThese are all valid variable declarations. The last one requires four lines:\nBULL_COLOR = color.lime\ni = 1\nlen = input(20, \"Length\")\nfloat f = 10.5\ncloseRoundedToTick = math.round_to_mintick(close)\nst = ta.supertrend(4, 14)\nvar barRange = float(na)\nvar firstBarOpen = open\nvarip float lastClose = na\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplotColor = if close > open\ncolor.green\ncolor.red\nThe above statements all contain the = assignment operator because they are variable declarations. When you see similar lines using the := reassignment operator, the code is reassigning a value to a variable that was already declared. Those are variable reassignments. Be sure you understand the distinction as this is a common stumbling block for newcomers to Pine Script™. See the next Variable reassignment section for details.\nThe formal syntax of a variable declaration is:\n<variable_declaration>\n[<declaration_mode>] [<type>] <identifier> = <expression> | <structure>\n|\n<tuple_declaration> = <function_call> | <structure>\n<declaration_mode>\nvar | varip\n<type>\nint | float | bool | color | string | line | linefill | label | box | table | array<type> | matrix<type> | UDF\nInitialization with `na`¶\nIn most cases, an explicit type declaration is redundant because type is automatically inferred from the value on the right of the = at compile time, so the decision to use them is often a matter of preference. For example:\nbaseLine0 = na // compile time error!\nfloat baseLine1 = na // OK\nbaseLine2 = float(na) // OK\nIn the first line of the example, the compiler cannot determine the type of the baseLine0 variable because na is a generic value of no particular type. The declaration of the baseLine1 variable is correct because its float type is declared explicitly. The declaration of the baseLine2 variable is also correct because its type can be derived from the expression float(na), which is an explicit cast of the na value to the float type. The declarations of baseLine1 and baseLine2 are equivalent.\nTuple declarations¶\nFunction calls or structures are allowed to return multiple values. When we call them and want to store the values they return, a tuple declaration must be used, which is a comma-separated set of one or more values enclosed in brackets. This allows us to declare multiple variables simultaneously. As an example, the ta.bb() built-in function for Bollinger bands returns three values:\n[bbMiddle, bbUpper, bbLower] = ta.bb(close, 5, 4)\nVariable reassignment¶\nA variable reassignment is done using the := reassignment operator. It can only be done after a variable has been first declared and given an initial value. Reassigning a new value to a variable is often necessary in calculations, and it is always necessary when a variable from the global scope must be assigned a new value from within a structure’s local block, e.g.:\nsensitivityInput = input.int(2, \"Sensitivity\", minval = 1, tooltip = \"Higher values make color changes less sensitive.\")\nma = ta.sma(close, 20)\nmaUp = ta.rising(ma, sensitivityInput)\nmaDn = ta.falling(ma, sensitivityInput)\n// On first bar only, initialize color to gray\nvar maColor = color.gray\nif maUp\n// MA has risen for two bars in a row; make it lime.\nmaColor := color.lime\nelse if maDn\n// MA has fallen for two bars in a row; make it fuchsia.\nmaColor := color.fuchsia\nplot(ma, \"MA\", maColor, 2)\nWe initialize maColor on the first bar only, so it preserves its value across bars.\nOn every bar, the if statement checks if the MA has been rising or falling for the user-specified number of bars (the default is 2). When that happens, the value of maColor must be reassigned a new value from within the if local blocks. To do this, we use the := reassignment operator.\nIf we did not use the := reassignment operator, the effect would be to initialize a new maColor local variable which would have the same name as that of the global scope, but actually be a very confusing independent entity that would persist only for the length of the local block, and then disappear without a trace.\nAll user-defined variables in Pine Script™ are mutable, which means their value can be changed using the := reassignment operator. Assigning a new value to a variable may change its type qualifier (see the page on Pine Script™’s type system for more information). A variable can be assigned a new value as many times as needed during the script’s execution on one bar, so a script can contain any number of reassignments of one variable. A variable’s declaration mode determines how new values assigned to a variable will be saved.\nDeclaration modes¶\nUnderstanding the impact that declaration modes have on the behavior of variables requires prior knowledge of Pine Script™’s execution model.\nWhen you declare a variable, if a declaration mode is specified, it must come first. Three modes can be used:\n“On each bar”, when none is specified\nvar\nvarip\nOn each bar¶\nWhen no explicit declaration mode is specified, i.e. no var or varip keyword is used, the variable is declared and initialized on each bar, e.g., the following declarations from our first set of examples in this page’s introduction:\nBULL_COLOR = color.lime\ni = 1\nlen = input(20, \"Length\")\nfloat f = 10.5\ncloseRoundedToTick = math.round_to_mintick(close)\nst = ta.supertrend(4, 14)\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nplotColor = if close > open\ncolor.green\ncolor.red\n`var`¶\nWhen the var keyword is used, the variable is only initialized once, on the first bar if the declaration is in the global scope, or the first time the local block is executed if the declaration is inside a local block. After that, it will preserve its last value on successive bars, until we reassign a new value to it. This behavior is very useful in many cases where a variable’s value must persist through the iterations of a script across successive bars. For example, suppose we’d like to count the number of green bars on the chart:\nindicator(\"Green Bars Count\")\nvar count = 0\nisGreen = close >= open\nif isGreen\ncount := count + 1\nplot(count)\nWithout the var modifier, variable count would be reset to zero (thus losing its value) every time a new bar update triggered a script recalculation.\nDeclaring variables on the first bar only is often useful to manage drawings more efficiently. Suppoose we want to extend the last bar’s close line to the right of the right chart. We could write:\nindicator(\"Inefficient version\", \"\", true)\ncloseLine = line.new(bar_index - 1, close, bar_index, close, extend = extend.right, width = 3)\nline.delete(closeLine[1])\nbut this is inefficient because we are creating and deleting the line on each historical bar and on each update in the realtime bar. It is more efficient to use:\nindicator(\"Efficient version\", \"\", true)\nvar closeLine = line.new(bar_index - 1, close, bar_index, close, extend = extend.right, width = 3)\nline.set_xy1(closeLine, bar_index - 1, close)\nline.set_xy2(closeLine, bar_index, close)\nWe initialize closeLine on the first bar only, using the var declaration mode\nWe restrict the execution of the rest of our code to the chart’s last bar by enclosing our code that updates the line in an if barstate.islast structure.\nThere is a very slight penalty performance for using the var declaration mode. For that reason, when declaring constants, it is preferable not to use var if performance is a concern, unless the initialization involves calculations that take longer than the maintenance penalty, e.g., functions with complex code or string manipulations.\n`varip`¶\nUnderstanding the behavior of variables using the varip declaration mode requires prior knowledge of Pine Script™’s execution model and bar states.\nThe varip keyword can be used to declare variables that escape the rollback process, which is explained in the page on Pine Script™’s execution model.\nWhereas scripts only execute once at the close of historical bars, when a script is running in realtime, it executes every time the chart’s feed detects a price or volume update. At every realtime update, Pine Script™’s runtime normally resets the values of a script’s variables to their last committed value, i.e., the value they held when the previous bar closed. This is generally handy, as each realtime script execution starts from a known state, which simplifies script logic.\nSometimes, however, script logic requires code to be able to save variable values between different executions in the realtime bar. Declaring variables with varip makes that possible. The “ip” in varip stands for intrabar persist.\nLet’s look at the following code, which does not use varip:\nint updateNo = na\nif barstate.isnew\nupdateNo := 1\nupdateNo := updateNo + 1\nplot(updateNo, style = plot.style_circles)\nOn historical bars, barstate.isnew is always true, so the plot shows a value of “1” because the else part of the if structure is never executed. On realtime bars, barstate.isnew is only true when the script first executes on the bar’s “open”. The plot will then briefly display “1” until subsequent executions occur. On the next executions during the realtime bar, the second branch of the if statement is executed because barstate.isnew is no longer true. Since updateNo is initialized to na at each execution, the updateNo + 1 expression yields na, so nothing is plotted on further realtime executions of the script.\nIf we now use varip to declare the updateNo variable, the script behaves very differently:\nvarip int updateNo = na\nif barstate.isnew\nupdateNo := 1\nupdateNo := updateNo + 1\nplot(updateNo, style = plot.style_circles)\nThe difference now is that updateNo tracks the number of realtime updates that occur on each realtime bar. This can happen because the varip declaration allows the value of updateNo to be preserved between realtime updates; it is no longer rolled back at each realtime execution of the script. The test on barstate.isnew allows us to reset the update count when a new realtime bar comes in.\nBecause varip only affects the behavior of your code in the realtime bar, it follows that backtest results on strategies designed using logic based on varip variables will not be able to reproduce that behavior on historical bars, which will invalidate test results on them. This also entails that plots on historical bars will not be able to reproduce the script’s behavior in realtime."
},
{
  "text": "Conditional structures¶\n`if` structure\n`if` used for its side effects\n`if` used to return a value\n`switch` structure\n`switch` with an expression\n`switch` without an expression\nMatching local block type requirement\nThe conditional structures in Pine Script™ are if and switch. They can be used:\nFor their side effects, i.e., when they don’t return a value but do things, like reassign values to variables or call functions.\nTo return a value or a tuple which can then be assigned to one (or more, in the case of tuples) variable.\nConditional structures, like the for and while structures, can be embedded; you can use an if or switch inside another structure.\nSome Pine Script™ built-in functions cannot be called from within the local blocks of conditional structures. They are: alertcondition(), barcolor(), fill(), hline(), indicator(), library(), plot(), plotbar(), plotcandle(), plotchar(), plotshape(), strategy(). This does not entail their functionality cannot be controlled by conditions evaluated by your script — only that it cannot be done by including them in conditional structures. Note that while input*.() function calls are allowed in local blocks, their functionality is the same as if they were in the script’s global scope.\nThe local blocks in conditional structures must be indented by four spaces or a tab.\n`if` structure¶\n`if` used for its side effects¶\nAn if structure used for its side effects has the following syntax:\nif <expression>\n<local_block>\n{else if <expression>\n<local_block>}\n[else\n<local_block>]\nParts enclosed in square brackets ([]) can appear zero or one time, and those enclosed in curly braces ({}) can appear zero or more times.\n<expression> must be of “bool” type or be auto-castable to that type, which is only possible for “int” or “float” values (see the Type system page).\n<local_block> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab.\nThere can be zero or more else if clauses.\nThere can be zero or one else clause.\nWhen the <expression> following the if evaluates to true, the first local block is executed, the if structure’s execution ends, and the value(s) evaluated at the end of the local block are returned.\nWhen the <expression> following the if evaluates to false, the successive else if clauses are evaluated, if there are any. When the <expression> of one evaluates to true, its local block is executed, the if structure’s execution ends, and the value(s) evaluated at the end of the local block are returned.\nWhen no <expression> has evaluated to true and an else clause exists, its local block is executed, the if structure’s execution ends, and the value(s) evaluated at the end of the local block are returned.\nWhen no <expression> has evaluated to true and no else clause exists, na is returned.\nUsing if structures for their side effects can be useful to manage the order flow in strategies, for example. While the same functionality can often be achieved using the when parameter in strategy.*() calls, code using if structures is easier to read:\nif (ta.crossover(source, lower))\nstrategy.entry(\"BBandLE\", strategy.long, stop=lower,\noca_name=\"BollingerBands\",\noca_type=strategy.oca.cancel, comment=\"BBandLE\")\nstrategy.cancel(id=\"BBandLE\")\nRestricting the execution of your code to specific bars ican be done using if structures, as we do here to restrict updates to our label to the chart’s last bar:\nvar ourLabel = label.new(bar_index, na, na, color = color(na), textcolor = color.orange)\nlabel.set_xy(ourLabel, bar_index + 2, hl2[1])\nlabel.set_text(ourLabel, str.tostring(bar_index + 1, \"# bars in chart\"))\nWe initialize the ourLabel variable on the script’s first bar only, as we use the var declaration mode. The value used to initialize the variable is provided by the label.new() function call, which returns a label ID pointing to the label it creates. We use that call to set the label’s properties because once set, they will persist until we change them.\nWhat happens next is that on each successive bar the Pine Script™ runtime will skip the initialization of ourLabel, and the if structure’s condition (barstate.islast) is evaluated. It returns false on all bars until the last one, so the script does nothing on most historical bars after bar zero.\nOn the last bar, barstate.islast becomes true and the structure’s local block executes, modifying on each chart update the properties of our label, which displays the number of bars in the dataset.\nWe want to display the label’s text without a background, so we make the label’s background na in the label.new() function call, and we use hl2[1] for the label’s y position because we don’t want it to move all the time. By using the average of the previous bar’s high and low values, the label doesn’t move until the moment when the next realtime bar opens.\nWe use bar_index + 2 in our label.set_xy() call to offset the label to the right by two bars.\n`if` used to return a value¶\nAn if structure used to return one or more values has the following syntax:\n[<declaration_mode>] [<type>] <identifier> = if <expression>\n<local_block>\n{else if <expression>\n<local_block>}\n[else\n<local_block>]\nParts enclosed in square brackets ([]) can appear zero or one time, and those enclosed in curly braces ({}) can appear zero or more times.\n<declaration_mode> is the variable’s declaration mode\n<type> is optional, as in almost all Pine Script™ variable declarations (see types)\n<identifier> is the variable’s name\n<expression> can be a literal, a variable, an expression or a function call.\n<local_block> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab.\nThe value assigned to the variable is the return value of the <local_block>, or na if no local block is executed.\nThis is an example:\nstring barState = if barstate.islastconfirmedhistory\n\"islastconfirmedhistory\"\nelse if barstate.isnew\n\"isnew\"\nelse if barstate.isrealtime\n\"isrealtime\"\n\"other\"\nf_print(_text) =>\nvar table _t = table.new(position.middle_right, 1, 1)\ntable.cell(_t, 0, 0, _text, bgcolor = color.yellow)\nf_print(barState)\nIt is possible to omit the else block. In this case, if the condition is false, an empty value (na, false, or \"\") will be assigned to the var_declarationX variable.\nThis is an example showing how na is returned when no local block is executed. If close > open is false in here, na is returned:\nx = if close > open\nclose\nScripts can contain if structures with nested if and other conditional structures. For example:\nif condition1\nif condition2\nif condition3\nexpression\nHowever, nesting these structures is not recommended from a performance perspective. When possible, it is typically more optimal to compose a single if statement with multiple logical operators rather than several nested if blocks:\nif condition1 and condition2 and condition3\nexpression\n`switch` structure¶\nThe switch structure exists in two forms. One switches on the different values of a key expression:\n[[<declaration_mode>] [<type>] <identifier> = ]switch <expression>\n{<expression> => <local_block>}\n=> <local_block>\nThe other form does not use an expression as a key; it switches on the evaluation of different expressions:\n[[<declaration_mode>] [<type>] <identifier> = ]switch\n{<expression> => <local_block>}\n=> <local_block>\nParts enclosed in square brackets ([]) can appear zero or one time, and those enclosed in curly braces ({}) can appear zero or more times.\n<declaration_mode> is the variable’s declaration mode\n<type> is optional, as in almost all Pine Script™ variable declarations (see types)\n<identifier> is the variable’s name\n<expression> can be a literal, a variable, an expression or a function call.\n<local_block> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab.\nThe value assigned to the variable is the return value of the <local_block>, or na if no local block is executed.\nThe => <local_block> at the end allows you to specify a return value which acts as a default to be used when no other case in the structure is executed.\nOnly one local block of a switch structure is executed. It is thus a structured switch that doesn’t fall through cases. Consequently, break statements are unnecessary.\nBoth forms are allowed as the value used to initialize a variable.\nAs with the if structure, if no local block is exectuted, na is returned.\n`switch` with an expression¶\nLet’s look at an example of a switch using an expression:\nindicator(\"Switch using an expression\", \"\", true)\nstring maType = input.string(\"EMA\", \"MA type\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"])\nint maLength = input.int(10, \"MA length\", minval = 2)\nfloat ma = switch maType\n\"EMA\" => ta.ema(close, maLength)\n\"SMA\" => ta.sma(close, maLength)\n\"RMA\" => ta.rma(close, maLength)\n\"WMA\" => ta.wma(close, maLength)\n=>\nruntime.error(\"No matching MA type found.\")\nfloat(na)\nplot(ma)\nThe expression we are switching on is the variable maType, which is of “input int” type (see here for an explanation of what the “input” qualifier is). Since it cannot change during the execution of the script, this guarantees that whichever MA type the user selects will be executing on each bar, which is a requirement for functions like ta.ema() which require a “simple int” argument for their length parameter.\nIf no matching value is found for maType, the switch executes the last local block introduced by =>, which acts as a catch-all. We generate a runtime error in that block. We also end it with float(na) so the local block returns a value whose type is compatible with that of the other local blocks in the structure, to avoid a compilation error.\n`switch` without an expression¶\nThis is an example of a switch structure wich does not use an exppression:\nstrategy(\"Switch without an expression\", \"\", true)\nbool longCondition = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))\nbool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\nswitch\nlongCondition => strategy.entry(\"Long ID\", strategy.long)\nshortCondition => strategy.entry(\"Short ID\", strategy.short)\nWe are using the switch to select the appropriate strategy order to emit, depending on whether the longCondition or shortCondition “bool” variables are true.\nThe building conditions of longCondition and shortCondition are exclusive. While they can both be false simultaneously, they cannot be true at the same time. The fact that only one local block of the switch structure is ever executed is thus not an issue for us.\nWe evaluate the calls to ta.crossover() and ta.crossunder() prior to entry in the switch structure. Not doing so, as in the following example, would prevent the functions to be executed on each bar, which would result in a compiler warning and erratic behavior:\nstrategy(\"Switch without an expression\", \"\", true)\nswitch\n// Compiler warning! Will not calculate correctly!\nta.crossover( ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry(\"Long ID\", strategy.long)\nta.crossunder(ta.sma(close, 14), ta.sma(close, 28)) => strategy.entry(\"Short ID\", strategy.short)\nMatching local block type requirement¶\nWhen multiple local blocks are used in structures, the type of the return value of all its local blocks must match. This applies only if the structure is used to assign a value to a variable in a declaration, because a variable can only have one type, and if the statement returns two incompatible types in its branches, the variable type cannot be properly determined. If the structure is not assigned anywhere, its branches can return different values.\nThis code compiles fine because close and open are both of the float type:\nx = if close > open\nclose\nopen\nThis code does not compile because the first local block returns a float value, while the second one returns a string, and the result of the if-statement is assigned to the x variable:\n// Compilation error!\nx = if close > open\nclose\n\"open\""
},
{
  "text": "When loops are not needed¶\nPine Script™’s runtime and its built-in functions make loops unnecessary in many situations. Budding Pine Script™ programmers not yet familiar with the Pine Script™ runtime and built-ins who want to calculate the average of the last 10 close values will often write code such as:\nindicator(\"Inefficient MA\", \"\", true)\nMA_LENGTH = 10\nsumOfCloses = 0.0\nfor offset = 0 to MA_LENGTH - 1\nsumOfCloses := sumOfCloses + close[offset]\ninefficientMA = sumOfCloses / MA_LENGTH\nplot(inefficientMA)\nA for loop is unnecessary and inefficient to accomplish tasks like this in Pine. This is how it should be done. This code is shorter and will run much faster because it does not use a loop and uses the ta.sma() built-in function to accomplish the task:\nindicator(\"Efficient MA\", \"\", true)\nthePineMA = ta.sma(close, 10)\nplot(thePineMA)\nCounting the occurrences of a condition in the last bars is also a task which beginning Pine Script™ programmers often think must be done with a loop. To count the number of up bars in the last 10 bars, they will use:\nindicator(\"Inefficient sum\")\nMA_LENGTH = 10\nupBars = 0.0\nfor offset = 0 to MA_LENGTH - 1\nif close[offset] > open[offset]\nupBars := upBars + 1\nplot(upBars)\nThe efficient way to write this in Pine (for the programmer because it saves time, to achieve the fastest-loading charts, and to share our common resources most equitably), is to use the math.sum() built-in function to accomplish the task:\nindicator(\"Efficient sum\")\nupBars = math.sum(close > open ? 1 : 0, 10)\nplot(upBars)\nWhat’s happening in there is:\nWe use the ?: ternary operator to build an expression that yields 1 on up bars and 0 on other bars.\nWe use the math.sum() built-in function to keep a running sum of that value for the last 10 bars.\nWhen loops are necessary¶\nLoops exist for good reason because even in Pine Script™, they are necessary in some cases. These cases typically include:\nThe manipulation of collections (arrays, matrices, and maps).\nLooking back in history to analyze bars using a reference value that can only be known on the current bar, e.g., to find how many past highs are higher than the high of the current bar. Since the current bar’s high is only known on the bar the script is running on, a loop is necessary to go back in time and analyze past bars.\nPerforming calculations on past bars that cannot be accomplished using built-in functions.\n`for`¶\nThe for structure allows the repetitive execution of statements using a counter. Its syntax is:\n[[<declaration_mode>] [<type>] <identifier> = ]for <identifier> = <expression> to <expression>[ by <expression>]\n<local_block_loop>\nParts enclosed in square brackets ([]) can appear zero or one time, and those enclosed in curly braces ({}) can appear zero or more times.\n<declaration_mode> is the variable’s declaration mode\n<type> is optional, as in almost all Pine Script™ variable declarations (see types)\n<identifier> is a variable’s name\n<expression> can be a literal, a variable, an expression or a function call.\n<local_block_loop> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab. It can contain the break statement to exit the loop, or the continue statement to exit the current iteration and continue on with the next.\nThe value assigned to the variable is the return value of the <local_block_loop>, i.e., the last value calculated on the loop’s last iteration, or na if the loop is not executed.\nThe identifier in for <identifier> is the loop’s counter initial value.\nThe expression in = <expression> is the start value of the counter.\nThe expression in to <expression> is the end value of the counter. It is only evaluated upon entry in the loop.\nThe expression in by <expression> is optional. It is the step by which the loop counter is increased or decreased on each iteration of the loop. Its default value is 1 when start value < end value. It is -1 when start value > end value. The step (+1 or -1) used as the default is determined by the start and end values.\nThis example uses a for statement to look back a user-defined amount of bars to determine how many bars have a high that is higher or lower than the high of the last bar on the chart. A for loop is necessary here, since the script only has access to the reference value on the chart’s last bar. Pine Script™’s runtime cannot, here, be used to calculate on the fly, as the script is executing bar to bar:\nindicator(\"`for` loop\")\nlookbackInput = input.int(50, \"Lookback in bars\", minval = 1, maxval = 4999)\nhigherBars = 0\nlowerBars = 0\nvar label lbl = label.new(na, na, \"\", style = label.style_label_left)\nfor i = 1 to lookbackInput\nif high[i] > high\nhigherBars += 1\nelse if high[i] < high\nlowerBars += 1\nlabel.set_xy(lbl, bar_index, high)\nlabel.set_text(lbl, str.tostring(higherBars, \"# higher bars\\n\") + str.tostring(lowerBars, \"# lower bars\"))\nThis example uses a loop in its checkLinesForBreaches() function to go through an array of pivot lines and delete them when price crosses them. A loop is necessary here because all the lines in each of the hiPivotLines and loPivotLines arrays must be checked on each bar, and there is no built-in that can do this for us:\nMAX_LINES_COUNT = 100\nindicator(\"Pivot line breaches\", \"\", true, max_lines_count = MAX_LINES_COUNT)\ncolor hiPivotColorInput = input(color.new(color.lime, 0), \"High pivots\")\ncolor loPivotColorInput = input(color.new(color.fuchsia, 0), \"Low pivots\")\nint pivotLegsInput = input.int(5, \"Pivot legs\")\nint qtyOfPivotsInput = input.int(50, \"Quantity of last pivots to remember\", minval = 0, maxval = MAX_LINES_COUNT / 2)\nint maxLineLengthInput = input.int(400, \"Maximum line length in bars\", minval = 2)\n// ————— Queues a new element in an array and de-queues its first element.\nqDq(array, qtyOfElements, arrayElement) =>\narray.push(array, arrayElement)\nif array.size(array) > qtyOfElements\n// Only deqeue if array has reached capacity.\narray.shift(array)\n// —————— Loop through an array of lines, extending those that price has not crossed and deleting those crossed.\ncheckLinesForBreaches(arrayOfLines) =>\nint qtyOfLines = array.size(arrayOfLines)\n// Don't loop in case there are no lines to check because \"to\" value will be `na` then`.\nfor lineNo = 0 to (qtyOfLines > 0 ? qtyOfLines - 1 : na)\n// Need to check that array size still warrants a loop because we may have deleted array elements in the loop.\nif lineNo < array.size(arrayOfLines)\nline currentLine = array.get(arrayOfLines, lineNo)\nfloat lineLevel = line.get_price(currentLine, bar_index)\nbool lineWasCrossed = math.sign(close[1] - lineLevel) != math.sign(close - lineLevel)\nbool lineIsTooLong = bar_index - line.get_x1(currentLine) > maxLineLengthInput\nif lineWasCrossed or lineIsTooLong\n// Line stays on the chart but will no longer be extend on further bars.\narray.remove(arrayOfLines, lineNo)\n// Force type of both local blocks to same type.\nint(na)\nline.set_x2(currentLine, bar_index)\nint(na)\n// Arrays of lines containing non-crossed pivot lines.\nvar array<line> hiPivotLines = array.new_line(qtyOfPivotsInput)\nvar array<line> loPivotLines = array.new_line(qtyOfPivotsInput)\n// Detect new pivots.\nfloat hiPivot = ta.pivothigh(pivotLegsInput, pivotLegsInput)\nfloat loPivot = ta.pivotlow(pivotLegsInput, pivotLegsInput)\n// Create new lines on new pivots.\nif not na(hiPivot)\nline newLine = line.new(bar_index[pivotLegsInput], hiPivot, bar_index, hiPivot, color = hiPivotColorInput)\nline.delete(qDq(hiPivotLines, qtyOfPivotsInput, newLine))\nelse if not na(loPivot)\nline newLine = line.new(bar_index[pivotLegsInput], loPivot, bar_index, loPivot, color = loPivotColorInput)\nline.delete(qDq(loPivotLines, qtyOfPivotsInput, newLine))\n// Extend lines if they haven't been crossed by price.\ncheckLinesForBreaches(hiPivotLines)\ncheckLinesForBreaches(loPivotLines)\n`while`¶\nThe while structure allows the repetitive execution of statements until a condition is false. Its syntax is:\n[[<declaration_mode>] [<type>] <identifier> = ]while <expression>\n<local_block_loop>\nParts enclosed in square brackets ([]) can appear zero or one time.\n<declaration_mode> is the variable’s declaration mode\n<type> is optional, as in almost all Pine Script™ variable declarations (see types)\n<identifier> is a variable’s name\n<expression> can be a literal, a variable, an expression or a function call. It is evaluated at each iteration of the loop. When it evaluates to true, the loop executes. When it evaluates to false the loop stops. Note that evaluation of the expression is done before each iteration only. Changes to the expression’s value inside the loop will only have an impact on the next iteration.\n<local_block_loop> consists of zero or more statements followed by a return value, which can be a tuple of values. It must be indented by four spaces or a tab. It can contain the break statement to exit the loop, or the continue statement to exit the current iteration and continue on with the next.\nThe value assigned to the <identifier> variable is the return value of the <local_block_loop>, i.e., the last value calculated on the loop’s last iteration, or na if the loop is not executed.\nThis is the first code example of the for section written using a while structure instead of a for one:\nindicator(\"`for` loop\")\nlookbackInput = input.int(50, \"Lookback in bars\", minval = 1, maxval = 4999)\nhigherBars = 0\nlowerBars = 0\nvar label lbl = label.new(na, na, \"\", style = label.style_label_left)\n// Initialize the loop counter to its start value.\ni = 1\n// Loop until the `i` counter's value is <= the `lookbackInput` value.\nwhile i <= lookbackInput\nif high[i] > high\nhigherBars += 1\nelse if high[i] < high\nlowerBars += 1\n// Counter must be managed \"manually\".\ni += 1\nlabel.set_xy(lbl, bar_index, high)\nlabel.set_text(lbl, str.tostring(higherBars, \"# higher bars\\n\") + str.tostring(lowerBars, \"# lower bars\"))\nThe i counter must be incremented by one explicitly inside the while’s local block.\nWe use the += operator to add one to the counter. lowerBars += 1 is equivalent to lowerBars := lowerBars + 1.\nLet’s calculate the factorial function using a while structure:\nint n = input.int(10, \"Factorial of\", minval=0)\nfactorial(int val = na) =>\nint counter = val\nint fact = 1\nresult = while counter > 0\nfact := fact * counter\ncounter := counter - 1\nfact\n// Only evaluate the function on the first bar.\nvar answer = factorial(n)\nplot(answer)\nWe use input.int() for our input because we need to specify a minval value to protect our code. While input() also supports the input of “int” type values, it does not support the minval parameter.\nWe have packaged our script’s functionality in a factorial() function which accepts as an argument the value whose factorial it must calculate. We have used int val = na to declare our function’s parameter, which says that if the function is called without an argument, as in factorial(), then the val parameter will initialize to na, which will prevent the execution of the while loop because its counter > 0 expression will return na. The while structure will thus initialize the result variable to na. In turn, because the initialization of result is the return value of the our function’s local block, the function will return na.\nNote the last line of the while’s local block: fact. It is the local block’s return value, so the value it had on the while structure’s last iteration.\nOur initialization of result is not required; we do it for readability. We could just as well have used:\nwhile counter > 0\nfact := fact * counter\ncounter := counter - 1\nfact"
},
{
  "text": "Type system¶\nQualifiers\nconst\ninput\nsimple\nseries\nTypes\nint\nfloat\nbool\ncolor\nstring\nplot and hline\nDrawing types\nCollections\nUser-defined types\nvoid\n`na` value\nType templates\nType casting\nTuples\nThe Pine Script™ type system determines the compatibility of a script’s values with various functions and operations. While it’s possible to write simple scripts without knowing anything about the type system, a reasonable understanding of it is necessary to achieve any degree of proficiency with the language, and an in-depth knowledge of its subtleties will allow you to harness its full potential.\nPine Script™ uses types to classify all values, and it uses qualifiers to determine whether values are constant, established on the first script iteration, or dynamic throughout a script’s execution. This system applies to all Pine values, including those from literals, variables, expressions, function returns, and function arguments.\nThe type system closely intertwines with Pine’s execution model and time series concepts. Understanding all three is essential for making the most of the power of Pine Script™.\nFor the sake of brevity, we often use “type” to refer to a “qualified type”.\nQualifiers¶\nPine Script™ qualifiers identify when a value is accessible in the script’s execution:\nValues qualified as const are established at compile time (i.e., when saving the script in the Pine Editor or adding it to the chart).\nValues qualified as input are available at input time (i.e., when changing values in the script’s “Settings/Inputs” tab).\nValues qualified as simple are established at bar zero (the first bar of the script’s execution).\nValues qualified as series can change throughout the script’s execution.\nPine Script™ bases the dominance of type qualifiers on the following hierarchy: const < input < simple < series, where “const” is the weakest qualifier and “series” is the strongest. The qualifier hierarchy translates into this rule: whenever a variable, function, or operation is compatible with a specific qualified type, values with weaker qualifiers are also allowed.\nScripts always qualify their expressions’ returned values based on the dominant qualifier in their calculations. For example, evaluating an expression that involves “const” and “series” values will return a value qualified as “series”. Furthermore, scripts cannot change a value’s qualifier to one that’s lower on the hierarchy. If a value acquires a stronger qualifier (e.g., a value initially inferred as “simple” becomes “series” later in the script’s execution), that state is irreversible.\nNote that only values qualified as “series” can change throughout the execution of a script, which include those from various built-ins, such as close and volume, as well as the results of any operations that involve “series” values. Values qualified as “const”, “input”, or “simple” are consistent throughout a script’s execution.\nconst¶\nValues qualified as “const” are established at compile time, before the script starts its execution. Compilation initially occurs when saving a script in the Pine Editor, which does not require it to run on a chart. Values with the “const” qualifier never change between script iterations, not even on the initial bar of its execution.\nScripts can qualify values as “const” by using a literal value or calculating values from expressions that only use literal values or other variables qualified as “const”.\nThese are examples of literal values:\nliteral int: 1, -1, 42\nliteral float: 1., 1.0, 3.14, 6.02E-23, 3e8\nliteral bool: true, false\nliteral color: #FF55C6, #FF55C6ff\nliteral string: \"A text literal\", \"Embedded single quotes 'text'\", 'Embedded double quotes \"text\"'\nUsers can explicitly define variables and parameters that only accept “const” values by including the const keyword in their declaration.\nOur Style guide recommends using uppercase SNAKE_CASE to name “const” variables for readability. While it is not a requirement, one can also use the var keyword when declaring “const” variables so the script only initializes them on the first bar of the dataset. See this section of our User Manual for more information.\nBelow is an example that uses “const” values within indicator() and plot() functions, which both require a value of the “const string” qualified type as their title argument:\n// The following global variables are all of the \"const string\" qualified type:\n//@variable The title of the indicator.\nINDICATOR_TITLE = \"const demo\"\n//@variable The title of the first plot.\nvar PLOT1_TITLE = \"High\"\n//@variable The title of the second plot.\nconst string PLOT2_TITLE = \"Low\"\n//@variable The title of the third plot.\nPLOT3_TITLE = \"Midpoint between \" + PLOT1_TITLE + \" and \" + PLOT2_TITLE\nindicator(INDICATOR_TITLE, overlay = true)\nplot(high, PLOT1_TITLE)\nplot(low, PLOT2_TITLE)\nplot(hl2, PLOT3_TITLE)\nThe following example will raise a compilation error since it uses syminfo.ticker, which returns a “simple” value because it depends on chart information that’s only accessible once the script starts its execution:\n//@variable The title in the `indicator()` call.\nvar NAME = \"My indicator for \" + syminfo.ticker\nindicator(NAME, \"\", true) // Causes an error because `NAME` is qualified as a \"simple string\".\ninput¶\nValues qualified as “input” are established after initialization via the input.*() functions. These functions produce values that users can modify within the “Inputs” tab of the script’s settings. When one changes any of the values in this tab, the script re-executes from the beginning of the chart’s history to ensure its input values are consistent throughout its execution.\nThe input.source() function is an exception in the input.*() namespace, as it returns “series” qualified values rather than “input” since built-in variables such as open, close, etc., as well as the values from another script’s plots, are qualified as “series”.\nThe following script plots the value of a sourceInput from the symbolInput and timeframeInput context. The request.security() call is valid in this script since its symbol and timeframe parameters allow “simple string” arguments, meaning they can also accept “input string” values because the “input” qualifier is lower on the hierarchy:\nindicator(\"input demo\", overlay = true)\n//@variable The symbol to request data from. Qualified as \"input string\".\nsymbolInput = input.symbol(\"AAPL\", \"Symbol\")\n//@variable The timeframe of the data request. Qualified as \"input string\".\ntimeframeInput = input.timeframe(\"D\", \"Timeframe\")\n//@variable The source of the calculation. Qualified as \"series float\".\nsourceInput = input.source(close, \"Source\")\n//@variable The `sourceInput` value from the requested context. Qualified as \"series float\".\nrequestedSource = request.security(symbolInput, timeframeInput, sourceInput)\nplot(requestedSource)\nsimple¶\nValues qualified as “simple” are available only once the script begins execution on the first chart bar of its history, and they remain consistent during the script’s execution.\nUsers can explicitly define variables and parameters that accept “simple” values by including the simple keyword in their declaration.\nMany built-in variables return “simple” qualified values because they depend on information that a script can only obtain once it starts its execution. Additionally, many built-in functions require “simple” arguments that do not change over time. Wherever a script allows “simple” values, it can also accept values qualified as “input” or “const”.\nThis script highlights the background to warn users that they’re using a non-standard chart type. It uses the value of chart.is_standard to calculate the isNonStandard variable, then uses that variable’s value to calculate a warningColor that also references a “simple” value. The color parameter of bgcolor() allows a “series color” argument, meaning it can also accept a “simple color” value since “simple” is lower on the hierarchy:\nindicator(\"simple demo\", overlay = true)\n//@variable Is `true` when the current chart is non-standard. Qualified as \"simple bool\".\nisNonStandard = not chart.is_standard\n//@variable Is orange when the the current chart is non-standard. Qualified as \"simple color\".\nsimple color warningColor = isNonStandard ? color.new(color.orange, 70) : na\n// Colors the chart's background to warn that it's a non-standard chart type.\nbgcolor(warningColor, title = \"Non-standard chart color\")\nseries¶\nValues qualified as “series” provide the most flexibility in scripts since they can change on any bar, even multiple times on the same bar.\nUsers can explicitly define variables and parameters that accept “series” values by including the series keyword in their declaration.\nBuilt-in variables such as open, high, low, close, volume, time, and bar_index, and the result from any expression using such built-ins, are qualified as “series”. The result of any function or operation that returns a dynamic value will always be a “series”, as will the results from using the history-referencing operator [] to access historical values. Wherever a script allows “series” values, it will also accept values with any other qualifier, as “series” is the highest qualifier on the hierarchy.\nThis script displays the highest and lowest value of a sourceInput over lengthInput bars. The values assigned to the highest and lowest variables are of the “series float” qualified type, as they can change throughout the script’s execution:\nindicator(\"series demo\", overlay = true)\n//@variable The source value to calculate on. Qualified as \"series float\".\nseries float sourceInput = input.source(close, \"Source\")\n//@variable The number of bars in the calculation. Qualified as \"input int\".\nlengthInput = input.int(20, \"Length\")\n//@variable The highest `sourceInput` value over `lengthInput` bars. Qualified as \"series float\".\nseries float highest = ta.highest(sourceInput, lengthInput)\n//@variable The lowest `sourceInput` value over `lengthInput` bars. Qualified as \"series float\".\nlowest = ta.lowest(sourceInput, lengthInput)\nplot(highest, \"Highest source\", color.green)\nplot(lowest, \"Lowest source\", color.red)\nTypes¶\nPine Script™ types classify values and determine the functions and operations they’re compatible with. They include:\nThe fundamental types: int, float, bool, color, and string\nThe special types: plot, hline, line, linefill, box, polyline, label, table, chart.point, array, matrix, and map\nUser-defined types (UDTs)\nvoid\nFundamental types refer to the underlying nature of a value, e.g., a value of 1 is of the “int” type, 1.0 is of the “float” type, “AAPL” is of the “string” type, etc. Special types and user-defined types utilize IDs that refer to objects of a specific class. For example, a value of the “label” type contains an ID that acts as a pointer referring to a “label” object. The “void” type refers to the output from a function or method that does not return a usable value.\nPine Script™ can automatically convert values from some types into others. The auto-casting rules are: int → float → bool. See the Type casting section of this page for more information.\nIn most cases, Pine Script™ can automatically determine a value’s type. However, we can also use type keywords to explicitly specify types for readability and for code that requires explicit definitions (e.g., declaring a variable assigned to na). For example:\nindicator(\"Types demo\", overlay = true)\n//@variable A value of the \"const string\" type for the `ma` plot's title.\nstring MA_TITLE = \"MA\"\n//@variable A value of the \"input int\" type. Controls the length of the average.\nint lengthInput = input.int(100, \"Length\", minval = 2)\n//@variable A \"series float\" value representing the last `close` that crossed over the `ma`.\nvar float crossValue = na\n//@variable A \"series float\" value representing the moving average of `close`.\nfloat ma = ta.sma(close, lengthInput)\n//@variable A \"series bool\" value that's `true` when the `close` crosses over the `ma`.\nbool crossUp = ta.crossover(close, ma)\n//@variable A \"series color\" value based on whether `close` is above or below its `ma`.\ncolor maColor = close > ma ? color.lime : color.fuchsia\n// Update the `crossValue`.\nif crossUp\ncrossValue := close\nplot(ma, MA_TITLE, maColor)\nplot(crossValue, \"Cross value\", style = plot.style_circles)\nplotchar(crossUp, \"Cross Up\", \"▲\", location.belowbar, size = size.small)\nint¶\nValues of the “int” type represent integers, i.e., whole numbers without any fractional quantities.\nInteger literals are numeric values written in decimal notation. For example:\nBuilt-in variables such as bar_index, time, timenow, dayofmonth, and strategy.wintrades all return values of the “int” type.\nfloat¶\nValues of the “float” type represent floating-point numbers, i.e., numbers that can contain whole and fractional quantities.\nFloating-point literals are numeric values written with a . delimiter. They may also contain the symbol e or E (which means “10 raised to the power of X”, where X is the number after the e or E symbol). For example:\n3.14159 // Rounded value of Pi (π)\n- 3.0\n6.02e23 // 6.02 * 10^23 (a very large value)\n1.6e-19 // 1.6 * 10^-19 (a very small value)\nThe internal precision of “float” values in Pine Script™ is 1e-16.\nBuilt-in variables such as close, hlcc4, volume, ta.vwap, and strategy.position_size all return values of the “float” type.\nbool¶\nValues of the “bool” type represent the truth value of a comparison or condition, which scripts can use in conditional structures and other expressions.\nThere are only two literals that represent boolean values:\ntrue // true value\nfalse // false value\nWhen an expression of the “bool” type returns na, scripts treat its value as false when evaluating conditional statements and operators.\nBuilt-in variables such as barstate.isfirst, chart.is_heikinashi, session.ismarket, and timeframe.isdaily all return values of the “bool” type.\ncolor¶\nColor literals have the following format: #RRGGBB or #RRGGBBAA. The letter pairs represent hexadecimal values between 00 and FF (0 to 255 in decimal) where:\nRR, GG and BB pairs respectively represent the values for the color’s red, green and blue components.\nAA is an optional value for the color’s opacity (or alpha component) where 00 is invisible and FF opaque. When the literal does not include an AA pair, the script treats it as fully opaque (the same as using FF).\nThe hexadecimal letters in the literals can be uppercase or lowercase.\nThese are examples of “color” literals:\n#000000 // black color\n#FF0000 // red color\n#00FF00 // green color\n#0000FF // blue color\n#FFFFFF // white color\n#808080 // gray color\n#3ff7a0 // some custom color\n#FF000080 // 50% transparent red color\n#FF0000ff // same as #FF0000, fully opaque red color\n#FF000000 // completely transparent red color\nPine Script™ also has built-in color constants, including color.green, color.red, color.orange, color.blue (the default color in plot*() functions and many of the default color-related properties in drawing types), etc.\nWhen using built-in color constants, it is possible to add transparency information to them via the color.new() function.\nNote that when specifying red, green or blue components in color.*() functions, we use “int” or “float” arguments with values between 0 and 255. When specifying transparency, we use a value between 0 and 100, where 0 means fully opaque and 100 means completely transparent. For example:\nindicator(\"Shading the chart's background\", overlay = true)\n//@variable A \"const color\" value representing the base for each day's color.\ncolor BASE_COLOR = color.rgb(0, 99, 165)\n//@variable A \"series int\" value that modifies the transparency of the `BASE_COLOR` in `color.new()`.\nint transparency = 50 + int(40 * dayofweek / 7)\n// Color the background using the modified `BASE_COLOR`.\nbgcolor(color.new(BASE_COLOR, transparency))\nSee the User Manual’s page on colors for more information on using colors in scripts.\nstring¶\nValues of the “string” type represent sequences of letters, numbers, symbols, spaces, and other characters.\nString literals in Pine are characters enclosed in single or double quotation marks. For example:\n\"This is a string literal using double quotes.\"\n'This is a string literal using single quotes.'\nSingle and double quotation marks are functionally equivalent in Pine Script™. A “string” enclosed within double quotation marks can contain any number of single quotation marks and vice versa:\n\"It's an example\"\n'The \"Star\" indicator'\nScripts can escape the enclosing delimiter in a “string” using the backslash character (\\). For example:\n'It\\'s an example'\n\"The \\\"Star\\\" indicator\"\nWe can create “string” values containing the new line escape character (\\n) for displaying multi-line text with plot*() and log.*() functions and objects of drawing types. For example:\n\"This\\nString\\nHas\\nOne\\nWord\\nPer\\nLine\"\nWe can use the + operator to concatenate “string” values:\n\"This is a \" + \"concatenated string.\"\nThe built-ins in the str.*() namespace create “string” values using specialized operations. For instance, this script creates a formatted string to represent “float” price values and displays the result using a label:\nindicator(\"Formatted string demo\", overlay = true)\n//@variable A \"series string\" value representing the bar's OHLC data.\nstring ohlcString = str.format(\"Open: {0}\\nHigh: {1}\\nLow: {2}\\nClose: {3}\", open, high, low, close)\n// Draw a label containing the `ohlcString`.\nlabel.new(bar_index, high, ohlcString, textcolor = color.white)\nSee our User Manual’s page on Text and shapes for more information about displaying “string” values from a script.\nBuilt-in variables such as syminfo.tickerid, syminfo.currency, and timeframe.period return values of the “string” type.\nplot and hline¶\nPine Script™’s plot() and hline() functions return IDs that respectively reference instances of the “plot” and “hline” types. These types display calculated values and horizontal levels on the chart, and one can assign their IDs to variables for use with the built-in fill() function.\nFor example, this script plots two EMAs on the chart and fills the space between them using the fill() function:\nindicator(\"plot fill demo\", overlay = true)\n//@variable A \"series float\" value representing a 10-bar EMA of `close`.\nfloat emaFast = ta.ema(close, 10)\n//@variable A \"series float\" value representing a 20-bar EMA of `close`.\nfloat emaSlow = ta.ema(close, 20)\n//@variable The plot of the `emaFast` value.\nemaFastPlot = plot(emaFast, \"Fast EMA\", color.orange, 3)\n//@variable The plot of the `emaSlow` value.\nemaSlowPlot = plot(emaSlow, \"Slow EMA\", color.gray, 3)\n// Fill the space between the `emaFastPlot` and `emaSlowPlot`.\nfill(emaFastPlot, emaSlowPlot, color.new(color.purple, 50), \"EMA Fill\")\nIt’s important to note that unlike other special types, there is no plot or hline keyword in Pine to explicitly declare a variable’s type as “plot” or “hline”.\nUsers can control where their scripts’ plots display via the variables in the display.* namespace. Additionally, one script can use the values from another script’s plots as external inputs via the input.source() function (see our User Manual’s section on source inputs).\nDrawing types¶\nPine Script™ drawing types allow scripts to create custom drawings on charts. They include the following: line, linefill, box, polyline, label, and table.\nEach type also has a namespace containing all the built-ins that create and manage drawing instances. For example, the following *.new() constructors create new objects of these types in a script: line.new(), linefill.new(), box.new(), polyline.new(), label.new(), and table.new().\nEach of these functions returns an ID which is a reference that uniquely identifies a drawing object. IDs are always qualified as “series”, meaning their qualified types are “series line”, “series label”, etc. Drawing IDs act like pointers, as each ID references a specific instance of a drawing in all the functions from that drawing’s namespace. For instance, the ID of a line returned by a line.new() call is used later to refer to that specific object once it’s time to delete it with line.delete().\nChart points¶\nChart points are special types that represent coordinates on the chart. Scripts use the information from chart.point objects to determine the chart locations of lines, boxes, polylines, and labels.\nObjects of this type contain three fields: time, index, and price. Whether a drawing instance uses the time or price field from a chart.point as an x-coordinate depends on the drawing’s xloc property.\nWe can use any of the following functions to create chart points in a script:\nchart.point.new() - Creates a new chart.point with a specified time, index, and price.\nchart.point.now() - Creates a new chart.point with a specified price y-coordinate. The time and index fields contain the time and bar_index of the bar the function executes on.\nchart.point_from_index() - Creates a new chart.point with an index x-coordinate and price y-coordinate. The time field of the resulting instance is na, meaning it will not work with drawing objects that use an xloc value of xloc.bar_time.\nchart.point.from_time() - Creates a new chart.point with a time x-coordinate and price y-coordinate. The index field of the resulting instance is na, meaning it will not work with drawing objects that use an xloc value of xloc.bar_index.\nchart.point.copy() - Creates a new chart.point containing the same time, index, and price information as the id in the function call.\nThis example draws lines connecting the previous bar’s high to the current bar’s low on each chart bar. It also displays labels at both points of each line. The line and labels get their information from the firstPoint and secondPoint variables, which reference chart points created using chart.point_from_index() and chart.point.now():\nindicator(\"Chart points demo\", overlay = true)\n//@variable A new `chart.point` at the previous `bar_index` and `high`.\nfirstPoint = chart.point.from_index(bar_index - 1, high[1])\n//@variable A new `chart.point` at the current bar's `low`.\nsecondPoint = chart.point.now(low)\n// Draw a new line connecting coordinates from the `firstPoint` and `secondPoint`.\n// This line uses the `index` fields from the points as x-coordinates.\nline.new(firstPoint, secondPoint, color = color.purple, width = 3)\n// Draw a label at the `firstPoint`. Uses the point's `index` field as its x-coordinate.\nfirstPoint, str.tostring(firstPoint.price), color = color.green,\nstyle = label.style_label_down, textcolor = color.white\n// Draw a label at the `secondPoint`. Uses the point's `index` field as its x-coordinate.\nsecondPoint, str.tostring(secondPoint.price), color = color.red,\nstyle = label.style_label_up, textcolor = color.white\nCollections¶\nCollections in Pine Script™ (arrays, matrices, and maps) utilize reference IDs, much like other special types (e.g., labels). The type of the ID defines the type of elements the collection will contain. In Pine, we specify array, matrix, and map types by appending a type template to the array, matrix, or map keywords:\narray<int> defines an array containing “int” elements.\narray<label> defines an array containing “label” IDs.\narray<UDT> defines an array containing IDs referencing objects of a user-defined type (UDT).\nmatrix<float> defines a matrix containing “float” elements.\nmatrix<UDT> defines a matrix containing IDs referencing objects of a user-defined type (UDT).\nmap<string, float> defines a map containing “string” keys and “float” values.\nmap<int, UDT> defines a map containing “int” keys and IDs of user-defined type (UDT) instances as values.\nFor example, one can declare an “int” array with a single element value of 10 in any of the following, equivalent ways:\na1 = array.new<int>(1, 10)\narray<int> a2 = array.new<int>(1, 10)\na3 = array.from(10)\narray<int> a4 = array.from(10)\nThe int[] syntax can also specify an array of “int” elements, but its use is discouraged. No equivalent exists to specify the types of matrices or maps in that way.\nType-specific built-ins exist for arrays, such as array.new_int(), but the more generic array.new<type> form is preferred, which would be array.new<int>() to create an array of “int” elements.\nUser-defined types¶\nThe type keyword allows the creation of user-defined types (UDTs) from which scripts can create objects. UDTs are composite types; they contain an arbitrary number of fields that can be of any type, including other user-defined types. The syntax to define a user-defined type is:\n[export] type <UDT_identifier>\n<field_type> <field_name> [= <value>]\n...\nexport is the keyword that a library script uses to export the user-defined type. To learn more about exporting UDTs, see our User Manual’s Libraries page.\n<UDT_identifier> is the name of the user-defined type.\n<field_type> is the type of the field.\n<field_name> is the name of the field.\n<value> is an optional default value for the field, which the script will assign to it when creating new objects of that UDT. If one does not provide a value, the field’s default is na. The same rules as those governing the default values of parameters in function signatures apply to the default values of fields. For example, a UDT’s default values cannot use results from the history-referencing operator [] or expressions.\nThis example declares a pivotPoint UDT with an “int” pivotTime field and a “float” priceLevel field that will respectively hold time and price information about a calculated pivot:\n//@type A user-defined type containing pivot information.\n//@field pivotTime Contains time information about the pivot.\n//@field priceLevel Contains price information about the pivot.\ntype pivotPoint\nint pivotTime\nfloat priceLevel\nUser-defined types support type recursion, i.e., the fields of a UDT can reference objects of the same UDT. Here, we’ve added a nextPivot field to our previous pivotPoint type that references another pivotPoint instance:\n//@type A user-defined type containing pivot information.\n//@field pivotTime Contains time information about the pivot.\n//@field priceLevel Contains price information about the pivot.\n//@field nextPivot A `pivotPoint` instance containing additional pivot information.\ntype pivotPoint\nint pivotTime\nfloat priceLevel\npivotPoint nextPivot\nScripts can use two built-in methods to create and copy UDTs: new() and copy(). See our User Manual’s page on Objects to learn more about working with UDTs.\nvoid¶\nThere is a “void” type in Pine Script™. Functions having only side-effects and returning no usable result return the “void” type. An example of such a function is alert(); it does something (triggers an alert event), but it returns no usable value.\nScripts cannot use “void” results in expressions or assign them to variables. No void keyword exists in Pine Script™ since one cannot declare a variable of the “void” type.\n`na` value¶\nThere is a special value in Pine Script™ called na, which is an acronym for not available. We use na to represent an undefined value from a variable or expression. It is similar to null in Java and None in Python.\nScripts can automatically cast na values to almost any type. However, in some cases, the compiler cannot infer the type associated with an na value because more than one type-casting rule may apply. For example:\n// Compilation error!\nmyVar = na\nThe above line of code causes a compilation error because the compiler cannot determine the nature of the myVar variable, i.e., whether the variable will reference numeric values for plotting, string values for setting text in a label, or other values for some other purpose later in the script’s execution.\nTo resolve such errors, we must explicitly declare the type associated with the variable. Suppose the myVar variable will reference “float” values in subsequent script iterations. We can resolve the error by declaring the variable with the float keyword:\nor by explicitly casting the na value to the “float” type via the float() function:\nTo test if the value from a variable or expression is na, we call the na() function, which returns true if the value is undefined. For example:\n//@variable Is 0 if the `myVar` is `na`, `close` otherwise.\nfloat myClose = na(myVar) ? 0 : close\nDo not use the == comparison operator to test for na values, as scripts cannot determine the equality of an undefined value:\n//@variable Returns the `close` value. The script cannot compare the equality of `na` values, as they're undefined.\nfloat myClose = myVar == na ? 0 : close\nBest coding practices often involve handling na values to prevent undefined values in calculations.\nFor example, this line of code checks if the close value on the current bar is greater than the previous bar’s value:\n//@variable Is `true` when the `close` exceeds the last bar's `close`, `false` otherwise.\nbool risingClose = close > close[1]\nOn the first chart bar, the value of risingClose is na since there is no past close value to reference.\nWe can ensure the expression also returns an actionable value on the first bar by replacing the undefined past value with a value from the current bar. This line of code uses the nz() function to replace the past bar’s close with the current bar’s open when the value is na:\n//@variable Is `true` when the `close` exceeds the last bar's `close` (or the current `open` if the value is `na`).\nbool risingClose = close > nz(close[1], open)\nProtecting scripts against na instances helps to prevent undefined values from propagating in a calculation’s results. For example, this script declares an allTimeHigh variable on the first bar. It then uses the math.max() between the allTimeHigh and the bar’s high to update the allTimeHigh throughout its execution:\nindicator(\"na protection demo\", overlay = true)\n//@variable The result of calculating the all-time high price with an initial value of `na`.\nvar float allTimeHigh = na\n// Reassign the value of the `allTimeHigh`.\n// Returns `na` on all bars because `math.max()` can't compare the `high` to an undefined value.\nallTimeHigh := math.max(allTimeHigh, high)\nplot(allTimeHigh) // Plots `na` on all bars.\nThis script plots a value of na on all bars, as we have not included any na protection in the code. To fix the behavior and plot the intended result (i.e., the all-time high of the chart’s prices), we can use nz() to replace na values in the allTimeHigh series:\nindicator(\"na protection demo\", overlay = true)\n//@variable The result of calculating the all-time high price with an initial value of `na`.\nvar float allTimeHigh = na\n// Reassign the value of the `allTimeHigh`.\n// We've used `nz()` to prevent the initial `na` value from persisting throughout the calculation.\nallTimeHigh := math.max(nz(allTimeHigh), high)\nplot(allTimeHigh)\nType templates¶\nType templates specify the data types that collections (arrays, matrices, and maps) can contain.\nTemplates for arrays and matrices consist of a single type identifier surrounded by angle brackets, e.g., <int>, <label>, and <PivotPoint> (where PivotPoint is a user-defined type (UDT)).\nTemplates for maps consist of two type identifiers enclosed in angle brackets, where the first specifies the type of keys in each key-value pair, and the second specifies the value type. For example, <string, float> is a type template for a map that holds string keys and float values.\nUsers can construct type templates from:\nFundamental types: int, float, bool, color, and string\nThe following special types: line, linefill, box, polyline, label, table, and chart.point\nUser-defined types (UDTs)\nMaps can use any of these types as values, but they can only accept fundamental types as keys.\nScripts use type templates to declare variables that point to collections, and when creating new collection instances. For example:\nindicator(\"Type templates demo\")\n//@variable A variable initially assigned to `na` that accepts arrays of \"int\" values.\narray<int> intArray = na\n//@variable An empty matrix that holds \"float\" values.\nfloatMatrix = matrix.new<float>()\n//@variable An empty map that holds \"string\" keys and \"color\" values.\nstringColorMap = map.new<string, color>()\nType casting¶\nPine Script™ includes an automatic type-casting mechanism that casts (converts) “int” values to “float” when necessary. Variables or expressions requiring “float” values can also use “int” values because any integer can be represented as a floating point number with its fractional part equal to 0.\nFor the sake of backward compatibility, Pine Script™ also automatically casts “int” and “float” values to “bool” when necessary. When passing numeric values to the parameters of functions and operations that expect “bool” types, Pine auto-casts them to “bool”. However, we do not recommend relying on this behavior. Most scripts that automatically cast numeric values to the “bool” type will produce a compiler warning. One can avoid the compiler warning and promote code readability by using the bool() function, which explicitly casts a numeric value to the “bool” type.\nWhen casting an “int” or “float” to “bool”, a value of 0 converts to false and any other numeric value always converts to true.\nThis code below demonstrates deprecated auto-casting behavior in Pine. It creates a randomValue variable with a “series float” value on every bar, which it passes to the condition parameter in an if structure and the series parameter in a plotchar() function call. Since both parameters accept “bool” values, the script automatically casts the randomValue to “bool” when evaluating them:\nindicator(\"Auto-casting demo\", overlay = true)\n//@variable A random rounded value between -1 and 1.\nfloat randomValue = math.round(math.random(-1, 1))\n//@variable The color of the chart background.\ncolor bgColor = na\n// This raises a compiler warning since `randomValue` is a \"float\", but `if` expects a \"bool\".\nif randomValue\nbgColor := color.new(color.blue, 60)\n// This does not raise a warning, as the `bool()` function explicitly casts the `randomValue` to \"bool\".\nif bool(randomValue)\nbgColor := color.new(color.blue, 60)\n// Display unicode characters on the chart based on the `randomValue`.\n// Whenever `math.random()` returns 0, no character will appear on the chart because 0 converts to `false`.\nplotchar(randomValue)\n// We recommend explicitly casting the number with the `bool()` function to make the type transformation more obvious.\nplotchar(bool(randomValue))\n// Highlight the background with the `bgColor`.\nbgcolor(bgColor)\nIt’s sometimes necessary to cast one type to another when auto-casting rules do not suffice. For such cases, the following type-casting functions are available: int(), float(), bool(), color(), string(), line(), linefill(), label(), box(), and table().\nThe example below shows a code that tries to use a “const float” value as the length argument in the ta.sma() function call. The script will fail to compile, as it cannot automatically convert the “float” value to the required “int” type:\nindicator(\"Explicit casting demo\", overlay = true)\n//@variable The length of the SMA calculation. Qualified as \"const float\".\nfloat LENGTH = 10.0\nfloat sma = ta.sma(close, LENGTH) // Compilation error. The `length` parameter requires an \"int\" value.\nplot(sma)\nThe code raises the following error: “Cannot call ‘ta.sma’ with argument ‘length’=’LENGTH’. An argument of ‘const float’ type was used but a ‘series int’ is expected.”\nThe compiler is telling us that the code is using a “float” value where an “int” is required. There is no auto-casting rule to cast a “float” to an “int”, so we must do the job ourselves. In this version of the code, we’ve used the int() function to explicitly convert our “float” LENGTH value to the “int” type within the ta.sma() call:\nindicator(\"explicit casting demo\")\n//@variable The length of the SMA calculation. Qualified as \"const float\".\nfloat LENGTH = 10.0\nfloat sma = ta.sma(close, int(LENGTH)) // Compiles successfully since we've converted the `LENGTH` to \"int\".\nplot(sma)\nExplicit type casting is also handy when declaring variables assigned to na, as explained in the previous section.\nFor example, once could explicitly declare a variable with a value of na as a “label” type in either of the following, equivalent ways:\n// Explicitly specify that the variable references \"label\" objects:\nlabel myLabel = na\n// Explicitly cast the `na` value to the \"label\" type:\nmyLabel = label(na)\nTuples¶\nA tuple is a comma-separated set of expressions enclosed in brackets. When a function, method, or other local block returns more than one value, scripts return those values in the form of a tuple.\nFor example, the following user-defined function returns the sum and product of two “float” values:\n//@function Calculates the sum and product of two values.\ncalcSumAndProduct(float a, float b) =>\n//@variable The sum of `a` and `b`.\nfloat sum = a + b\n//@variable The product of `a` and `b`.\nfloat product = a * b\n// Return a tuple containing the `sum` and `product`.\n[sum, product]\nWhen we call this function later in the script, we use a tuple declaration to declare multiple variables corresponding to the values returned by the function call:\n// Declare a tuple containing the sum and product of the `high` and `low`, respectively.\n[hlSum, hlProduct] = calcSumAndProduct(high, low)\nKeep in mind that unlike declaring single variables, we cannot explicitly define the types the tuple’s variables (hlSum and hlProduct in this case), will contain. The compiler automatically infers the types associated with the variables in a tuple.\nIn the above example, the resulting tuple contains values of the same type (“float”). However, it’s important to note that tuples can contain values of multiple types. For example, the chartInfo() function below returns a tuple containing “int”, “float”, “bool”, “color”, and “string” values:\n//@function Returns information about the current chart.\nchartInfo() =>\n//@variable The first visible bar's UNIX time value.\nint firstVisibleTime = chart.left_visible_bar_time\n//@variable The `close` value at the `firstVisibleTime`.\nfloat firstVisibleClose = ta.valuewhen(ta.cross(time, firstVisibleTime), close, 0)\n//@variable Is `true` when using a standard chart type, `false` otherwise.\nbool isStandard = chart.is_standard\n//@variable The foreground color of the chart.\ncolor fgColor = chart.fg_color\n//@variable The ticker ID of the current chart.\nstring symbol = syminfo.tickerid\n// Return a tuple containing the values.\n[firstVisibleTime, firstVisibleClose, isStandard, fgColor, symbol]\nTuples are especially handy for requesting multiple values in one request.security() call.\nFor instance, this roundedOHLC() function returns a tuple containing OHLC values rounded to the nearest prices that are divisible by the symbol’s minimum tick value. We call this function as the expression argument in request.security() to request a tuple containing daily OHLC values:\n//@function Returns a tuple of OHLC values, rounded to the nearest tick.\nroundedOHLC() =>\n[math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]\n[op, hi, lo, cl] = request.security(syminfo.tickerid, \"D\", roundedOHLC())\nWe can also achieve the same result by directly passing a tuple of rounded values as the expression in the request.security() call:\n[op, hi, lo, cl] = request.security(\nsyminfo.tickerid, \"D\",\n[math.round_to_mintick(open), math.round_to_mintick(high), math.round_to_mintick(low), math.round_to_mintick(close)]\nLocal blocks of conditional structures, including if and switch statements, can return tuples. For example:\n[v1, v2] = if close > open\n[high, close]\n[close, low]\nand:\n[v1, v2] = switch\nclose > open => [high, close]\n=> [close, low]\nHowever, ternaries cannot contain tuples, as the return values in a ternary statement are not considered local blocks:\n// Not allowed.\n[v1, v2] = close > open ? [high, close] : [close, low]\nNote that all items within a tuple returned from a function are qualified as “simple” or “series”, depending on its contents. If a tuple contains a “series” value, all other elements within the tuple will also adopt the “series” qualifier. For example:\nindicator(\"Qualified types in tuples demo\")\nmakeTicker(simple string prefix, simple string ticker) =>\ntId = prefix + \":\" + ticker // simple string\nsource = close // series float\n[tId, source]\n// Both variables are series now.\n[tId, source] = makeTicker(\"BATS\", \"AAPL\")\n// Error cannot call 'request.security' with 'series string' tId.\nr = request.security(tId, \"\", source)\nplot(r)"
},
{
  "text": "Pine Script™ has hundreds of built-in variables and functions. They provide your scripts with valuable information and make calculations for you, dispensing you from coding them. The better you know the built-ins, the more you will be able to do with your Pine scripts.\nIn this page we present an overview of some of Pine Script™’s built-in variables and functions. They will be covered in more detail in the pages of this manual covering specific themes.\nAll built-in variables and functions are defined in the Pine Script™ v5 Reference Manual. It is called a “Reference Manual” because it is the definitive reference on the Pine Script™ language. It is an essential tool that will accompany you anytime you code in Pine, whether you are a beginner or an expert. If you are learning your first programming language, make the Reference Manual your friend. Ignoring it will make your programming experience with Pine Script™ difficult and frustrating — as it would with any other programming language.\nVariables and functions in the same family share the same namespace, which is a prefix to the function’s name. The ta.sma() function, for example, is in the ta namespace, which stands for “technical analysis”. A namespace can contain both variables and functions.\nSome variables have function versions as well, e.g.:\nThe ta.tr variable returns the “True Range” of the current bar. The ta.tr(true) function call also returns the “True Range”, but when the previous close value which is normally needed to calculate it is na, it calculates using high - low instead.\nThe time variable gives the time at the open of the current bar. The time(timeframe) function returns the time of the bar’s open from the timeframe specified, even if the chart’s timeframe is different. The time(timeframe, session) function returns the time of the bar’s open from the timeframe specified, but only if it is within the session time. The time(timeframe, session, timezone) function returns the time of the bar’s open from the timeframe specified, but only if it is within the session time in the specified timezone.\nBuilt-in variables¶\nBuilt-in variables exist for different purposes. These are a few examples:\nPrice- and volume-related variables: open, high, low, close, hl2, hlc3, ohlc4, and volume.\nSymbol-related information in the syminfo namespace: syminfo.basecurrency, syminfo.currency, syminfo.description, syminfo.mintick, syminfo.pointvalue, syminfo.prefix, syminfo.root, syminfo.session, syminfo.ticker, syminfo.tickerid, syminfo.timezone, and syminfo.type.\nTimeframe (a.k.a. “interval” or “resolution”, e.g., 15sec, 30min, 60min, 1D, 3M) variables in the timeframe namespace: timeframe.isseconds, timeframe.isminutes, timeframe.isintraday, timeframe.isdaily, timeframe.isweekly, timeframe.ismonthly, timeframe.isdwm, timeframe.multiplier, and timeframe.period.\nBar states in the barstate namespace (see the Bar states page): barstate.isconfirmed, barstate.isfirst, barstate.ishistory, barstate.islast, barstate.islastconfirmedhistory, barstate.isnew, and barstate.isrealtime.\nStrategy-related information in the strategy namespace: strategy.equity, strategy.initial_capital, strategy.grossloss, strategy.grossprofit, strategy.wintrades, strategy.losstrades, strategy.position_size, strategy.position_avg_price, strategy.wintrades, etc.\nBuilt-in functions¶\nMany functions are used for the result(s) they return. These are a few examples:\nMath-related functions in the math namespace: math.abs(), math.log(), math.max(), math.random(), math.round_to_mintick(), etc.\nTechnical indicators in the ta namespace: ta.sma(), ta.ema(), ta.macd(), ta.rsi(), ta.supertrend(), etc.\nSupport functions often used to calculate technical indicators in the ta namespace: ta.barssince(), ta.crossover(), ta.highest(), etc.\nFunctions to request data from other symbols or timeframes in the request namespace: request.dividends(), request.earnings(), request.financial(), request.quandl(), request.security(), request.splits().\nFunctions to manipulate strings in the str namespace: str.format(), str.length(), str.tonumber(), str.tostring(), etc.\nFunctions used to define the input values that script users can modify in the script’s “Settings/Inputs” tab, in the input namespace: input(), input.color(), input.int(), input.session(), input.symbol(), etc.\nFunctions used to manipulate colors in the color namespace: color.from_gradient(), color.new(), color.rgb(), etc.\nSome functions do not return a result but are used for their side effects, which means they do something, even if they don’t return a result:\nFunctions used as a declaration statement defining one of three types of Pine scripts, and its properties. Each script must begin with a call to one of these functions: indicator(), strategy() or library().\nPlotting or coloring functions: bgcolor(), plotbar(), plotcandle(), plotchar(), plotshape(), fill().\nStrategy functions placing orders, in the strategy namespace: strategy.cancel(), strategy.close(), strategy.entry(), strategy.exit(), strategy.order(), etc.\nStrategy functions returning information on indivdual past trades, in the strategy namespace: strategy.closedtrades.entry_bar_index(), strategy.closedtrades.entry_price(), strategy.closedtrades.entry_time(), strategy.closedtrades.exit_bar_index(), strategy.closedtrades.max_drawdown(), strategy.closedtrades.max_runup(), strategy.closedtrades.profit(), etc.\nFunctions to generate alert events: alert() and alertcondition().\nOther functions return a result, but we don’t always use it, e.g.: hline(), plot(), array.pop(), label.new(), etc.\nAll built-in functions are defined in the Pine Script™ v5 Reference Manual. You can click on any of the function names listed here to go to its entry in the Reference Manual, which documents the function’s signature, i.e., the list of parameters it accepts and the qualified type of the value(s) it returns (a function can return more than one result). The Reference Manual entry will also list, for each parameter:\nIts name.\nThe qualified type of the value it requires (we use argument to name the values passed to a function when calling it).\nIf the parameter is required or not.\nAll built-in functions have one or more parameters defined in their signature. Not all parameters are required for every function.\nLet’s look at the ta.vwma() function, which returns the volume-weighted moving average of a source value. This is its entry in the Reference Manual:\nThe entry gives us the information we need to use it:\nWhat the function does.\nIts signature (or definition):\nta.vwma(source, length) → series float\nThe parameters it includes: source and length\nThe qualified type of the result it returns: “series float”.\nAn example showing it in use: plot(ta.vwma(close, 15)).\nAn example showing what it does, but in long form, so you can better understand its calculations. Note that this is meant to explain — not as usable code, because it is more complicated and takes longer to execute. There are only disadvantages to using the long form.\nThe “RETURNS” section explains exacty what value the function returns.\nThe “ARGUMENTS” section lists each parameter and gives the critical information concerning what qualified type is required for arguments used when calling the function.\nThe “SEE ALSO” section refers you to related Reference Manual entries.\nThis is a call to the function in a line of code that declares a myVwma variable and assigns the result of ta.vwma(close, 20) to it:\nmyVwma = ta.vwma(close, 20)\nWe use the built-in variable close as the argument for the source parameter.\nWe use 20 as the argument for the length parameter.\nIf placed in the global scope (i.e., starting in a line’s first position), it will be executed by the Pine Script™ runtime on each bar of the chart.\nWe can also use the parameter names when calling the function. Parameter names are called keyword arguments when used in a function call:\nmyVwma = ta.vwma(source = close, length = 20)\nYou can change the position of arguments when using keyword arguments, but only if you use them for all your arguments. When calling functions with many parameters such as indicator(), you can also forego keyword arguments for the first arguments, as long as you don’t skip any. If you skip some, you must then use keyword arguments so the Pine Script™ compiler can figure out which parameter they correspond to, e.g.:\nindicator(\"Example\", \"Ex\", true, max_bars_back = 100)\nMixing things up this way is not allowed:\nindicator(precision = 3, \"Example\") // Compilation error!\nWhen calling built-ins, it is critical to ensure that the arguments you use are of the required qualified type, which will vary for each parameter.\nTo learn how to do this, one needs to understand Pine Script™’s type system. The Reference Manual entry for each built-in function includes an “ARGUMENTS” section which lists the qualified type required for the argument supplied to each of the function’s parameters."
},
{
  "text": "User-defined functions¶\nSingle-line functions\nMulti-line functions\nScopes in the script\nFunctions that return multiple results\nLimitations\nUser-defined functions are functions that you write, as opposed to the built-in functions in Pine Script™. They are useful to define calculations that you must do repetitevely, or that you want to isolate from your script’s main section of calculations. Think of user-defined functions as a way to extend the capabilities of Pine Script™, when no built-in function will do what you need.\nYou can write your functions in two ways:\nIn a single line, when they are simple, or\nOn multiple lines\nFunctions can be located in two places:\nIf a function is only used in one script, you can include it in the script where it is used. See our Style guide for recommendations on where to place functions in your script.\nYou can create a Pine Script™ library to include your functions, which makes them reusable in other scripts without having to copy their code. Distinct requirements exist for library functions. They are explained in the page on libraries.\nWhether they use one line or multiple lines, user-defined functions have the following characteristics:\nThey cannot be embedded. All functions are defined in the script’s global scope.\nThey do not support recursion. It is not allowed for a function to call itself from within its own code.\nThe type of the value returned by a function is determined automatically and depends on the type of arguments used in each particular function call.\nA function’s returned value is that of the last value in the function’s body.\nEach instance of a function call in a script maintains its own, independent history.\nSingle-line functions¶\nSimple functions can often be written in one line. This is the formal definition of single-line functions:\n<function_declaration>\n<identifier>(<parameter_list>) => <return_value>\n<parameter_list>\n{<parameter_definition>{, <parameter_definition>}}\n<parameter_definition>\n[<identifier> = <default_value>]\n<return_value>\n<statement> | <expression> | <tuple>\nHere is an example:\nAfter the function f() has been declared, it’s possible to call it using different types of arguments:\na = f(open, close)\nb = f(2, 2)\nc = f(open, 2)\nIn the example above, the type of variable a is series because the arguments are both series. The type of variable b is integer because arguments are both literal integers. The type of variable c is series because the addition of a series and literal integer produces a series result.\nMulti-line functions¶\nPine Script™ also supports multi-line functions with the following syntax:\n<identifier>(<parameter_list>) =>\n<local_block>\n<identifier>(<list of parameters>) =>\n<variable declaration>\n...\n<variable declaration or expression>\n<parameter_list>\n{<parameter_definition>{, <parameter_definition>}}\n<parameter_definition>\n[<identifier> = <default_value>]\nThe body of a multi-line function consists of several statements. Each statement is placed on a separate line and must be preceded by 1 indentation (4 spaces or 1 tab). The indentation before the statement indicates that it is a part of the body of the function and not part of the script’s global scope. After the function’s code, the first statement without an indent indicates the body of the function has ended.\nEither an expression or a declared variable should be the last statement of the function’s body. The result of this expression (or variable) will be the result of the function’s call. For example:\ngeom_average(x, y) =>\na = x*x\nb = y*y\nmath.sqrt(a + b)\nThe function geom_average has two arguments and creates two variables in the body: a and b. The last statement calls the function math.sqrt (an extraction of the square root). The geom_average call will return the value of the last expression: (math.sqrt(a + b)).\nScopes in the script¶\nVariables declared outside the body of a function or of other local blocks belong to the global scope. User-declared and built-in functions, as well as built-in variables also belong to the global scope.\nEach function has its own local scope. All the variables declared within the function, as well as the function’s arguments, belong to the scope of that function, meaning that it is impossible to reference them from outside — e.g., from the global scope or the local scope of another function.\nOn the other hand, since it is possible to refer to any variable or function declared in the global scope from the scope of a function (except for self-referencing recursive calls), one can say that the local scope is embedded into the global scope.\nIn Pine Script™, nested functions are not allowed, i.e., one cannot declare a function inside another one. All user functions are declared in the global scope. Local scopes cannot intersect with each other.\nFunctions that return multiple results¶\nIn most cases a function returns only one result, but it is possible to return a list of results (a tuple-like result):\nfun(x, y) =>\na = x+y\nb = x-y\n[a, b]\nSpecial syntax is required for calling such functions:\n[res0, res1] = fun(open, close)\nplot(res0)\nplot(res1)\nLimitations¶\nUser-defined functions can use any of the Pine Script™ built-ins, except: barcolor(), fill(), hline(), indicator(), library(), plot(), plotbar(), plotcandle(), plotchar(), plotshape() and strategy()."
},
{
  "text": "Objects¶\nCreating objects\nChanging field values\nCollecting objects\nCopying objects\nShadowing\nThis page contains advanced material. If you are a beginning Pine Script™ programmer, we recommend you become familiar with other, more accessible Pine Script™ features before you venture here.\nPine Script™ objects are instances of user-defined types (UDTs). They are the equivalent of variables containing parts called fields, each able to hold independent values that can be of various types.\nExperienced programmers can think of UDTs as methodless classes. They allow users to create custom types that organize different values under one logical entity.\nCreating objects¶\nBefore an object can be created, its type must be defined. The User-defined types section of the Type system page explains how to do so.\nLet’s define a pivotPoint type to hold pivot information:\ntype pivotPoint\nint x\nfloat y\nstring xloc = xloc.bar_time\nWe use the type keyword to declare the creation of a UDT.\nWe name our new UDT pivotPoint.\nAfter the first line, we create a local block containing the type and name of each field.\nThe x field will hold the x-coordinate of the pivot. It is declared as an “int” because it will hold either a timestamp or a bar index of “int” type.\ny is a “float” because it will hold the pivot’s price.\nxloc is a field that will specify the units of x: xloc.bar_index or xloc.bar_time. We set its default value to xloc.bar_time by using the = operator. When an object is created from that UDT, its xloc field will thus be set to that value.\nNow that our pivotPoint UDT is defined, we can proceed to create objects from it. We create objects using the UDT’s new() built-in method. To create a new foundPoint object from our pivotPoint UDT, we use:\nfoundPoint = pivotPoint.new()\nWe can also specify field values for the created object using the following:\nfoundPoint = pivotPoint.new(time, high)\nOr the equivalent:\nfoundPoint = pivotPoint.new(x = time, y = high)\nAt this point, the foundPoint object’s x field will contain the value of the time built-in when it is created, y will contain the value of high and the xloc field will contain its default value of xloc.bar_time because no value was defined for it when creating the object.\nObject placeholders can also be created by declaring na object names using the following:\npivotPoint foundPoint = na\nThis example displays a label where high pivots are detected. The pivots are detected legsInput bars after they occur, so we must plot the label in the past for it to appear on the pivot:\nindicator(\"Pivot labels\", overlay = true)\nint legsInput = input(10)\n// Define the `pivotPoint` UDT.\ntype pivotPoint\nint x\nfloat y\nstring xloc = xloc.bar_time\n// Detect high pivots.\npivotHighPrice = ta.pivothigh(legsInput, legsInput)\nif not na(pivotHighPrice)\n// A new high pivot was found; display a label where it occurred `legsInput` bars back.\nfoundPoint = pivotPoint.new(time[legsInput], pivotHighPrice)\nfoundPoint.x,\nfoundPoint.y,\nstr.tostring(foundPoint.y, format.mintick),\nfoundPoint.xloc,\ntextcolor = color.white)\nTake note of this line from the above example:\nfoundPoint = pivotPoint.new(time[legsInput], pivotHighPrice)\nThis could also be written using the following:\npivotPoint foundPoint = na\nfoundPoint := pivotPoint.new(time[legsInput], pivotHighPrice)\nWhen an object is created using var or varip, those keywords apply to all of the object’s fields:\ntype barInfo\nint i = bar_index\nint t = time\nfloat c = close\n// Created on bar zero.\nvar firstBar = barInfo.new()\n// Created on every bar.\ncurrentBar = barInfo.new()\nplot(firstBar.i)\nplot(currentBar.i)\nChanging field values¶\nThe value of an object’s fields can be changed using the := reassignment operator.\nThis line of our previous example:\nfoundPoint = pivotPoint.new(time[legsInput], pivotHighPrice)\nCould be written using the following:\nfoundPoint = pivotPoint.new()\nfoundPoint.x := time[legsInput]\nfoundPoint.y := pivotHighPrice\nCollecting objects¶\nPine Script™ collections (arrays, matrices, and maps) can contain objects, allowing users to add virtual dimensions to their data structures. To declare a collection of objects, pass a UDT name into its type template.\nThis example declares an empty array that will hold objects of a pivotPoint user-defined type:\npivotHighArray = array.new<pivotPoint>()\nTo explicitly declare the type of a variable as an array, matrix, or map of a user-defined type, use the collection’s type keyword followed by its type template. For example:\nvar array<pivotPoint> pivotHighArray = na\npivotHighArray := array.new<pivotPoint>()\nLet’s use what we have learned to create a script that detects high pivot points. The script first collects historical pivot information in an array. It then loops through the array on the last historical bar, creating a label for each pivot and connecting the pivots with lines:\nindicator(\"Pivot Points High\", overlay = true)\nint legsInput = input(10)\n// Define the `pivotPoint` UDT containing the time and price of pivots.\nint openTime\nfloat level\n// Create an empty `pivotPoint` array.\nvar pivotHighArray = array.new<pivotPoint>()\n// Detect new pivots (`na` is returned when no pivot is found).\npivotHighPrice = ta.pivothigh(legsInput, legsInput)\n// Add a new `pivotPoint` object to the end of the array for each detected pivot.\nif not na(pivotHighPrice)\n// A new pivot is found; create a new object of `pivotPoint` type, setting its `openTime` and `level` fields.\nnewPivot = pivotPoint.new(time[legsInput], pivotHighPrice)\n// Add the new pivot object to the array.\narray.push(pivotHighArray, newPivot)\n// On the last historical bar, draw pivot labels and connecting lines.\nvar pivotPoint previousPoint = na\nfor eachPivot in pivotHighArray\n// Display a label at the pivot point.\nlabel.new(eachPivot.openTime, eachPivot.level, str.tostring(eachPivot.level, format.mintick), xloc.bar_time, textcolor = color.white)\n// Create a line between pivots.\nif not na(previousPoint)\n// Only create a line starting at the loop's second iteration because lines connect two pivots.\nline.new(previousPoint.openTime, previousPoint.level, eachPivot.openTime, eachPivot.level, xloc = xloc.bar_time)\n// Save the pivot for use in the next iteration.\npreviousPoint := eachPivot\nCopying objects¶\nIn Pine, objects are assigned by reference. When an existing object is assigned to a new variable, both point to the same object.\nIn the example below, we create a pivot1 object and set its x field to 1000. Then, we declare a pivot2 variable containing the reference to the pivot1 object, so both point to the same instance. Changing pivot2.x will thus also change pivot1.x, as both refer to the x field of the same object:\npivot1 = pivotPoint.new()\npivot1.x := 1000\npivot2 = pivot1\npivot2.x := 2000\n// Both plot the value 2000.\nplot(pivot1.x)\nplot(pivot2.x)\nTo create a copy of an object that is independent of the original, we can use the built-in copy() method in this case.\nIn this example, we declare the pivot2 variable referring to a copied instance of the pivot1 object. Now, changing pivot2.x will not change pivot1.x, as it refers to the x field of a separate object:\npivot1 = pivotPoint.new()\npivot1.x := 1000\npivot2 = pivotPoint.copy(pivot1)\npivot2.x := 2000\n// Plots 1000 and 2000.\nplot(pivot1.x)\nplot(pivot2.x)\nIt’s important to note that the built-in copy() method produces a shallow copy of an object. If an object has fields with special types (array, matrix, map, line, linefill, box, polyline, label, table, or chart.point), those fields in a shallow copy of the object will point to the same instances as the original.\nIn the following example, we have defined an InfoLabel type with a label as one of its fields. The script instantiates a shallow copy of the parent object, then calls a user-defined set() method to update the info and lbl fields of each object. Since the lbl field of both objects points to the same label instance, changes to this field in either object affect the other:\nindicator(\"Shallow Copy\")\ntype InfoLabel\nstring info\nlabel lbl\nmethod set(InfoLabel this, int x = na, int y = na, string info = na) =>\nif not na(x)\nthis.lbl.set_x(x)\nif not na(y)\nthis.lbl.set_y(y)\nif not na(info)\nthis.info := info\nthis.lbl.set_text(this.info)\nvar parent = InfoLabel.new(\"\", label.new(0, 0))\nvar shallow = parent.copy()\nparent.set(bar_index, 0, \"Parent\")\nshallow.set(bar_index, 1, \"Shallow Copy\")\nTo produce a deep copy of an object with all of its special type fields pointing to independent instances, we must explicitly copy those fields as well.\nIn this example, we have defined a deepCopy() method that instantiates a new InfoLabel object with its lbl field pointing to a copy of the original’s field. Changes to the deep copy’s lbl field will not affect the parent object, as it points to a separate instance:\nindicator(\"Deep Copy\")\ntype InfoLabel\nstring info\nlabel lbl\nmethod set(InfoLabel this, int x = na, int y = na, string info = na) =>\nif not na(x)\nthis.lbl.set_x(x)\nif not na(y)\nthis.lbl.set_y(y)\nif not na(info)\nthis.info := info\nthis.lbl.set_text(this.info)\nmethod deepCopy(InfoLabel this) =>\nInfoLabel.new(this.info, this.lbl.copy())\nvar parent = InfoLabel.new(\"\", label.new(0, 0))\nvar deep = parent.deepCopy()\nparent.set(bar_index, 0, \"Parent\")\ndeep.set(bar_index, 1, \"Deep Copy\")\nShadowing¶\nTo avoid potential conflicts in the eventuality where namespaces added to Pine Script™ in the future would collide with UDTs or object names in existing scripts; as a rule, UDTs and object names shadow the language’s namespaces. For example, a UDT or object can use the name of built-in types, such as line or table.\nOnly the language’s five primitive types cannot be used to name UDTs or objects: int, float, string, bool, and color."
},
{
  "text": "Methods¶\nBuilt-in methods\nUser-defined methods\nMethod overloading\nAdvanced example\nThis page contains advanced material. If you are a beginning Pine Script™ programmer, we recommend you become familiar with other, more accessible Pine Script™ features before you venture here.\nPine Script™ methods are specialized functions associated with specific instances of built-in or user-defined types. They are essentially the same as regular functions in most regards but offer a shorter, more convenient syntax. Users can access methods using dot notation on variables directly, just like accessing the fields of a Pine Script™ object.\nBuilt-in methods¶\nPine Script™ includes built-in methods for all special types, including array, matrix, map, line, linefill, box, polyline, label, and table. These methods provide users with a more concise way to call specialized routines for these types within their scripts.\nWhen using these special types, the expressions:\n<namespace>.<functionName>([paramName =] <objectName>, …)\nand:\n<objectName>.<functionName>(…)\nare equivalent. For example, rather than using:\nto get the value from an array id at the specified index, we can simply use:\nto achieve the same effect. This notation eliminates the need for users to reference the function’s namespace, as get() is a method of id in this context.\nWritten below is a practical example to demonstrate the usage of built-in methods in place of functions.\nThe following script computes Bollinger Bands over a specified number of prices sampled once every n bars. It calls array.push() and array.shift() to queue sourceInput values through the sourceArray, then array.avg() and array.stdev() to compute the sampleMean and sampleDev. The script then uses these values to calculate the highBand and lowBand, which it plots on the chart along with the sampleMean:\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput = input.source(close, \"Source\")\nint samplesInput = input.int(20, \"Samples\")\nint n = input.int(10, \"Bars\")\nfloat multiplier = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float sampleMean = na\nvar float sampleDev = na\n// Identify if `n` bars have passed.\nif bar_index % n == 0\n// Update the queue.\narray.push(sourceArray, sourceInput)\narray.shift(sourceArray)\n// Update the mean and standard deviaiton values.\nsampleMean := array.avg(sourceArray)\nsampleDev := array.stdev(sourceArray) * multiplier\n// Calculate bands.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand = sampleMean - sampleDev\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\nLet’s rewrite this code to utilize methods rather than built-in functions. In this version, we have replaced all built-in array.* functions in the script with equivalent methods:\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput = input.source(close, \"Source\")\nint samplesInput = input.int(20, \"Samples\")\nint n = input.int(10, \"Bars\")\nfloat multiplier = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\nvar float sampleMean = na\nvar float sampleDev = na\n// Identify if `n` bars have passed.\nif bar_index % n == 0\n// Update the queue.\nsourceArray.push(sourceInput)\nsourceArray.shift()\n// Update the mean and standard deviaiton values.\nsampleMean := sourceArray.avg()\nsampleDev := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand = sampleMean - sampleDev\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\nWe call the array methods using sourceArray.* rather than referencing the array namespace.\nWe do not include sourceArray as a parameter when we call the methods since they already reference the object.\nUser-defined methods¶\nPine Script™ allows users to define custom methods for use with objects of any built-in or user-defined type. Defining a method is essentially the same as defining a function, but with two key differences:\nThe method keyword must be included before the function name.\nThe type of the first parameter in the signature must be explicitly declared, as it represents the type of object that the method will be associated with.\n[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n<functionBlock>\nLet’s apply user-defined methods to our previous Bollinger Bands example to encapsulate operations from the global scope, which will simplify the code and promote reusability. See this portion from the example:\n// Identify if `n` bars have passed.\nif bar_index % n == 0\n// Update the queue.\nsourceArray.push(sourceInput)\nsourceArray.shift()\n// Update the mean and standard deviaiton values.\nsampleMean := sourceArray.avg()\nsampleDev := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand = sampleMean - sampleDev\nWe will start by defining a simple method to queue values through an array in a single call.\nThis maintainQueue() method invokes the push() and shift() methods on a srcArray when takeSample is true and returns the object:\n// @function Maintains a queue of the size of `srcArray`.\n// It appends a `value` to the array and removes its oldest element at position zero.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param value (float) The new value to be added to the queue.\n// The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new `value` is only pushed into the queue if this is true.\n// @returns (array<float>) `srcArray` object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\nif takeSample\nsrcArray.push(value)\nsrcArray.shift()\nsrcArray\nJust as with user-defined functions, we use the @function compiler annotation to document method descriptions.\nNow we can replace sourceArray.push() and sourceArray.shift() with sourceArray.maintainQueue() in our example:\n// Identify if `n` bars have passed.\nif bar_index % n == 0\n// Update the queue.\nsourceArray.maintainQueue(sourceInput)\n// Update the mean and standard deviaiton values.\nsampleMean := sourceArray.avg()\nsampleDev := sourceArray.stdev() * multiplier\n// Calculate band values.\nfloat highBand = sampleMean + sampleDev\nfloat lowBand = sampleMean - sampleDev\nFrom here, we will further simplify our code by defining a method that handles all Bollinger Band calculations within its scope.\nThis calcBB() method invokes the avg() and stdev() methods on a srcArray to update mean and dev values when calculate is true. The method uses these values to return a tuple containing the basis, upper band, and lower band values respectively:\n// @function Computes Bollinger Band values from an array of data.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate (bool) The method will only calculate new values when this is true.\n// @returns A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\nvar float mean = na\nvar float dev = na\nif calculate\n// Compute the mean and standard deviation of the array.\nmean := srcArray.avg()\ndev := srcArray.stdev() * mult\n[mean, mean + dev, mean - dev]\nWith this method, we can now remove Bollinger Band calculations from the global scope and improve code readability:\nbool newSample = bar_index % n == 0\n// Update the queue and compute new BB values on each new sample.\n[sampleMean, highBand, lowBand] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\nRather than using an if block in the global scope, we have defined a newSample variable that is only true once every n bars. The maintainQueue() and calcBB() methods use this value for their respective takeSample and calculate parameters.\nSince the maintainQueue() method returns the object that it references, we’re able to call calcBB() from the same line of code, as both methods apply to array<float> instances.\nHere is how the full script example looks now that we’ve applied our user-defined methods:\nindicator(\"Custom Sample BB\", overlay = true)\nfloat sourceInput = input.source(close, \"Source\")\nint samplesInput = input.int(20, \"Samples\")\nint n = input.int(10, \"Bars\")\nfloat multiplier = input.float(2.0, \"StdDev\")\nvar array<float> sourceArray = array.new<float>(samplesInput)\n// @function Maintains a queue of the size of `srcArray`.\n// It appends a `value` to the array and removes its oldest element at position zero.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param value (float) The new value to be added to the queue.\n// The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new `value` is only pushed into the queue if this is true.\n// @returns (array<float>) `srcArray` object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\nif takeSample\nsrcArray.push(value)\nsrcArray.shift()\nsrcArray\n// @function Computes Bollinger Band values from an array of data.\n// @param srcArray (array<float>) The array where the queue is maintained.\n// @param multiplier (float) Standard deviaiton multiplier.\n// @param calcuate (bool) The method will only calculate new values when this is true.\n// @returns A tuple containing the basis, upper band, and lower band respectively.\nmethod calcBB(array<float> srcArray, float mult, bool calculate = true) =>\nvar float mean = na\nvar float dev = na\nif calculate\n// Compute the mean and standard deviation of the array.\nmean := srcArray.avg()\ndev := srcArray.stdev() * mult\n[mean, mean + dev, mean - dev]\nbool newSample = bar_index % n == 0\n// Update the queue and compute new BB values on each new sample.\n[sampleMean, highBand, lowBand] = sourceArray.maintainQueue(sourceInput, newSample).calcBB(multiplier, newSample)\nplot(sampleMean, \"Basis\", color.orange)\nplot(highBand, \"Upper\", color.lime)\nplot(lowBand, \"Lower\", color.red)\nMethod overloading¶\nUser-defined methods can override and overload existing built-in and user-defined methods with the same identifier. This capability allows users to define multiple routines associated with different parameter signatures under the same method name.\nAs a simple example, suppose we want to define a method to identify a variable’s type. Since we must explicitly specify the type of object associated with a user-defined method, we will need to define overloads for each type that we want it to recognize.\nBelow, we have defined a getType() method that returns a string representation of a variable’s type with overloads for the five primitive types:\n// @function Identifies an object's type.\n// @param this Object to inspect.\n// @returns (string) A string representation of the type.\nmethod getType(int this) =>\nna(this) ? \"int(na)\" : \"int\"\nmethod getType(float this) =>\nna(this) ? \"float(na)\" : \"float\"\nmethod getType(bool this) =>\nna(this) ? \"bool(na)\" : \"bool\"\nmethod getType(color this) =>\nna(this) ? \"color(na)\" : \"color\"\nmethod getType(string this) =>\nna(this) ? \"string(na)\" : \"string\"\nNow we can use these overloads to inspect some variables. This script uses str.format() to format the results from calling the getType() method on five different variables into a single results string, then displays the string in the lbl label using the built-in set_text() method:\nindicator(\"Type Inspection\")\n// @function Identifies an object's type.\n// @param this Object to inspect.\n// @returns (string) A string representation of the type.\nmethod getType(int this) =>\nna(this) ? \"int(na)\" : \"int\"\nmethod getType(float this) =>\nna(this) ? \"float(na)\" : \"float\"\nmethod getType(bool this) =>\nna(this) ? \"bool(na)\" : \"bool\"\nmethod getType(color this) =>\nna(this) ? \"color(na)\" : \"color\"\nmethod getType(string this) =>\nna(this) ? \"string(na)\" : \"string\"\na = 1\nb = 1.0\nc = true\nd = color.white\ne = \"1\"\n// Inspect variables and format results.\nresults = str.format(\n\"a: {0}\\nb: {1}\\nc: {2}\\nd: {3}\\ne: {4}\",\na.getType(), b.getType(), c.getType(), d.getType(), e.getType()\nvar label lbl = label.new(0, 0)\nlbl.set_x(bar_index)\nlbl.set_text(results)\nThe underlying type of each variable determines which overload of getType() the compiler will use.\nThe method will append “(na)” to the output string when a variable is na to demarcate that it is empty.\nAdvanced example¶\nLet’s apply what we’ve learned to construct a script that estimates the cumulative distribution of elements in an array, meaning the fraction of elements in the array that are less than or equal to any given value.\nThere are many ways in which we could choose to tackle this objective. For this example, we will start by defining a method to replace elements of an array, which will help us count the occurrences of elements within a range of values.\nWritten below is an overload of the built-in fill() method for array<float> instances. This overload replaces elements in a srcArray within the range between the lowerBound and upperBound with an innerValue, and replaces all elements outside the range with an outerValue:\n// @function Replaces elements in a `srcArray` between `lowerBound` and `upperBound` with an `innerValue`,\n// and replaces elements outside the range with an `outerValue`.\n// @param srcArray (array<float>) Array to modify.\n// @param innerValue (float) Value to replace elements within the range with.\n// @param outerValue (float) Value to replace elements outside the range with.\n// @param lowerBound (float) Lowest value to replace with `innerValue`.\n// @param upperBound (float) Highest value to replace with `innerValue`.\n// @returns (array<float>) `srcArray` object.\nmethod fill(array<float> srcArray, float innerValue, float outerValue, float lowerBound, float upperBound) =>\nfor [i, element] in srcArray\nif (element >= lowerBound or na(lowerBound)) and (element <= upperBound or na(upperBound))\nsrcArray.set(i, innerValue)\nsrcArray.set(i, outerValue)\nsrcArray\nWith this method, we can filter an array by value ranges to produce an array of occurrences. For example, the expression:\nsrcArray.copy().fill(1.0, 0.0, min, val)\ncopies the srcArray object, replaces all elements between min and val with 1.0, then replaces all elements above val with 0.0. From here, it’s easy to estimate the output of the cumulative distribution function at the val, as it’s simply the average of the resulting array:\nsrcArray.copy().fill(1.0, 0.0, min, val).avg()\nThe compiler will only use this fill() overload instead of the built-in when the user provides innerValue, outerValue, lowerBound, and upperBound arguments in the call.\nIf either lowerBound or upperBound is na, its value is ignored while filtering the fill range.\nWe are able to call copy(), fill(), and avg() successively on the same line of code because the first two methods return an array<float> instance.\nWe can now use this to define a method that will calculate our empirical distribution values. The following eCDF() method estimates a number of evenly spaced ascending steps from the cumulative distribution function of a srcArray and pushes the results into a cdfArray:\n// @function Estimates the empirical CDF of a `srcArray`.\n// @param srcArray (array<float>) Array to calculate on.\n// @param steps (int) Number of steps in the estimation.\n// @returns (array<float>) Array of estimated CDF ratios.\nmethod eCDF(array<float> srcArray, int steps) =>\nfloat min = srcArray.min()\nfloat rng = srcArray.range() / steps\narray<float> cdfArray = array.new<float>()\n// Add averages of `srcArray` filtered by value region to the `cdfArray`.\nfloat val = min\nfor i = 1 to steps\nval += rng\ncdfArray.push(srcArray.copy().fill(1.0, 0.0, min, val).avg())\ncdfArray\nLastly, to ensure that our eCDF() method functions properly for arrays containing small and large values, we will define a method to normalize our arrays.\nThis featureScale() method uses array min() and range() methods to produce a rescaled copy of a srcArray. We will use this to normalize our arrays prior to invoking the eCDF() method:\n// @function Rescales the elements within a `srcArray` to the interval [0, 1].\n// @param srcArray (array<float>) Array to normalize.\n// @returns (array<float>) Normalized copy of the `srcArray`.\nmethod featureScale(array<float> srcArray) =>\nfloat min = srcArray.min()\nfloat rng = srcArray.range()\narray<float> scaledArray = array.new<float>()\n// Push normalized `element` values into the `scaledArray`.\nfor element in srcArray\nscaledArray.push((element - min) / rng)\nscaledArray\nThis method does not include special handling for divide by zero conditions. If rng is 0, the value of the array element will be na.\nThe full example below queues a sourceArray of size length with sourceInput values using our previous maintainQueue() method, normalizes the array’s elements using the featureScale() method, then calls the eCDF() method to get an array of estimates for n evenly spaced steps on the distribution. The script then calls a user-defined makeLabel() function to display the estimates and prices in a label on the right side of the chart:\nindicator(\"Empirical Distribution\", overlay = true)\nfloat sourceInput = input.source(close, \"Source\")\nint length = input.int(20, \"Length\")\nint n = input.int(20, \"Steps\")\n// @function Maintains a queue of the size of `srcArray`.\n// It appends a `value` to the array and removes its oldest element at position zero.\n// @param value (float) The new value to be added to the queue.\n// The queue's oldest value is also removed, so its size is constant.\n// @param takeSample (bool) A new `value` is only pushed into the queue if this is true.\n// @returns (array<float>) `srcArray` object.\nmethod maintainQueue(array<float> srcArray, float value, bool takeSample = true) =>\nif takeSample\nsrcArray.push(value)\nsrcArray.shift()\nsrcArray\n// @function Replaces elements in a `srcArray` between `lowerBound` and `upperBound` with an `innerValue`,\n// and replaces elements outside the range with an `outerValue`.\n// @param srcArray (array<float>) Array to modify.\n// @param innerValue (float) Value to replace elements within the range with.\n// @param outerValue (float) Value to replace elements outside the range with.\n// @param lowerBound (float) Lowest value to replace with `innerValue`.\n// @param upperBound (float) Highest value to replace with `innerValue`.\nmethod fill(array<float> srcArray, float innerValue, float outerValue, float lowerBound, float upperBound) =>\nfor [i, element] in srcArray\nif (element >= lowerBound or na(lowerBound)) and (element <= upperBound or na(upperBound))\nsrcArray.set(i, innerValue)\nsrcArray.set(i, outerValue)\n// @function Estimates the empirical CDF of a `srcArray`.\n// @param srcArray (array<float>) Array to calculate on.\n// @param steps (int) Number of steps in the estimation.\n// @returns (array<float>) Array of estimated CDF ratios.\nmethod eCDF(array<float> srcArray, int steps) =>\nfloat min = srcArray.min()\nfloat rng = srcArray.range() / steps\narray<float> cdfArray = array.new<float>()\n// Add averages of `srcArray` filtered by value region to the `cdfArray`.\nfloat val = min\nfor i = 1 to steps\nval += rng\ncdfArray.push(srcArray.copy().fill(1.0, 0.0, min, val).avg())\ncdfArray\n// @function Rescales the elements within a `srcArray` to the interval [0, 1].\n// @param srcArray (array<float>) Array to normalize.\n// @returns (array<float>) Normalized copy of the `srcArray`.\nmethod featureScale(array<float> srcArray) =>\nfloat min = srcArray.min()\nfloat rng = srcArray.range()\narray<float> scaledArray = array.new<float>()\n// Push normalized `element` values into the `scaledArray`.\nfor element in srcArray\nscaledArray.push((element - min) / rng)\nscaledArray\n// @function Draws a label containing eCDF estimates in the format \"{price}: {percent}%\"\n// @param srcArray (array<float>) Array of source values.\n// @param cdfArray (array<float>) Array of CDF estimates.\n// @returns (void)\nmakeLabel(array<float> srcArray, array<float> cdfArray) =>\nfloat max = srcArray.max()\nfloat rng = srcArray.range() / cdfArray.size()\nstring results = \"\"\nvar label lbl = label.new(0, 0, \"\", style = label.style_label_left, text_font_family = font.family_monospace)\n// Add percentage strings to `results` starting from the `max`.\ncdfArray.reverse()\nfor [i, element] in cdfArray\nresults += str.format(\"{0}: {1}%\\n\", max - i * rng, element * 100)\n// Update `lbl` attributes.\nlbl.set_xy(bar_index + 1, srcArray.avg())\nlbl.set_text(results)\nvar array<float> sourceArray = array.new<float>(length)\n// Add background color for the last `length` bars.\nbgcolor(bar_index > last_bar_index - length ? color.new(color.orange, 80) : na)\n// Queue `sourceArray`, feature scale, then estimate the distribution over `n` steps.\narray<float> distArray = sourceArray.maintainQueue(sourceInput).featureScale().eCDF(n)\n// Draw label.\nmakeLabel(sourceArray, distArray)"
},
{
  "text": "Arrays¶\nDeclaring arrays\nUsing `var` and `varip` keywords\nReading and writing array elements\nLooping through array elements\nScope\nHistory referencing\nInserting and removing array elements\nInserting\nRemoving\nUsing an array as a stack\nUsing an array as a queue\nCalculations on arrays\nManipulating arrays\nConcatenation\nCopying\nJoining\nSorting\nReversing\nSlicing\nSearching arrays\nError handling\nIndex xx is out of bounds. Array size is yy\nCannot call array methods when ID of array is ‘na’\nArray is too large. Maximum size is 100000\nCannot create an array with a negative size\nCannot use shift() if array is empty.\nCannot use pop() if array is empty.\nIndex ‘from’ should be less than index ‘to’\nSlice is out of bounds of the parent array\nThis page contains advanced material. If you are a beginning Pine Script™ programmer, we recommend you become familiar with other, more accessible Pine Script™ features before you venture here.\nPine Script™ Arrays are one-dimensional collections that can hold multiple value references. Think of them as a better way to handle cases where one would otherwise need to explicitly declare a set of similar variables (e.g., price00, price01, price02, …).\nAll elements within an array must be of the same type, which can be a built-in or a user-defined type, always qualified as “series”. Scripts reference arrays using an array ID similar to the IDs of lines, labels, and other special types. Pine Script™ does not use an indexing operator to reference individual array elements. Instead, functions including array.get() and array.set() read and write the values of array elements. We can use array values in expressions and functions that allow “series” values.\nScripts reference the elements of an array using an index, which starts at 0 and extends to the number of elements in the array minus one. Arrays in Pine Script™ can have a dynamic size that varies across bars, as one can change the number of elements in an array on each iteration of a script. Scripts can contain multiple array instances. The size of arrays is limited to 100,000 elements.\nWe will use beginning of an array to designate index 0, and end of an array to designate the array’s element with the highest index value. We will also extend the meaning of array to include array IDs, for the sake of brevity.\nDeclaring arrays¶\nPine Script™ uses the following syntax to declare arrays:\n[var/varip ][array<type>/<type[]> ]<identifier> = <expression>\nWhere <type> is a type template for the array that declares the type of values it will contain, and the <expression> returns either an array of the specified type or na.\nWhen declaring a variable as an array, we can use the array keyword followed by a type template. Alternatively, we can use the type name followed by the [] modifier (not to be confused with the [] history-referencing operator).\nSince Pine always uses type-specific functions to create arrays, the array<type>/type[] part of the declaration is redundant, except when declaring an array variable assigned to na. Even when not required, explicitly declaring the array type helps clearly state the intention to readers.\nThis line of code declares an array variable named prices that points to na. In this case, we must specify the type to declare that the variable can reference arrays containing “float” values:\nWe can also write the above example in this form:\nWhen declaring an array and the <expression> is not na, use one of the following functions: array.new<type>(size, initial_value), array.from(), or array.copy(). For array.new<type>(size, initial_value) functions, the arguments of the size and initial_value parameters can be “series” to allow dynamic sizing and initialization of array elements. The following example creates an array containing zero “float” elements, and this time, the array ID returned by the array.new<float>() function call is assigned to prices:\nprices = array.new<float>(0)\nThe array.* namespace also contains type-specific functions for creating arrays, including array.new_int(), array.new_float(), array.new_bool(), array.new_color(), array.new_string(), array.new_line(), array.new_linefill(), array.new_label(), array.new_box() and array.new_table(). The array.new<type>() function can create an array of any type, including user-defined types.\nThe initial_value parameter of array.new* functions allows users to set all elements in the array to a specified value. If no argument is provided for initial_value, the array is filled with na values.\nThis line declares an array ID named prices pointing to an array containing two elements, each assigned to the bar’s close value:\nprices = array.new<float>(2, close)\nTo create an array and initialize its elements with different values, use array.from(). This function infers the array’s size and the type of elements it will hold from the arguments in the function call. As with array.new* functions, it accepts “series” arguments. All values supplied to the function must be of the same type.\nFor example, all three of these lines of code will create identical “bool” arrays with the same two elements:\nstatesArray = array.from(close > open, high != close)\nbool[] statesArray = array.from(close > open, high != close)\narray<bool> statesArray = array.from(close > open, high != close)\nUsing `var` and `varip` keywords¶\nUsers can utilize var and varip keywords to instruct a script to declare an array variable only once on the first iteration of the script on the first chart bar. Array variables declared using these keywords point to the same array instances until explicitly reassigned, allowing an array and its element references to persist across bars.\nWhen declaring an array variable using these keywords and pushing a new value to the end of the referenced array on each bar, the array will grow by one on each bar and be of size bar_index + 1 (bar_index starts at zero) by the time the script executes on the last bar, as this code demonstrates:\nindicator(\"Using `var`\")\n//@variable An array that expands its size by 1 on each bar.\nvar a = array.new<float>(0)\narray.push(a, close)\n//@variable A string containing the size of `a` and the current `bar_index` value.\nstring labelText = \"Array size: \" + str.tostring(a.size()) + \"\\nbar_index: \" + str.tostring(bar_index)\n// Display the `labelText`.\nlabel.new(bar_index, 0, labelText, size = size.large)\nThe same code without the var keyword would re-declare the array on each bar. In this case, after execution of the array.push() call, the a.size() call would return a value of 1.\nArray variables declared using varip behave as ones using var on historical data, but they update their values for realtime bars (i.e., the bars since the script’s last compilation) on each new price tick. Arrays assigned to varip variables can only hold int, float, bool, color, or string types or user-defined types that exclusively contain within their fields these types or collections (arrays, matrices, or maps) of these types.\nReading and writing array elements¶\nScripts can write values to existing individual array elements using array.set(id, index, value), and read using array.get(id, index). When using these functions, it is imperative that the index in the function call is always less than or equal to the array’s size (because array indices start at zero). To get the size of an array, use the array.size(id) function.\nThe following example uses the set() method to populate a fillColors array with instances of one base color using different transparency levels. It then uses array.get() to retrieve one of the colors from the array based on the location of the bar with the highest price within the last lookbackInput bars:\nindicator(\"Distance from high\", \"\", true)\nlookbackInput = input.int(100)\nFILL_COLOR = color.green\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(5)\n// Initialize the array elements with progressively lighter shades of the fill color.\nfillColors.set(0, color.new(FILL_COLOR, 70))\nfillColors.set(1, color.new(FILL_COLOR, 75))\nfillColors.set(2, color.new(FILL_COLOR, 80))\nfillColors.set(3, color.new(FILL_COLOR, 85))\nfillColors.set(4, color.new(FILL_COLOR, 90))\n// Find the offset to highest high. Change its sign because the function returns a negative value.\nlastHiBar = - ta.highestbars(high, lookbackInput)\n// Convert the offset to an array index, capping it to 4 to avoid a runtime error.\n// The index used by `array.get()` will be the equivalent of `floor(fillNo)`.\nfillNo = math.min(lastHiBar / (lookbackInput / 5), 4)\n// Set background to a progressively lighter fill with increasing distance from location of highest high.\nbgcolor(array.get(fillColors, fillNo))\n// Plot key values to the Data Window for debugging.\nplotchar(lastHiBar, \"lastHiBar\", \"\", location.top, size = size.tiny)\nplotchar(fillNo, \"fillNo\", \"\", location.top, size = size.tiny)\nAnother technique for initializing the elements in an array is to create an empty array (an array with no elements), then use array.push() to append new elements to the end of the array, increasing the size of the array by one on each call. The following code is functionally identical to the initialization section from the preceding script:\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(0)\n// Initialize the array elements with progressively lighter shades of the fill color.\narray.push(fillColors, color.new(FILL_COLOR, 70))\narray.push(fillColors, color.new(FILL_COLOR, 75))\narray.push(fillColors, color.new(FILL_COLOR, 80))\narray.push(fillColors, color.new(FILL_COLOR, 85))\narray.push(fillColors, color.new(FILL_COLOR, 90))\nThis code is equivalent to the one above, but it uses array.unshift() to insert new elements at the beginning of the fillColors array:\n// Declare array and set its values on the first bar only.\nvar fillColors = array.new<color>(0)\n// Initialize the array elements with progressively lighter shades of the fill color.\narray.unshift(fillColors, color.new(FILL_COLOR, 90))\narray.unshift(fillColors, color.new(FILL_COLOR, 85))\narray.unshift(fillColors, color.new(FILL_COLOR, 80))\narray.unshift(fillColors, color.new(FILL_COLOR, 75))\narray.unshift(fillColors, color.new(FILL_COLOR, 70))\nWe can also use array.from() to create the same fillColors array with a single function call:\nindicator(\"Using `var`\")\nFILL_COLOR = color.green\nvar array<color> fillColors = array.from(\ncolor.new(FILL_COLOR, 70),\ncolor.new(FILL_COLOR, 75),\ncolor.new(FILL_COLOR, 80),\ncolor.new(FILL_COLOR, 85),\ncolor.new(FILL_COLOR, 90)\n// Cycle background through the array's colors.\nbgcolor(array.get(fillColors, bar_index % (fillColors.size())))\nThe array.fill(id, value, index_from, index_to) function points all array elements, or the elements within the index_from to index_to range, to a specified value. Without the last two optional parameters, the function fills the whole array, so:\na = array.new<float>(10, close)\nand:\na = array.new<float>(10)\na.fill(close)\nare equivalent, but:\na = array.new<float>(10)\na.fill(close, 1, 3)\nonly fills the second and third elements (at index 1 and 2) of the array with close. Note how array.fill()’s last parameter, index_to, must be one greater than the last index the function will fill. The remaining elements will hold na values, as the array.new() function call does not contain an initial_value argument.\nLooping through array elements¶\nWhen looping through an array’s element indices and the array’s size is unknown, one can use the array.size() function to get the maximum index value. For example:\nindicator(\"Protected `for` loop\", overlay = true)\n//@variable An array of `close` prices from the 1-minute timeframe.\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\n//@variable A string representation of the elements in `a`.\nstring labelText = \"\"\nfor i = 0 to (array.size(a) == 0 ? na : array.size(a) - 1)\nlabelText += str.tostring(array.get(a, i)) + \"\\n\"\nlabel.new(bar_index, high, text = labelText)\nWe use the request.security_lower_tf() function which returns an array of close prices at the 1 minute timeframe.\nThis code example will throw an error if you use it on a chart timeframe smaller than 1 minute.\nfor loops do not execute if the to expression is na. Note that the to value is only evaluated once upon entry.\nAn alternative method to loop through an array is to use a for…in loop. This approach is a variation of the standard for loop that can iterate over the value references and indices in an array. Here is an example of how we can write the code example from above using a for...in loop:\nindicator(\"`for...in` loop\", overlay = true)\n//@variable An array of `close` prices from the 1-minute timeframe.\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\n//@variable A string representation of the elements in `a`.\nstring labelText = \"\"\nfor price in a\nlabelText += str.tostring(price) + \"\\n\"\nlabel.new(bar_index, high, text = labelText)\nfor…in loops can return a tuple containing each index and corresponding element. For example, for [i, price] in a returns the i index and price value for each element in a.\nA while loop statement can also be used:\nindicator(\"`while` loop\", overlay = true)\narray<float> a = request.security_lower_tf(syminfo.tickerid, \"1\", close)\nstring labelText = \"\"\nint i = 0\nwhile i < array.size(a)\nlabelText += str.tostring(array.get(a, i)) + \"\\n\"\ni += 1\nlabel.new(bar_index, high, text = labelText)\nScope¶\nUsers can declare arrays within the global scope of a script, as well as the local scopes of functions, methods, and conditional structures. Unlike some of the other built-in types, namely fundamental types, scripts can modify globally-assigned arrays from within local scopes, allowing users to implement global variables that any function in the script can directly interact with. We use the functionality here to calculate progressively lower or higher price levels:\nindicator(\"Bands\", \"\", true)\n//@variable The distance ratio between plotted price levels.\nfactorInput = 1 + (input.float(-2., \"Step %\") / 100)\n//@variable A single-value array holding the lowest `ohlc4` value within a 50 bar window from 10 bars back.\nlevel = array.new<float>(1, ta.lowest(ohlc4, 50)[10])\nnextLevel(val) =>\nnewLevel = level.get(0) * val\n// Write new level to the global `level` array so we can use it as the base in the next function call.\nlevel.set(0, newLevel)\nnewLevel\nplot(nextLevel(1))\nplot(nextLevel(factorInput))\nplot(nextLevel(factorInput))\nplot(nextLevel(factorInput))\nHistory referencing¶\nPine Script™’s history-referencing operator [ ] can access the history of array variables, allowing scripts to interact with past array instances previously assigned to a variable.\nTo illustrate this, let’s create a simple example to show how one can fetch the previous bar’s close value in two equivalent ways. This script uses the [ ] operator to get the array instance assigned to a on the previous bar, then uses the get() method to retrieve the value of the first element (previousClose1). For previousClose2, we use the history-referencing operator on the close variable directly to retrieve the value. As we see from the plots, previousClose1 and previousClose2 both return the same value:\nindicator(\"History referencing\")\n//@variable A single-value array declared on each bar.\na = array.new<float>(1)\n// Set the value of the only element in `a` to `close`.\narray.set(a, 0, close)\n//@variable The array instance assigned to `a` on the previous bar.\nprevious = a[1]\npreviousClose1 = na(previous) ? na : previous.get(0)\npreviousClose2 = close[1]\nplot(previousClose1, \"previousClose1\", color.gray, 6)\nplot(previousClose2, \"previousClose2\", color.white, 2)\nInserting and removing array elements¶\nInserting¶\nThe following three functions can insert new elements into an array.\narray.unshift() inserts a new element at the beginning of an array (index 0) and increases the index values of any existing elements by one.\narray.insert() inserts a new element at the specified index and increases the index of existing elements at or after the index by one.\nindicator(\"`array.insert()`\")\na = array.new<float>(5, 0)\nfor i = 0 to 4\narray.set(a, i, i + 1)\nlabel.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a), size = size.large)\narray.insert(a, 2, 999)\nlabel.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a), style = label.style_label_up, size = size.large)\narray.push() adds a new element at the end of an array.\nRemoving¶\nThese four functions remove elements from an array. The first three also return the value of the removed element.\narray.remove() removes the element at the specified index and returns that element’s value.\narray.shift() removes the first element from an array and returns its value.\narray.pop() removes the last element of an array and returns its value.\narray.clear() removes all elements from an array. Note that clearing an array won’t delete any objects its elements referenced. See the example below that illustrates how this works:\nindicator(\"`array.clear()` example\", overlay = true)\n// Create a label array and add a label to the array on each new bar.\nvar a = array.new<label>()\nlabel lbl = label.new(bar_index, high, \"Text\", color = color.red)\narray.push(a, lbl)\nvar table t = table.new(position.top_right, 1, 1)\n// Clear the array on the last bar. This doesn't remove the labels from the chart.\narray.clear(a)\ntable.cell(t, 0, 0, \"Array elements count: \" + str.tostring(array.size(a)), bgcolor = color.yellow)\nUsing an array as a stack¶\nStacks are LIFO (last in, first out) constructions. They behave somewhat like a vertical pile of books to which books can only be added or removed one at a time, always from the top. Pine Script™ arrays can be used as a stack, in which case we use the array.push() and array.pop() functions to add and remove elements at the end of the array.\narray.push(prices, close) will add a new element to the end of the prices array, increasing the array’s size by one.\narray.pop(prices) will remove the end element from the prices array, return its value and decrease the array’s size by one.\nSee how the functions are used here to track successive lows in rallies:\nindicator(\"Lows from new highs\", \"\", true)\nvar lows = array.new<float>(0)\nflushLows = false\n// Remove last element from the stack when `_cond` is true.\narray_pop(id, cond) => cond and array.size(id) > 0 ? array.pop(id) : float(na)\nif ta.rising(high, 1)\n// Rising highs; push a new low on the stack.\nlows.push(low)\n// Force the return type of this `if` block to be the same as that of the next block.\nbool(na)\nelse if lows.size() >= 4 or low < array.min(lows)\n// We have at least 4 lows or price has breached the lowest low;\n// sort lows and set flag indicating we will plot and flush the levels.\narray.sort(lows, order.ascending)\nflushLows := true\n// If needed, plot and flush lows.\nlowLevel = array_pop(lows, flushLows)\nplot(lowLevel, \"Low 1\", low > lowLevel ? color.silver : color.purple, 2, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 2\", low > lowLevel ? color.silver : color.purple, 3, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 3\", low > lowLevel ? color.silver : color.purple, 4, plot.style_linebr)\nlowLevel := array_pop(lows, flushLows)\nplot(lowLevel, \"Low 4\", low > lowLevel ? color.silver : color.purple, 5, plot.style_linebr)\nif flushLows\n// Clear remaining levels after the last 4 have been plotted.\nlows.clear()\nUsing an array as a queue¶\nQueues are FIFO (first in, first out) constructions. They behave somewhat like cars arriving at a red light. New cars are queued at the end of the line, and the first car to leave will be the first one that arrived to the red light.\nIn the following code example, we let users decide through the script’s inputs how many labels they want to have on their chart. We use that quantity to determine the size of the array of labels we then create, initializing the array’s elements to na.\nWhen a new pivot is detected, we create a label for it, saving the label’s ID in the pLabel variable. We then queue the ID of that label by using array.push() to append the new label’s ID to the end of the array, making our array size one greater than the maximum number of labels to keep on the chart.\nLastly, we de-queue the oldest label by removing the array’s first element using array.shift() and deleting the label referenced by that array element’s value. As we have now de-queued an element from our queue, the array contains pivotCountInput elements once again. Note that on the dataset’s first bars we will be deleting na label IDs until the maximum number of labels has been created, but this does not cause runtime errors. Let’s look at our code:\nMAX_LABELS = 100\nindicator(\"Show Last n High Pivots\", \"\", true, max_labels_count = MAX_LABELS)\npivotCountInput = input.int(5, \"How many pivots to show\", minval = 0, maxval = MAX_LABELS)\npivotLegsInput = input.int(3, \"Pivot legs\", minval = 1, maxval = 5)\n// Create an array containing the user-selected max count of label IDs.\nvar labelIds = array.new<label>(pivotCountInput)\npHi = ta.pivothigh(pivotLegsInput, pivotLegsInput)\nif not na(pHi)\n// New pivot found; plot its label `i_pivotLegs` bars back.\npLabel = label.new(bar_index[pivotLegsInput], pHi, str.tostring(pHi, format.mintick), textcolor = color.white)\n// Queue the new label's ID by appending it to the end of the array.\narray.push(labelIds, pLabel)\n// De-queue the oldest label ID from the queue and delete the corresponding label.\nlabel.delete(array.shift(labelIds))\nCalculations on arrays¶\nWhile series variables can be viewed as a horizontal set of values stretching back in time, Pine Script™’s one-dimensional arrays can be viewed as vertical structures residing on each bar. As an array’s set of elements is not a time series, Pine Script™’s usual mathematical functions are not allowed on them. Special-purpose functions must be used to operate on all of an array’s values. The available functions are: array.abs(), array.avg(), array.covariance(), array.min(), array.max(), array.median(), array.mode(), array.percentile_linear_interpolation(), array.percentile_nearest_rank(), array.percentrank(), array.range(), array.standardize(), array.stdev(), array.sum(), array.variance().\nNote that contrary to the usual mathematical functions in Pine Script™, those used on arrays do not return na when some of the values they calculate on have na values. There are a few exceptions to this rule:\nWhen all array elements have na value or the array contains no elements, na is returned. array.standardize() however, will return an empty array.\narray.mode() will return na when no mode is found.\nManipulating arrays¶\nConcatenation¶\nTwo arrays can be merged—or concatenated—using array.concat(). When arrays are concatenated, the second array is appended to the end of the first, so the first array is modified while the second one remains intact. The function returns the array ID of the first array:\nindicator(\"`array.concat()`\")\na = array.new<float>(0)\nb = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(b, 2)\narray.push(b, 3)\nlabel.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b), size = size.large)\nc = array.concat(a, b)\narray.push(c, 4)\nlabel.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b) + \"\\nc: \" + str.tostring(c), style = label.style_label_up, size = size.large)\nCopying¶\nYou can copy an array using array.copy(). Here we copy the array a to a new array named _b:\nindicator(\"`array.copy()`\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\nb = array.copy(a)\narray.push(b, 2)\nlabel.new(bar_index, 0, \"a: \" + str.tostring(a) + \"\\nb: \" + str.tostring(b), size = size.large)\nNote that simply using _b = a in the previous example would not have copied the array, but only its ID. From thereon, both variables would point to the same array, so using either one would affect the same array.\nJoining¶\nUse array.join() to concatenate all of the elements in the array into a string and separate these elements with the specified separator:\nv1 = array.new<string>(10, \"test\")\nv2 = array.new<string>(10, \"test\")\narray.push(v2, \"test1\")\nv3 = array.new_float(5, 5)\nv4 = array.new_int(5, 5)\nl1 = label.new(bar_index, close, array.join(v1))\nl2 = label.new(bar_index, close, array.join(v2, \",\"))\nl3 = label.new(bar_index, close, array.join(v3, \",\"))\nl4 = label.new(bar_index, close, array.join(v4, \",\"))\nSorting¶\nArrays containing “int” or “float” elements can be sorted in either ascending or descending order using array.sort(). The order parameter is optional and defaults to order.ascending. As all array.*() function arguments, it is qualified as “series”, so can be determined at runtime, as is done here. Note that in the example, which array is sorted is also determined at runtime:\nindicator(\"`array.sort()`\")\na = array.new<float>(0)\nb = array.new<float>(0)\narray.push(a, 2)\narray.push(a, 0)\narray.push(a, 1)\narray.push(b, 4)\narray.push(b, 3)\narray.push(b, 5)\nbarUp = close > open\narray.sort(barUp ? a : b, barUp ? order.ascending : order.descending)\nlabel.new(bar_index, 0,\n\"a \" + (barUp ? \"is sorted ▲: \" : \"is not sorted: \") + str.tostring(a) + \"\\n\\n\" +\n\"b \" + (barUp ? \"is not sorted: \" : \"is sorted ▼: \") + str.tostring(b), size = size.large)\nAnother useful option for sorting arrays is to use the array.sort_indices() function, which takes a reference to the original array and returns an array containing the indices from the original array. Please note that this function won’t modify the original array. The order parameter is optional and defaults to order.ascending.\nReversing¶\nUse array.reverse() to reverse an array:\nindicator(\"`array.reverse()`\")\na = array.new<float>(0)\narray.push(a, 0)\narray.push(a, 1)\narray.push(a, 2)\narray.reverse(a)\nlabel.new(bar_index, 0, \"a: \" + str.tostring(a))\nSlicing¶\nSlicing an array using array.slice() creates a shallow copy of a subset of the parent array. You determine the size of the subset to slice using the index_from and index_to parameters. The index_to argument must be one greater than the end of the subset you want to slice.\nThe shallow copy created by the slice acts like a window on the parent array’s content. The indices used for the slice define the window’s position and size over the parent array. If, as in the example below, a slice is created from the first three elements of an array (indices 0 to 2), then regardless of changes made to the parent array, and as long as it contains at least three elements, the shallow copy will always contain the parent array’s first three elements.\nAdditionally, once the shallow copy is created, operations on the copy are mirrored on the parent array. Adding an element to the end of the shallow copy, as is done in the following example, will widen the window by one element and also insert that element in the parent array at index 3. In this example, to slice the subset from index 0 to index 2 of array a, we must use _sliceOfA = array.slice(a, 0, 3):\nindicator(\"`array.slice()`\")\narray.push(a, 2)\narray.push(a, 3)\n// Create a shadow of elements at index 1 and 2 from array `a`.\nsliceOfA = array.slice(a, 0, 3)\nlabel.new(bar_index, 0, \"BEFORE\\na: \" + str.tostring(a) + \"\\nsliceOfA: \" + str.tostring(sliceOfA))\n// Remove first element of parent array `a`.\narray.remove(a, 0)\n// Add a new element at the end of the shallow copy, thus also affecting the original array `a`.\narray.push(sliceOfA, 4)\nlabel.new(bar_index, 0, \"AFTER\\na: \" + str.tostring(a) + \"\\nsliceOfA: \" + str.tostring(sliceOfA), style = label.style_label_up)\nSearching arrays¶\nWe can test if a value is part of an array with the array.includes() function, which returns true if the element is found. We can find the first occurrence of a value in an array by using the array.indexof() function. The first occurence is the one with the lowest index. We can also find the last occurrence of a value with array.lastindexof():\nindicator(\"Searching in arrays\")\nvalueInput = input.int(1)\narray.push(a, 2)\nvalueFound = array.includes(a, valueInput)\nfirstIndexFound = array.indexof(a, valueInput)\nlastIndexFound = array.lastindexof(a, valueInput)\nlabel.new(bar_index, 0, \"a: \" + str.tostring(a) +\n\"\\nFirst \" + str.tostring(valueInput) + (firstIndexFound != -1 ? \" value was found at index: \" + str.tostring(firstIndexFound) : \" value was not found.\") +\n\"\\nLast \" + str.tostring(valueInput) + (lastIndexFound != -1 ? \" value was found at index: \" + str.tostring(lastIndexFound) : \" value was not found.\"))\nWe can also perform a binary search on an array but note that performing a binary search on an array means that the array will first need to be sorted in ascending order only. The array.binary_search() function will return the value’s index if it was found or -1 if it wasn’t. If we want to always return an existing index from the array even if our chosen value wasn’t found, then we can use one of the other binary search functions available. The array.binary_search_leftmost() function, which returns an index if the value was found or the first index to the left where the value would be found. The array.binary_search_rightmost() function is almost identical and returns an index if the value was found or the first index to the right where the value would be found.\nError handling¶\nMalformed array.*() call syntax in Pine scripts will cause the usual compiler error messages to appear in Pine Editor’s console, at the bottom of the window, when you save a script. Refer to the Pine Script™ v5 Reference Manual when in doubt regarding the exact syntax of function calls.\nScripts using arrays can also throw runtime errors, which appear as an exclamation mark next to the indicator’s name on the chart. We discuss those runtime errors in this section.\nIndex xx is out of bounds. Array size is yy¶\nThis will most probably be the most frequent error you encounter. It will happen when you reference an nonexistent array index. The “xx” value will be the value of the faulty index you tried to use, and “yy” will be the size of the array. Recall that array indices start at zero—not one—and end at the array’s size, minus one. An array of size 3’s last valid index is thus 2.\nTo avoid this error, you must make provisions in your code logic to prevent using an index lying outside of the array’s index boundaries. This code will generate the error because the last index we use in the loop is outside the valid index range for the array:\nindicator(\"Out of bounds index\")\na = array.new<float>(3)\nfor i = 1 to 3\narray.set(a, i, i)\nplot(array.pop(a))\nThe correct for statement is:\nTo loop on all array elements in an array of unknown size, use:\nindicator(\"Protected `for` loop\")\nsizeInput = input.int(0, \"Array size\", minval = 0, maxval = 100000)\na = array.new<float>(sizeInput)\nfor i = 0 to (array.size(a) == 0 ? na : array.size(a) - 1)\narray.set(a, i, i)\nplot(array.pop(a))\nWhen you size arrays dynamically using a field in your script’s Settings/Inputs tab, protect the boundaries of that value using input.int()’s minval and maxval parameters:\nindicator(\"Protected array size\")\nsizeInput = input.int(10, \"Array size\", minval = 1, maxval = 100000)\na = array.new<float>(sizeInput)\nfor i = 0 to sizeInput - 1\narray.set(a, i, i)\nplot(array.size(a))\nSee the Looping section of this page for more information.\nCannot call array methods when ID of array is ‘na’¶\nWhen an array ID is initialized to na, operations on it are not allowed, since no array exists. All that exists at that point is an array variable containing the na value rather that a valid array ID pointing to an existing array. Note that an array created with no elements in it, as you do when you use a = array.new_int(0), has a valid ID nonetheless. This code will throw the error we are discussing:\nindicator(\"Out of bounds index\")\narray<int> a = na\narray.push(a, 111)\nlabel.new(bar_index, 0, \"a: \" + str.tostring(a))\nTo avoid it, create an array with size zero using:\narray<int> a = array.new_int(0)\nor:\nArray is too large. Maximum size is 100000¶\nThis error will appear if your code attempts to declare an array with a size greater than 100,000. It will also occur if, while dynamically appending elements to an array, a new element would increase the array’s size past the maximum.\nCannot create an array with a negative size¶\nWe haven’t found any use for arrays of negative size yet, but if you ever do, we may allow them :)\nCannot use shift() if array is empty.¶\nThis error will occur if array.shift() is called to remove the first element of an empty array.\nCannot use pop() if array is empty.¶\nThis error will occur if array.pop() is called to remove the last element of an empty array.\nIndex ‘from’ should be less than index ‘to’¶\nWhen two indices are used in functions such as array.slice(), the first index must always be smaller than the second one.\nSlice is out of bounds of the parent array¶\nThis message occurs whenever the parent array’s size is modified in such a way that it makes the shallow copy created by a slice point outside the boundaries of the parent array. This code will reproduce it because after creating a slice from index 3 to 4 (the last two elements of our five-element parent array), we remove the parent’s first element, making its size four and its last index 3. From that moment on, the shallow copy which is still poiting to the “window” at the parent array’s indices 3 to 4, is pointing out of the parent array’s boundaries:\nindicator(\"Slice out of bounds\")\na = array.new<float>(5, 0)\nb = array.slice(a, 3, 5)\narray.remove(a, 0)\nc = array.indexof(b, 2)\nplot(c)"
},
{
  "text": "Matrices¶\nDeclaring a matrix\nUsing `var` and `varip` keywords\nReading and writing matrix elements\n`matrix.get()` and `matrix.set()`\n`matrix.fill()`\nRows and columns\nRetrieving\nInserting\nRemoving\nSwapping\nReplacing\nLooping through a matrix\n`for`\n`for…in`\nCopying a matrix\nShallow copies\nDeep copies\nSubmatrices\nScope and history\nInspecting a matrix\nManipulating a matrix\nReshaping\nReversing\nTransposing\nSorting\nConcatenating\nMatrix calculations\nElement-wise calculations\nSpecial calculations\n`matrix.sum()` and `matrix.diff()`\n`matrix.mult()`\n`matrix.det()`\n`matrix.inv()` and `matrix.pinv()`\n`matrix.rank()`\nError handling\nThe row/column index (xx) is out of bounds, row/column size is (yy).\nThe array size does not match the number of rows/columns in the matrix.\nCannot call matrix methods when the ID of matrix is ‘na’.\nMatrix is too large. Maximum size of the matrix is 100,000 elements.\nThe row/column index must be 0 <= from_row/column < to_row/column.\nMatrices ‘id1’ and ‘id2’ must have an equal number of rows and columns to be added.\nThe number of columns in the ‘id1’ matrix must equal the number of rows in the matrix (or the number of elements in the array) ‘id2’.\nOperation not available for non-square matrices.\nThis page contains advanced material. If you are a beginning Pine Script™ programmer, we recommend you become familiar with other, more accessible Pine Script™ features before you venture here.\nPine Script™ Matrices are collections that store value references in a rectangular format. They are essentially the equivalent of two-dimensional array objects with functions and methods for inspection, modification, and specialized calculations. As with arrays, all matrix elements must be of the same type, which can be a built-in or a user-defined type.\nMatrices reference their elements using two indices: one index for their rows and the other for their columns. Each index starts at 0 and extends to the number of rows/columns in the matrix minus one. Matrices in Pine can have dynamic numbers of rows and columns that vary across bars. The total number of elements within a matrix is the product of the number of rows and columns (e.g., a 5x5 matrix has a total of 25). Like arrays, the total number of elements in a matrix cannot exceed 100,000.\nDeclaring a matrix¶\nPine Script™ uses the following syntax for matrix declaration:\n[var/varip ][matrix<type> ]<identifier> = <expression>\nWhere <type> is a type template for the matrix that declares the type of values it will contain, and the <expression> returns either a matrix instance of the type or na.\nWhen declaring a matrix variable as na, users must specify that the identifier will reference matrices of a specific type by including the matrix keyword followed by a type template.\nThis line declares a new myMatrix variable with a value of na. It explicitly declares the variable as matrix<float>, which tells the compiler that the variable can only accept matrix objects containing float values:\nmatrix<float> myMatrix = na\nWhen a matrix variable is not assigned to na, the matrix keyword and its type template are optional, as the compiler will use the type information from the object the variable references.\nHere, we declare a myMatrix variable referencing a new matrix<float> instance with two rows, two columns, and an initial_value of 0. The variable gets its type information from the new object in this case, so it doesn’t require an explicit type declaration:\nmyMatrix = matrix.new<float>(2, 2, 0.0)\nUsing `var` and `varip` keywords¶\nAs with other variables, users can include the var or varip keywords to instruct a script to declare a matrix variable only once rather than on every bar. A matrix variable declared with this keyword will point to the same instance throughout the span of the chart unless the script explicitly assigns another matrix to it, allowing a matrix and its element references to persist between script iterations.\nThis script declares an m variable assigned to a matrix that holds a single row of two int elements using the var keyword. On every 20th bar, the script adds 1 to the first element on the first row of the m matrix. The plot() call displays this element on the chart. As we see from the plot, the value of m.get(0, 0) persists between bars, never returning to the initial value of 0:\nindicator(\"var matrix demo\")\n//@variable A 1x2 rectangular matrix declared only at `bar_index == 0`, i.e., the first bar.\nvar m = matrix.new<int>(1, 2, 0)\n//@variable Is `true` on every 20th bar.\nbool update = bar_index % 20 == 0\nif update\nint currentValue = m.get(0, 0) // Get the current value of the first row and column.\nm.set(0, 0, currentValue + 1) // Set the first row and column element value to `currentValue + 1`.\nplot(m.get(0, 0), linewidth = 3) // Plot the value from the first row and column.\nMatrix variables declared using varip behave as ones using var on historical data, but they update their values for realtime bars (i.e., the bars since the script’s last compilation) on each new price tick. Matrices assigned to varip variables can only hold int, float, bool, color, or string types or user-defined types that exclusively contain within their fields these types or collections (arrays, matrices, or maps) of these types.\nReading and writing matrix elements¶\n`matrix.get()` and `matrix.set()`¶\nTo retrieve the value from a matrix at a specified row and column index, use matrix.get(). This function locates the specified matrix element and returns its value. Similarly, to overwrite a specific element’s value, use matrix.set() to assign the element at the specified row and column to a new value.\nThe example below defines a square matrix m with two rows and columns and an initial_value of 0 for all elements on the first bar. The script adds 1 to each element’s value on different bars using the m.get() and m.set() methods. It updates the first row’s first value once every 11 bars, the first row’s second value once every seven bars, the second row’s first value once every five bars, and the second row’s second value once every three bars. The script plots each element’s value on the chart:\nindicator(\"Reading and writing elements demo\")\n//@variable A 2x2 square matrix of `float` values.\nvar m = matrix.new<float>(2, 2, 0.0)\nbar_index % 11 == 0 => m.set(0, 0, m.get(0, 0) + 1.0) // Adds 1 to the value at row 0, column 0 every 11th bar.\nbar_index % 7 == 0 => m.set(0, 1, m.get(0, 1) + 1.0) // Adds 1 to the value at row 0, column 1 every 7th bar.\nbar_index % 5 == 0 => m.set(1, 0, m.get(1, 0) + 1.0) // Adds 1 to the value at row 1, column 0 every 5th bar.\nbar_index % 3 == 0 => m.set(1, 1, m.get(1, 1) + 1.0) // Adds 1 to the value at row 1, column 1 every 3rd bar.\nplot(m.get(0, 0), \"Row 0, Column 0 Value\", color.red, 2)\nplot(m.get(0, 1), \"Row 0, Column 1 Value\", color.orange, 2)\nplot(m.get(1, 0), \"Row 1, Column 0 Value\", color.green, 2)\nplot(m.get(1, 1), \"Row 1, Column 1 Value\", color.blue, 2)\n`matrix.fill()`¶\nTo overwrite all matrix elements with a specific value, use matrix.fill(). This function points all items in the entire matrix or within the from_row/column and to_row/column index range to the value specified in the call. For example, this snippet declares a 4x4 square matrix, then fills its elements with a random value:\nmyMatrix = matrix.new<float>(4, 4)\nmyMatrix.fill(math.random())\nNote when using matrix.fill() with matrices containing special types (line, linefill, box, polyline, label, table, or chart.point) or UDTs, all replaced elements will point to the same object passed in the function call.\nThis script declares a matrix with four rows and columns of label references, which it fills with a new label object on the first bar. On each bar, the script sets the x attribute of the label referenced at row 0, column 0 to bar_index, and the text attribute of the one referenced at row 3, column 3 to the number of labels on the chart. Although the matrix can reference 16 (4x4) labels, each element points to the same instance, resulting in only one label on the chart that updates its x and text attributes on each bar:\nindicator(\"Object matrix fill demo\")\n//@variable A 4x4 label matrix.\nvar matrix<label> m = matrix.new<label>(4, 4)\n// Fill `m` with a new label object on the first bar.\nif bar_index == 0\nm.fill(label.new(0, 0, textcolor = color.white, size = size.huge))\n//@variable The number of label objects on the chart.\nint numLabels = label.all.size()\n// Set the `x` of the label from the first row and column to `bar_index`.\nm.get(0, 0).set_x(bar_index)\n// Set the `text` of the label at the last row and column to the number of labels.\nm.get(3, 3).set_text(str.format(\"Total labels on the chart: {0}\", numLabels))\nRows and columns¶\nRetrieving¶\nMatrices facilitate the retrieval of all values from a specific row or column via the matrix.row() and matrix.col() functions. These functions return the values as an array object sized according to the other dimension of the matrix, i.e., the size of a matrix.row() array equals the number of columns and the size of a matrix.col() array equals the number of rows.\nThe script below populates a 3x2 m matrix with the values 1 - 6 on the first chart bar. It calls the m.row() and m.col() methods to access the first row and column arrays from the matrix and displays them on the chart in a label along with the array sizes:\nindicator(\"Retrieving rows and columns demo\")\n//@variable A 3x2 rectangular matrix.\nvar matrix<float> m = matrix.new<float>(3, 2)\nif bar_index == 0\nm.set(0, 0, 1.0) // Set row 0, column 0 value to 1.\nm.set(0, 1, 2.0) // Set row 0, column 1 value to 2.\nm.set(1, 0, 3.0) // Set row 1, column 0 value to 3.\nm.set(1, 1, 4.0) // Set row 1, column 1 value to 4.\nm.set(2, 0, 5.0) // Set row 1, column 0 value to 5.\nm.set(2, 1, 6.0) // Set row 1, column 1 value to 6.\n//@variable The first row of the matrix.\narray<float> row0 = m.row(0)\n//@variable The first column of the matrix.\narray<float> column0 = m.col(0)\n//@variable Displays the first row and column of the matrix and their sizes in a label.\nvar label debugLabel = label.new(0, 0, color = color.blue, textcolor = color.white, size = size.huge)\ndebugLabel.set_x(bar_index)\ndebugLabel.set_text(str.format(\"Row 0: {0}, Size: {1}\\nCol 0: {2}, Size: {3}\", row0, m.columns(), column0, m.rows()))\nTo get the sizes of the arrays displayed in the label, we used the rows() and columns() methods rather than array.size() to demonstrate that the size of the row0 array equals the number of columns and the size of the column0 array equals the number of rows.\nmatrix.row() and matrix.col() copy the references in a row/column to a new array. Modifications to the arrays returned by these functions do not directly affect the elements or the shape of a matrix.\nHere, we’ve modified the previous script to set the first element of row0 to 10 via the array.set() method before displaying the label. This script also plots the value from row 0, column 0. As we see, the label shows that the first element of the row0 array is 10. However, the plot shows that the corresponding matrix element still has a value of 1:\nindicator(\"Retrieving rows and columns demo\")\n//@variable A 3x2 rectangular matrix.\nvar matrix<float> m = matrix.new<float>(3, 2)\nif bar_index == 0\nm.set(0, 0, 1.0) // Set row 0, column 0 value to 1.\nm.set(0, 1, 2.0) // Set row 0, column 1 value to 2.\nm.set(1, 0, 3.0) // Set row 1, column 0 value to 3.\nm.set(1, 1, 4.0) // Set row 1, column 1 value to 4.\nm.set(2, 0, 5.0) // Set row 1, column 0 value to 5.\nm.set(2, 1, 6.0) // Set row 1, column 1 value to 6.\n//@variable The first row of the matrix.\narray<float> row0 = m.row(0)\n//@variable The first column of the matrix.\narray<float> column0 = m.col(0)\n// Set the first `row` element to 10.\nrow0.set(0, 10)\n//@variable Displays the first row and column of the matrix and their sizes in a label.\nvar label debugLabel = label.new(0, m.get(0, 0), color = color.blue, textcolor = color.white, size = size.huge)\ndebugLabel.set_x(bar_index)\ndebugLabel.set_text(str.format(\"Row 0: {0}, Size: {1}\\nCol 0: {2}, Size: {3}\", row0, m.columns(), column0, m.rows()))\n// Plot the first element of `m`.\nplot(m.get(0, 0), linewidth = 3)\nAlthough changes to an array returned by matrix.row() or matrix.col() do not directly affect a parent matrix, it’s important to note the resulting array from a matrix containing UDTs or special types, including line, linefill, box, polyline, label, table, or chart.point, behaves as a shallow copy of a row/column, i.e., the elements within an array returned from these functions point to the same objects as the corresponding matrix elements.\nThis script contains a custom myUDT type containing a value field with an initial value of 0. It declares a 1x1 m matrix to hold a single myUDT instance on the first bar, then calls m.row(0) to copy the first row of the matrix as an array. On every chart bar, the script adds 1 to the value field of the first row array element. In this case, the value field of the matrix element increases on every bar as well since both elements reference the same object:\nindicator(\"Row with reference types demo\")\n//@type A custom type that holds a float value.\ntype myUDT\nfloat value = 0.0\n//@variable A 1x1 matrix of `myUDT` type.\nvar matrix<myUDT> m = matrix.new<myUDT>(1, 1, myUDT.new())\n//@variable A shallow copy of the first row of `m`.\narray<myUDT> row = m.row(0)\n//@variable The first element of the `row`.\nmyUDT firstElement = row.get(0)\nfirstElement.value += 1.0 // Add 1 to the `value` field of `firstElement`. Also affects the element in the matrix.\nplot(m.get(0, 0).value, linewidth = 3) // Plot the `value` of the `myUDT` object from the first row and column of `m`.\nInserting¶\nScripts can add new rows and columns to a matrix via matrix.add_row() and matrix.add_col(). These functions insert the value references from an array into a matrix at the specified row/column index. If the id matrix is empty (has no rows or columns), the array_id in the call can be of any size. If a row/column exists at the specified index, the matrix increases the index value for the existing row/column and all after it by 1.\nThe script below declares an empty m matrix and inserts rows and columns using the m.add_row() and m.add_col() methods. It first inserts an array with three elements at row 0, turning m into a 1x3 matrix, then another at row 1, changing the shape to 2x3. After that, the script inserts another array at row 0, which changes the shape of m to 3x3 and shifts the index of all rows previously at index 0 and higher. It inserts another array at the last column index, changing the shape to 3x4. Finally, it adds an array with four values at the end row index.\nThe resulting matrix has four rows and columns and contains values 1-16 in ascending order. The script displays the rows of m after each row/column insertion with a user-defined debugLabel() function to visualize the process:\nindicator(\"Rows and columns demo\")\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The `bar_index` to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\n\" + str.tostring(this)\nif barstate.ishistory\nbarIndex, 0, labelText, color = bgColor, style = label.style_label_center,\ntextcolor = textColor, size = size.huge\n//Create an empty matrix.\nvar m = matrix.new<float>()\nif bar_index == last_bar_index - 1\ndebugLabel(m, bar_index - 30, note = \"Empty matrix\")\n// Insert an array at row 0. `m` will now have 1 row and 3 columns.\nm.add_row(0, array.from(5, 6, 7))\ndebugLabel(m, bar_index - 20, note = \"New row at\\nindex 0\")\n// Insert an array at row 1. `m` will now have 2 rows and 3 columns.\nm.add_row(1, array.from(9, 10, 11))\ndebugLabel(m, bar_index - 10, note = \"New row at\\nindex 1\")\n// Insert another array at row 0. `m` will now have 3 rows and 3 columns.\n// The values previously on row 0 will now be on row 1, and the values from row 1 will be on row 2.\nm.add_row(0, array.from(1, 2, 3))\ndebugLabel(m, bar_index, note = \"New row at\\nindex 0\")\n// Insert an array at column 3. `m` will now have 3 rows and 4 columns.\nm.add_col(3, array.from(4, 8, 12))\ndebugLabel(m, bar_index + 10, note = \"New column at\\nindex 3\")\n// Insert an array at row 3. `m` will now have 4 rows and 4 columns.\nm.add_row(3, array.from(13, 14, 15, 16))\ndebugLabel(m, bar_index + 20, note = \"New row at\\nindex 3\")\nJust as the row or column arrays retrieved from a matrix of line, linefill, box, polyline, label, table, chart.point, or UDT instances behave as shallow copies, the elements of matrices containing such types reference the same objects as the arrays inserted into them. Modifications to the element values in either object affect the other in such cases.\nRemoving¶\nTo remove a specific row or column from a matrix, use matrix.remove_row() and matrix.remove_col(). These functions remove the specified row/column and decrease the index values of all rows/columns after it by 1.\nFor this example, we’ve added these lines of code to our “Rows and columns demo” script from the section above:\n// Removing example\n// Remove the first row and last column from the matrix. `m` will now have 3 rows and 3 columns.\nm.remove_row(0)\nm.remove_col(3)\ndebugLabel(m, bar_index + 30, color.red, note = \"Removed row 0\\nand column 3\")\nThis code removes the first row and the last column of the m matrix using the m.remove_row() and m.remove_col() methods and displays the rows in a label at bar_index + 30. As we can see, m has a 3x3 shape after executing this block, and the index values for all existing rows are reduced by 1:\nSwapping¶\nTo swap the rows and columns of a matrix without altering its dimensions, use matrix.swap_rows() and matrix.swap_columns(). These functions swap the locations of the elements at the row1/column1 and row2/column2 indices.\nLet’s add the following lines to the previous example, which swap the first and last rows of m and display the changes in a label at bar_index + 40:\n// Swapping example\n// Swap the first and last row. `m` retains the same dimensions.\nm.swap_rows(0, 2)\ndebugLabel(m, bar_index + 40, color.purple, note = \"Swapped rows 0\\nand 2\")\nIn the new label, we see the matrix has the same number of rows as before, and the first and last rows have traded places:\nReplacing¶\nIt may be desirable in some cases to completely replace a row or column in a matrix. To do so, insert the new array at the desired row/column and remove the old elements previously at that index.\nIn the following code, we’ve defined a replaceRow() method that uses the add_row() method to insert the new values at the row index and uses the remove_row() method to remove the old row that moved to the row + 1 index. This script uses the replaceRow() method to fill the rows of a 3x3 matrix with the numbers 1-9. It draws a label on the chart before and after replacing the rows using the custom debugLabel() method:\nindicator(\"Replacing rows demo\")\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The `bar_index` to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\n\" + str.tostring(this)\nif barstate.ishistory\nbarIndex, 0, labelText, color = bgColor, style = label.style_label_center,\ntextcolor = textColor, size = size.huge\n//@function Replaces the `row` of `this` matrix with a new array of `values`.\n//@param row The row index to replace.\n//@param values The array of values to insert.\nmethod replaceRow(matrix<float> this, int row, array<float> values) =>\nthis.add_row(row, values) // Inserts a copy of the `values` array at the `row`.\nthis.remove_row(row + 1) // Removes the old elements previously at the `row`.\n//@variable A 3x3 matrix.\nvar matrix<float> m = matrix.new<float>(3, 3, 0.0)\nif bar_index == last_bar_index - 1\nm.debugLabel(note = \"Original\")\n// Replace each row of `m`.\nm.replaceRow(0, array.from(1.0, 2.0, 3.0))\nm.replaceRow(1, array.from(4.0, 5.0, 6.0))\nm.replaceRow(2, array.from(7.0, 8.0, 9.0))\nm.debugLabel(bar_index + 10, note = \"Replaced rows\")\nLooping through a matrix¶\n`for`¶\nWhen a script only needs to iterate over the row/column indices in a matrix, the most common method is to use for loops. For example, this line creates a loop with a row value that starts at 0 and increases by one until it reaches one less than the number of rows in the m matrix (i.e., the last row index):\nfor row = 0 to m.rows() - 1\nTo iterate over all index values in the m matrix, we can create a nested loop that iterates over each column index on each row value:\nfor row = 0 to m.rows() - 1\nfor column = 0 to m.columns() - 1\nLet’s use this nested structure to create a method that visualizes matrix elements. In the script below, we’ve defined a toTable() method that displays the elements of a matrix within a table object. It iterates over each row index and over each column index on every row. Within the loop, it converts each element to a string to display in the corresponding table cell.\nOn the first bar, the script creates an empty m matrix, populates it with rows, and calls m.toTable() to display its elements:\nindicator(\"for loop demo\", \"Matrix to table\")\n//@function Displays the elements of `this` matrix in a table.\n//@param this The matrix to display.\n//@param position The position of the table on the chart.\n//@param bgColor The background color of the table.\n//@param textColor The color of the text in each cell.\n//@param note A note string to display on the bottom row of the table.\n//@returns A new `table` object with cells corresponding to each element of `this` matrix.\nmethod toTable(\nmatrix<float> this, string position = position.middle_center,\ncolor bgColor = color.blue, color textColor = color.white,\nstring note = na\n) =>\n//@variable The number of rows in `this` matrix.\nint rows = this.rows()\n//@variable The number of columns in `this` matrix.\nint columns = this.columns()\n//@variable A table that displays the elements of `this` matrix with an optional `note` cell.\ntable result = table.new(position, columns, rows + 1, bgColor)\n// Iterate over each row index of `this` matrix.\nfor row = 0 to rows - 1\n// Iterate over each column index of `this` matrix on each `row`.\nfor col = 0 to columns - 1\n//@variable The element from `this` matrix at the `row` and `col` index.\nfloat element = this.get(row, col)\n// Initialize the corresponding `result` cell with the `element` value.\nresult.cell(col, row, str.tostring(element), text_color = textColor, text_size = size.huge)\n// Initialize a merged cell on the bottom row if a `note` is provided.\nif not na(note)\nresult.cell(0, rows, note, text_color = textColor, text_size = size.huge)\nresult.merge_cells(0, rows, columns - 1, rows)\nresult // Return the `result` table.\n//@variable A 3x4 matrix of values.\nvar m = matrix.new<float>()\nif bar_index == 0\n// Add rows to `m`.\nm.add_row(0, array.from(1, 2, 3))\nm.add_row(1, array.from(5, 6, 7))\nm.add_row(2, array.from(9, 10, 11))\n// Add a column to `m`.\nm.add_col(3, array.from(4, 8, 12))\n// Display the elements of `m` in a table.\nm.toTable()\n`for…in`¶\nWhen a script needs to iterate over and retrieve the rows of a matrix, using the for…in structure is often preferred over the standard for loop. This structure directly references the row arrays in a matrix, making it a more convenient option for such use cases. For example, this line creates a loop that returns a row array for each row in the m matrix:\nThe following indicator calculates the moving average of OHLC data with an input length and displays the values on the chart. The custom rowWiseAvg() method loops through the rows of a matrix using a for...in structure to produce an array containing the array.avg() of each row.\nOn the first chart bar, the script creates a new m matrix with four rows and length columns, which it queues a new column of OHLC data into via the m.add_col() and m.remove_col() methods on each subsequent bar. It uses m.rowWiseAvg() to calculate the array of row-wise averages, then it plots the element values on the chart:\nindicator(\"for...in loop demo\", \"Average OHLC\", overlay = true)\n//@variable The number of terms in the average.\nint length = input.int(20, \"Length\", minval = 1)\n//@function Calculates the average of each matrix row.\nmethod rowWiseAvg(matrix<float> this) =>\n//@variable An array with elements corresponding to each row's average.\narray<float> result = array.new<float>()\n// Iterate over each `row` of `this` matrix.\nfor row in this\n// Push the average of each `row` into the `result`.\nresult.push(row.avg())\nresult // Return the resulting array.\n//@variable A 4x`length` matrix of values.\nvar matrix<float> m = matrix.new<float>(4, length)\n// Add a new column containing OHLC values to the matrix.\nm.add_col(m.columns(), array.from(open, high, low, close))\n// Remove the first column.\nm.remove_col(0)\n//@variable An array containing averages of `open`, `high`, `low`, and `close` over `length` bars.\narray<float> averages = m.rowWiseAvg()\nplot(averages.get(0), \"Average Open\", color.blue, 2)\nplot(averages.get(1), \"Average High\", color.green, 2)\nplot(averages.get(2), \"Average Low\", color.red, 2)\nplot(averages.get(3), \"Average Close\", color.orange, 2)\nfor...in loops can also reference the index value of each row. For example, for [i, row] in m creates a tuple containing the i row index and the corresponding row array from the m matrix on each loop iteration.\nCopying a matrix¶\nShallow copies¶\nPine scripts can copy matrices via matrix.copy(). This function returns a shallow copy of a matrix that does not affect the shape of the original matrix or its references.\nFor example, this script assigns a new matrix to the myMatrix variable and adds two columns. It creates a new myCopy matrix from myMatrix using the myMatrix.copy() method, then adds a new row. It displays the rows of both matrices in labels via the user-defined debugLabel() function:\nindicator(\"Shallow copy demo\")\n//@function Displays the rows of a matrix in a label with a note.\n//@param this The matrix to display.\n//@param barIndex The `bar_index` to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\n) =>\nlabelText = note + \"\\n\" + str.tostring(this)\nif barstate.ishistory\nbarIndex, 0, labelText, color = bgColor, style = label.style_label_center,\ntextcolor = textColor, size = size.huge\n//@variable A 2x2 `float` matrix.\nmatrix<float> myMatrix = matrix.new<float>()\nmyMatrix.add_col(0, array.from(1.0, 3.0))\nmyMatrix.add_col(1, array.from(2.0, 4.0))\n//@variable A shallow copy of `myMatrix`.\nmatrix<float> myCopy = myMatrix.copy()\n// Add a row to the last index of `myCopy`.\nmyCopy.add_row(myCopy.rows(), array.from(5.0, 6.0))\nif bar_index == last_bar_index - 1\n// Display the rows of both matrices in separate labels.\nmyMatrix.debugLabel(note = \"Original\")\nmyCopy.debugLabel(bar_index + 10, color.green, note = \"Shallow Copy\")\nIt’s important to note that the elements within shallow copies of a matrix point to the same values as the original matrix. When matrices contain special types (line, linefill, box, polyline, label, table, or chart.point) or user-defined types, the elements of a shallow copy reference the same objects as the original.\nThis script declares a myMatrix variable with a newLabel as the initial value. It then copies myMatrix to a myCopy variable via myMatrix.copy() and plots the number of labels. As we see below, there’s only one label on the chart, as the element in myCopy references the same object as the element in myMatrix. Consequently, changes to the element values in myCopy affect the values in both matrices:\nindicator(\"Shallow copy demo\")\n//@variable Initial value of the original matrix elements.\nvar label newLabel = label.new(\nbar_index, 1, \"Original\", color = color.blue, textcolor = color.white, size = size.huge\n//@variable A 1x1 matrix containing a new `label` instance.\nvar matrix<label> myMatrix = matrix.new<label>(1, 1, newLabel)\n//@variable A shallow copy of `myMatrix`.\nvar matrix<label> myCopy = myMatrix.copy()\n//@variable The first label from the `myCopy` matrix.\nlabel testLabel = myCopy.get(0, 0)\n// Change the `text`, `style`, and `x` values of `testLabel`. Also affects the `newLabel`.\ntestLabel.set_text(\"Copy\")\ntestLabel.set_style(label.style_label_up)\ntestLabel.set_x(bar_index)\n// Plot the total number of labels.\nplot(label.all.size(), linewidth = 3)\nDeep copies¶\nOne can produce a deep copy of a matrix (i.e., a matrix whose elements point to copies of the original values) by explicitly copying each object the matrix references.\nHere, we’ve added a deepCopy() user-defined method to our previous script. The method creates a new matrix and uses nested for loops to assign all elements to copies of the originals. When the script calls this method instead of the built-in copy(), we see that there are now two labels on the chart, and any changes to the label from myCopy do not affect the one from myMatrix:\nindicator(\"Deep copy demo\")\n//@function Returns a deep copy of a label matrix.\nmethod deepCopy(matrix<label> this) =>\n//@variable A deep copy of `this` matrix.\nmatrix<label> that = this.copy()\nfor row = 0 to that.rows() - 1\nfor column = 0 to that.columns() - 1\n// Assign the element at each `row` and `column` of `that` matrix to a copy of the retrieved label.\nthat.set(row, column, that.get(row, column).copy())\nthat\n//@variable Initial value of the original matrix.\nvar label newLabel = label.new(\nbar_index, 2, \"Original\", color = color.blue, textcolor = color.white, size = size.huge\n//@variable A 1x1 matrix containing a new `label` instance.\nvar matrix<label> myMatrix = matrix.new<label>(1, 1, newLabel)\n//@variable A deep copy of `myMatrix`.\nvar matrix<label> myCopy = myMatrix.deepCopy()\n//@variable The first label from the `myCopy` matrix.\nlabel testLabel = myCopy.get(0, 0)\n// Change the `text`, `style`, and `x` values of `testLabel`. Does not affect the `newLabel`.\ntestLabel.set_text(\"Copy\")\ntestLabel.set_style(label.style_label_up)\ntestLabel.set_x(bar_index)\n// Change the `x` value of `newLabel`.\nnewLabel.set_x(bar_index)\n// Plot the total number of labels.\nplot(label.all.size(), linewidth = 3)\nSubmatrices¶\nIn Pine, a submatrix is a shallow copy of an existing matrix that only includes the rows and columns specified by the from_row/column and to_row/column parameters. In essence, it is a sliced copy of a matrix.\nFor example, the script below creates an mSub matrix from the m matrix via the m.submatrix() method, then calls our user-defined debugLabel() function to display the rows of both matrices in labels:\nindicator(\"Submatrix demo\")\n//@function Displays the rows of a matrix in a label with a note.\n//@param barIndex The `bar_index` to display the label at.\n//@param bgColor The background color of the label.\n//@param textColor The color of the label's text.\n//@param note The text to display above the rows.\nmethod debugLabel(\nmatrix<float> this, int barIndex = bar_index, color bgColor = color.blue,\ncolor textColor = color.white, string note = \"\"\nlabelText = note + \"\\n\" + str.tostring(this)\nif barstate.ishistory\nbarIndex, 0, labelText, color = bgColor, style = label.style_label_center,\ntextcolor = textColor, size = size.huge\n//@variable A 3x3 matrix of values.\nvar m = matrix.new<float>()\nif bar_index == last_bar_index - 1\n// Add columns to `m`.\nm.add_col(0, array.from(9, 6, 3))\nm.add_col(1, array.from(8, 5, 2))\nm.add_col(2, array.from(7, 4, 1))\n// Display the rows of `m`.\nm.debugLabel(note = \"Original Matrix\")\n//@variable A 2x2 submatrix of `m` containing the first two rows and columns.\nmatrix<float> mSub = m.submatrix(from_row = 0, to_row = 2, from_column = 0, to_column = 2)\n// Display the rows of `mSub`\ndebugLabel(mSub, bar_index + 10, bgColor = color.green, note = \"Submatrix\")\nScope and history¶\nMatrix variables leave historical trails on each bar, allowing scripts to use the history-referencing operator [] to interact with past matrix instances previously assigned to a variable. Additionally, scripts can modify matrices assigned to global variables from within the scopes of functions, methods, and conditional structures.\nThis script calculates the average ratios of body and wick distances relative to the bar range over length bars. It displays the data along with values from length bars ago in a table. The user-defined addData() function adds columns of current and historical ratios to the globalMatrix, and the calcAvg() function references previous matrices assigned to globalMatrix using the [] operator to calculate a matrix of averages:\nindicator(\"Scope and history demo\", \"Bar ratio comparison\")\nint length = input.int(10, \"Length\", 1)\n//@variable A global matrix.\nmatrix<float> globalMatrix = matrix.new<float>()\n//@function Calculates the ratio of body range to candle range.\nbodyRatio() =>\nmath.abs(close - open) / (high - low)\n//@function Calculates the ratio of upper wick range to candle range.\nupperWickRatio() =>\n(high - math.max(open, close)) / (high - low)\n//@function Calculates the ratio of lower wick range to candle range.\nlowerWickRatio() =>\n(math.min(open, close) - low) / (high - low)\n//@function Adds data to the `globalMatrix`.\naddData() =>\n// Add a new column of data at `column` 0.\nglobalMatrix.add_col(0, array.from(bodyRatio(), upperWickRatio(), lowerWickRatio()))\n//@variable The column of `globalMatrix` from index 0 `length` bars ago.\narray<float> pastValues = globalMatrix.col(0)[length]\n// Add `pastValues` to the `globalMatrix`, or an array of `na` if `pastValues` is `na`.\nif na(pastValues)\nglobalMatrix.add_col(1, array.new<float>(3))\nglobalMatrix.add_col(1, pastValues)\n//@function Returns the `length`-bar average of matrices assigned to `globalMatrix` on historical bars.\ncalcAvg() =>\n//@variable The sum historical `globalMatrix` matrices.\nmatrix<float> sums = matrix.new<float>(globalMatrix.rows(), globalMatrix.columns(), 0.0)\nfor i = 0 to length - 1\n//@variable The `globalMatrix` matrix `i` bars before the current bar.\nmatrix<float> previous = globalMatrix[i]\n// Break the loop if `previous` is `na`.\nif na(previous)\nsums.fill(na)\nbreak\n// Assign the sum of `sums` and `previous` to `sums`.\nsums := matrix.sum(sums, previous)\n// Divide the `sums` matrix by the `length`.\nresult = sums.mult(1.0 / length)\n// Add data to the `globalMatrix`.\naddData()\n//@variable The historical average of the `globalMatrix` matrices.\nglobalAvg = calcAvg()\n//@variable A `table` displaying information from the `globalMatrix`.\nvar table infoTable = table.new(\nposition.middle_center, globalMatrix.columns() + 1, globalMatrix.rows() + 1, bgcolor = color.navy\n// Define value cells.\nfor [i, row] in globalAvg\nfor [j, value] in row\ncolor textColor = value > 0.333 ? color.orange : color.gray\ninfoTable.cell(j + 1, i + 1, str.tostring(value), text_color = textColor, text_size = size.huge)\n// Define header cells.\ninfoTable.cell(0, 1, \"Body ratio\", text_color = color.white, text_size = size.huge)\ninfoTable.cell(0, 2, \"Upper wick ratio\", text_color = color.white, text_size = size.huge)\ninfoTable.cell(0, 3, \"Lower wick ratio\", text_color = color.white, text_size = size.huge)\ninfoTable.cell(1, 0, \"Current average\", text_color = color.white, text_size = size.huge)\ninfoTable.cell(2, 0, str.format(\"{0} bars ago\", length), text_color = color.white, text_size = size.huge)\nThe addData() and calcAvg() functions have no parameters, as they directly interact with the globalMatrix and length variables declared in the outer scope.\ncalcAvg() calculates the average by adding previous matrices using matrix.sum() and multiplying all elements by 1 / length using matrix.mult(). We discuss these and other specialized functions in our Matrix calculations section below.\nInspecting a matrix¶\nThe ability to inspect the shape of a matrix and patterns within its elements is crucial, as it helps reveal important information about a matrix and its compatibility with various calculations and transformations. Pine Script™ includes several built-ins for matrix inspection, including matrix.is_square(), matrix.is_identity(), matrix.is_diagonal(), matrix.is_antidiagonal(), matrix.is_symmetric(), matrix.is_antisymmetric(), matrix.is_triangular(), matrix.is_stochastic(), matrix.is_binary(), and matrix.is_zero().\nTo demonstrate these features, this example contains a custom inspect() method that uses conditional blocks with matrix.is_*() functions to return information about a matrix. It displays a string representation of an m matrix and the description returned from m.inspect() in labels on the chart:\nindicator(\"Matrix inspection demo\")\n//@function Inspects a matrix using `matrix.is_*()` functions and returns a `string` describing some of its features.\nmethod inspect(matrix<int> this)=>\n//@variable A string describing `this` matrix.\nstring result = \"This matrix:\\n\"\nif this.is_square()\nresult += \"- Has an equal number of rows and columns.\\n\"\nif this.is_binary()\nresult += \"- Contains only 1s and 0s.\\n\"\nif this.is_zero()\nresult += \"- Is filled with 0s.\\n\"\nif this.is_triangular()\nresult += \"- Contains only 0s above and/or below its main diagonal.\\n\"\nif this.is_diagonal()\nresult += \"- Only has nonzero values in its main diagonal.\\n\"\nif this.is_antidiagonal()\nresult += \"- Only has nonzero values in its main antidiagonal.\\n\"\nif this.is_symmetric()\nresult += \"- Equals its transpose.\\n\"\nif this.is_antisymmetric()\nresult += \"- Equals the negative of its transpose.\\n\"\nif this.is_identity()\nresult += \"- Is the identity matrix.\\n\"\nresult\n//@variable A 4x4 identity matrix.\nmatrix<int> m = matrix.new<int>()\n// Add rows to the matrix.\nm.add_row(0, array.from(1, 0, 0, 0))\nm.add_row(1, array.from(0, 1, 0, 0))\nm.add_row(2, array.from(0, 0, 1, 0))\nm.add_row(3, array.from(0, 0, 0, 1))\n// Display the `m` matrix in a blue label.\nbar_index, 0, str.tostring(m), color = color.blue, style = label.style_label_right,\ntextcolor = color.white, size = size.huge\n// Display the result of `m.inspect()` in a purple label.\nbar_index, 0, m.inspect(), color = color.purple, style = label.style_label_left,\ntextcolor = color.white, size = size.huge\nManipulating a matrix¶\nReshaping¶\nThe shape of a matrix can determine its compatibility with various matrix operations. In some cases, it is necessary to change the dimensions of a matrix without affecting the number of elements or the values they reference, otherwise known as reshaping. To reshape a matrix in Pine, use the matrix.reshape() function.\nThis example demonstrates the results of multiple reshaping operations on a matrix. The initial m matrix has a 1x8 shape (one row and eight columns). Through successive calls to the m.reshape() method, the script changes the shape of m to 2x4, 4x2, and 8x1. It displays each reshaped matrix in a label on the chart using the custom debugLabel() method:\nindicator(\"Reshaping example\")\n//@variable A matrix containing the values 1-8.\nmatrix<int> m = matrix.new<int>()\n// Add the initial vector of values.\nm.add_row(0, array.from(1, 2, 3, 4, 5, 6, 7, 8))\nm.debugLabel(note = \"Initial 1x8 matrix\")\n// Reshape. `m` now has 2 rows and 4 columns.\nm.reshape(2, 4)\nm.debugLabel(bar_index + 10, note = \"Reshaped to 2x4\")\n// Reshape. `m` now has 4 rows and 2 columns.\nm.reshape(4, 2)\nm.debugLabel(bar_index + 20, note = \"Reshaped to 4x2\")\n// Reshape. `m` now has 8 rows and 1 column.\nm.reshape(8, 1)\nm.debugLabel(bar_index + 30, note = \"Reshaped to 8x1\")\nThe order of elements in m does not change with each m.reshape() call.\nWhen reshaping a matrix, the product of the rows and columns arguments must equal the matrix.elements_count() value, as matrix.reshape() cannot change the number of elements in a matrix.\nReversing¶\nOne can reverse the order of all elements in a matrix using matrix.reverse(). This function moves the references of an m-by-n matrix id at the i-th row and j-th column to the m - 1 - i row and n - 1 - j column.\nFor example, this script creates a 3x3 matrix containing the values 1-9 in ascending order, then uses the reverse() method to reverse its contents. It displays the original and modified versions of the matrix in labels on the chart via m.debugLabel():\nindicator(\"Reversing demo\")\n//@variable A 3x3 matrix.\nmatrix<float> m = matrix.new<float>()\n// Add rows to `m`.\nm.add_row(0, array.from(1, 2, 3))\nm.add_row(1, array.from(4, 5, 6))\nm.add_row(2, array.from(7, 8, 9))\n// Display the contents of `m`.\nm.debugLabel(note = \"Original\")\n// Reverse `m`, then display its contents.\nm.reverse()\nm.debugLabel(bar_index + 10, color.red, note = \"Reversed\")\nTransposing¶\nTransposing a matrix is a fundamental operation that flips all rows and columns in a matrix about its main diagonal (the diagonal vector of all values in which the row index equals the column index). This process produces a new matrix with reversed row and column dimensions, known as the transpose. Scripts can calculate the transpose of a matrix using matrix.transpose().\nFor any m-row, n-column matrix, the matrix returned from matrix.transpose() will have n rows and m columns. All elements in a matrix at the i-th row and j-th column correspond to the elements in its transpose at the j-th row and i-th column.\nThis example declares a 2x4 m matrix, calculates its transpose using the m.transpose() method, and displays both matrices on the chart using our custom debugLabel() method. As we can see below, the transposed matrix has a 4x2 shape, and the rows of the transpose match the columns of the original:\nindicator(\"Transpose example\")\n//@variable A 2x4 matrix.\nmatrix<int> m = matrix.new<int>()\n// Add columns to `m`.\nm.add_col(0, array.from(1, 5))\nm.add_col(1, array.from(2, 6))\nm.add_col(2, array.from(3, 7))\nm.add_col(3, array.from(4, 8))\n//@variable The transpose of `m`. Has a 4x2 shape.\nmatrix<int> mt = m.transpose()\nm.debugLabel(note = \"Original\")\nmt.debugLabel(bar_index + 10, note = \"Transpose\")\nSorting¶\nScripts can sort the contents of a matrix via matrix.sort(). Unlike array.sort(), which sorts elements, this function organizes all rows in a matrix in a specified order (order.ascending by default) based on the values in a specified column.\nThis script declares a 3x3 m matrix, sorts the rows of the m1 copy in ascending order based on the first column, then sorts the rows of the m2 copy in descending order based on the second column. It displays the original matrix and sorted copies in labels using our debugLabel() method:\nindicator(\"Sorting rows example\")\n//@variable A 3x3 matrix.\nmatrix<int> m = matrix.new<int>()\n// Add rows to `m`.\nm.add_row(0, array.from(3, 2, 4))\nm.add_row(1, array.from(1, 9, 6))\nm.add_row(2, array.from(7, 8, 9))\nm.debugLabel(note = \"Original\")\n// Copy `m` and sort rows in ascending order based on the first column (default).\nmatrix<int> m1 = m.copy()\nm1.sort()\nm1.debugLabel(bar_index + 10, color.green, note = \"Sorted using col 0\\n(Ascending)\")\n// Copy `m` and sort rows in descending order based on the second column.\nmatrix<int> m2 = m.copy()\nm2.sort(1, order.descending)\nm2.debugLabel(bar_index + 20, color.red, note = \"Sorted using col 1\\n(Descending)\")\nIt’s important to note that matrix.sort() does not sort the columns of a matrix. However, one can use this function to sort matrix columns with the help of matrix.transpose().\nAs an example, this script contains a sortColumns() method that uses the sort() method to sort the transpose of a matrix using the column corresponding to the row of the original matrix. The script uses this method to sort the m matrix based on the contents of its first row:\nindicator(\"Sorting columns example\")\n//@function Sorts the columns of `this` matrix based on the values in the specified `row`.\nmethod sortColumns(matrix<int> this, int row = 0, bool ascending = true) =>\n//@variable The transpose of `this` matrix.\nmatrix<int> thisT = this.transpose()\n//@variable Is `order.ascending` when `ascending` is `true`, `order.descending` otherwise.\norder = ascending ? order.ascending : order.descending\n// Sort the rows of `thisT` using the `row` column.\nthisT.sort(row, order)\n//@variable A copy of `this` matrix with sorted columns.\nresult = thisT.transpose()\n//@variable A 3x3 matrix.\n// Add rows to `m`.\nm.add_row(0, array.from(3, 2, 4))\nm.add_row(1, array.from(1, 9, 6))\nm.add_row(2, array.from(7, 8, 9))\n// Sort the columns of `m` based on the first row and display the result.\nm.sortColumns(0).debugLabel(bar_index + 10, note = \"Sorted using row 0\\n(Ascending)\")\nConcatenating¶\nScripts can concatenate two matrices using matrix.concat(). This function appends the rows of an id2 matrix to the end of an id1 matrix with the same number of columns.\nTo create a matrix with elements representing the columns of a matrix appended to another, transpose both matrices, use matrix.concat() on the transposed matrices, then transpose() the result.\nFor example, this script appends the rows of the m2 matrix to the m1 matrix and appends their columns using transposed copies of the matrices. It displays the m1 and m2 matrices and the results after concatenating their rows and columns in labels using the custom debugLabel() method:\nindicator(\"Concatenation demo\")\n//@variable A 2x3 matrix filled with 1s.\nmatrix<int> m1 = matrix.new<int>(2, 3, 1)\n//@variable A 2x3 matrix filled with 2s.\nmatrix<int> m2 = matrix.new<int>(2, 3, 2)\n//@variable The transpose of `m1`.\nt1 = m1.transpose()\n//@variable The transpose of `m2`.\nt2 = m2.transpose()\n// Display the original matrices.\nm1.debugLabel(note = \"Matrix 1\")\nm2.debugLabel(bar_index + 10, note = \"Matrix 2\")\n// Append the rows of `m2` to the end of `m1` and display `m1`.\nm1.concat(m2)\nm1.debugLabel(bar_index + 20, color.blue, note = \"Appended rows\")\n// Append the rows of `t2` to the end of `t1`, then display the transpose of `t1.\nt1.concat(t2)\nt1.transpose().debugLabel(bar_index + 30, color.purple, note = \"Appended columns\")\nMatrix calculations¶\nElement-wise calculations¶\nPine scripts can calculate the average, minimum, maximum, and mode of all elements within a matrix via matrix.avg(), matrix.min(), matrix.max(), and matrix.mode(). These functions operate the same as their array.* equivalents, allowing users to run element-wise calculations on a matrix, its submatrices, and its rows and columns using the same syntax. For example, the built-in *.avg() functions called on a 3x3 matrix with values 1-9 and an array with the same nine elements will both return a value of 5.\nThe script below uses *.avg(), *.max(), and *.min() methods to calculate developing averages and extremes of OHLC data in a period. It adds a new column of open, high, low, and close values to the end of the ohlcData matrix whenever queueColumn is true. When false, the script uses the get() and set() matrix methods to adjust the elements in the last column for developing HLC values in the current period. It uses the ohlcData matrix, a submatrix(), and row() and col() arrays to calculate the developing OHLC4 and HL2 averages over length periods, the maximum high and minimum low over length periods, and the current period’s developing OHLC4 price:\nindicator(\"Element-wise calculations example\", \"Developing values\", overlay = true)\n//@variable The number of data points in the averages.\nint length = input.int(3, \"Length\", 1)\n//@variable The timeframe of each reset period.\nstring timeframe = input.timeframe(\"D\", \"Reset Timeframe\")\n//@variable A 4x`length` matrix of OHLC values.\nvar matrix<float> ohlcData = matrix.new<float>(4, length)\n//@variable Is `true` at the start of a new bar at the `timeframe`.\nbool queueColumn = timeframe.change(timeframe)\nif queueColumn\n// Add new values to the end column of `ohlcData`.\nohlcData.add_col(length, array.from(open, high, low, close))\n// Remove the oldest column from `ohlcData`.\nohlcData.remove_col(0)\n// Adjust the last element of column 1 for new highs.\nif high > ohlcData.get(1, length - 1)\nohlcData.set(1, length - 1, high)\n// Adjust the last element of column 2 for new lows.\nif low < ohlcData.get(2, length - 1)\nohlcData.set(2, length - 1, low)\n// Adjust the last element of column 3 for the new closing price.\nohlcData.set(3, length - 1, close)\n//@variable The `matrix.avg()` of all elements in `ohlcData`.\navgOHLC4 = ohlcData.avg()\n//@variable The `matrix.avg()` of all elements in rows 1 and 2, i.e., the average of all `high` and `low` values.\navgHL2 = ohlcData.submatrix(from_row = 1, to_row = 3).avg()\n//@variable The `matrix.max()` of all values in `ohlcData`. Equivalent to `ohlcData.row(1).max()`.\nmaxHigh = ohlcData.max()\n//@variable The `array.min()` of all `low` values in `ohlcData`. Equivalent to `ohlcData.min()`.\nminLow = ohlcData.row(2).min()\n//@variable The `array.avg()` of the last column in `ohlcData`, i.e., the current OHLC4.\nohlc4Value = ohlcData.col(length - 1).avg()\nplot(avgOHLC4, \"Average OHLC4\", color.purple, 2)\nplot(avgHL2, \"Average HL2\", color.navy, 2)\nplot(maxHigh, \"Max High\", color.green)\nplot(minLow, \"Min Low\", color.red)\nplot(ohlc4Value, \"Current OHLC4\", color.blue)\nIn this example, we used array.*() and matrix.*() methods interchangeably to demonstrate their similarities in syntax and behavior.\nUsers can calculate the matrix equivalent of array.sum() by multiplying the matrix.avg() by the matrix.elements_count().\nSpecial calculations¶\nPine Script™ features several built-in functions for performing essential matrix arithmetic and linear algebra operations, including matrix.sum(), matrix.diff(), matrix.mult(), matrix.pow(), matrix.det(), matrix.inv(), matrix.pinv(), matrix.rank(), matrix.trace(), matrix.eigenvalues(), matrix.eigenvectors(), and matrix.kron(). These functions are advanced features that facilitate a variety of matrix calculations and transformations.\nBelow, we explain a few fundamental functions with some basic examples.\n`matrix.sum()` and `matrix.diff()`¶\nScripts can perform addition and subtraction of two matrices with the same shape or a matrix and a scalar value using the matrix.sum() and matrix.diff() functions. These functions use the values from the id2 matrix or scalar to add to or subtract from the elements in id1.\nThis script demonstrates a simple example of matrix addition and subtraction in Pine. It creates a 3x3 matrix, calculates its transpose, then calculates the matrix.sum() and matrix.diff() of the two matrices. This example displays the original matrix, its transpose, and the resulting sum and difference matrices in labels on the chart:\nindicator(\"Matrix sum and diff example\")\nm = matrix.new<float>()\nm.add_row(0, array.from(0.5, 1.0, 1.5))\nm.add_row(1, array.from(2.0, 2.5, 3.0))\nm.add_row(2, array.from(3.5, 4.0, 4.5))\n// Display `m`.\nm.debugLabel(note = \"A\")\n// Get and display the transpose of `m`.\nmatrix<float> t = m.transpose()\nt.debugLabel(bar_index + 10, note = \"Aᵀ\")\n// Calculate the sum of the two matrices. The resulting matrix is symmetric.\nmatrix.sum(m, t).debugLabel(bar_index + 20, color.green, note = \"A + Aᵀ\")\n// Calculate the difference between the two matrices. The resulting matrix is antisymmetric.\nmatrix.diff(m, t).debugLabel(bar_index + 30, color.red, note = \"A - Aᵀ\")\nIn this example, we’ve labeled the original matrix as “A” and the transpose as “AT”.\nAdding “A” and “AT” produces a symmetric matrix, and subtracting them produces an antisymmetric matrix.\n`matrix.mult()`¶\nScripts can multiply two matrices via the matrix.mult() function. This function also facilitates the multiplication of a matrix by an array or a scalar value.\nIn the case of multiplying two matrices, unlike addition and subtraction, matrix multiplication does not require two matrices to share the same shape. However, the number of columns in the first matrix must equal the number of rows in the second one. The resulting matrix returned by matrix.mult() will contain the same number of rows as id1 and the same number of columns as id2. For instance, a 2x3 matrix multiplied by a 3x4 matrix will produce a matrix with two rows and four columns, as shown below. Each value within the resulting matrix is the dot product of the corresponding row in id1 and column in id2:\nindicator(\"Matrix mult example\")\n//@variable A 2x3 matrix.\na = matrix.new<float>()\n//@variable A 3x4 matrix.\nb = matrix.new<float>()\n// Add rows to `a`.\na.add_row(0, array.from(1, 2, 3))\na.add_row(1, array.from(4, 5, 6))\n// Add rows to `b`.\nb.add_row(0, array.from(0.5, 1.0, 1.5, 2.0))\nb.add_row(1, array.from(2.5, 3.0, 3.5, 4.0))\nb.add_row(0, array.from(4.5, 5.0, 5.5, 6.0))\n//@variable The result of `a` * `b`.\nmatrix<float> ab = a.mult(b)\n// Display `a`, `b`, and `ab` matrices.\ndebugLabel(a, note = \"A\")\ndebugLabel(b, bar_index + 10, note = \"B\")\ndebugLabel(ab, bar_index + 20, color.green, note = \"A * B\")\nIn contrast to the multiplication of scalars, matrix multiplication is non-commutative, i.e., matrix.mult(a, b) does not necessarily produce the same result as matrix.mult(b, a). In the context of our example, the latter will raise a runtime error because the number of columns in b doesn’t equal the number of rows in a.\nWhen multiplying a matrix and an array, this function treats the operation the same as multiplying id1 by a single-column matrix, but it returns an array with the same number of elements as the number of rows in id1. When matrix.mult() passes a scalar as its id2 value, the function returns a new matrix whose elements are the elements in id1 multiplied by the id2 value.\n`matrix.det()`¶\nA determinant is a scalar value associated with a square matrix that describes some of its characteristics, namely its invertibility. If a matrix has an inverse, its determinant is nonzero. Otherwise, the matrix is singular (non-invertible). Scripts can calculate the determinant of a matrix via matrix.det().\nProgrammers can use determinants to detect similarities between matrices, identify full-rank and rank-deficient matrices, and solve systems of linear equations, among other applications.\nFor example, this script utilizes determinants to solve a system of linear equations with a matching number of unknown values using Cramer’s rule. The user-defined solve() function returns an array containing solutions for each unknown value in the system, where the n-th element of the array is the determinant of the coefficient matrix with the n-th column replaced by the column of constants divided by the determinant of the original coefficients.\nIn this script, we’ve defined the matrix m that holds coefficients and constants for these three equations:\n3 * x0 + 4 * x1 - 1 * x2 = 8\n5 * x0 - 2 * x1 + 1 * x2 = 4\n2 * x0 - 2 * x1 + 1 * x2 = 1\nThe solution to this system is (x0 = 1, x1 = 2, x2 = 3). The script calculates these values from m via m.solve() and plots them on the chart:\nindicator(\"Determinants example\", \"Cramer's Rule\")\n//@function Solves a system of linear equations with a matching number of unknowns using Cramer's rule.\n//@param this An augmented matrix containing the coefficients for each unknown and the results of\n// the equations. For example, a row containing the values 2, -1, and 3 represents the equation\n// `2 * x0 + (-1) * x1 = 3`, where `x0` and `x1` are the unknown values in the system.\n//@returns An array containing solutions for each variable in the system.\nsolve(matrix<float> this) =>\n//@variable The coefficient matrix for the system of equations.\nmatrix<float> coefficients = this.submatrix(from_column = 0, to_column = this.columns() - 1)\n//@variable The array of resulting constants for each equation.\narray<float> constants = this.col(this.columns() - 1)\n//@variable An array containing solutions for each unknown in the system.\narray<float> result = array.new<float>()\n//@variable The determinant value of the coefficient matrix.\nfloat baseDet = coefficients.det()\nmatrix<float> modified = na\nfor col = 0 to coefficients.columns() - 1\nmodified := coefficients.copy()\nmodified.add_col(col, constants)\nmodified.remove_col(col + 1)\n// Calculate the solution for the column's unknown by dividing the determinant of `modified` by the `baseDet`.\nresult.push(modified.det() / baseDet)\nresult\n//@variable A 3x4 matrix containing coefficients and results for a system of three equations.\nm = matrix.new<float>()\n// Add rows for the following equations:\n// Equation 1: 3 * x0 + 4 * x1 - 1 * x2 = 8\n// Equation 2: 5 * x0 - 2 * x1 + 1 * x2 = 4\n// Equation 3: 2 * x0 - 2 * x1 + 1 * x2 = 1\nm.add_row(0, array.from(3.0, 4.0, -1.0, 8.0))\nm.add_row(1, array.from(5.0, -2.0, 1.0, 4.0))\nm.add_row(2, array.from(2.0, -2.0, 1.0, 1.0))\n//@variable An array of solutions to the unknowns in the system of equations represented by `m`.\nsolutions = solve(m)\nplot(solutions.get(0), \"x0\", color.red, 3) // Plots 1.\nplot(solutions.get(1), \"x1\", color.green, 3) // Plots 2.\nplot(solutions.get(2), \"x2\", color.blue, 3) // Plots 3.\nSolving systems of equations is particularly useful for regression analysis, e.g., linear and polynomial regression.\nCramer’s rule works fine for small systems of equations. However, it’s computationally inefficient on larger systems. Other methods, such as Gaussian elimination, are often preferred for such use cases.\n`matrix.inv()` and `matrix.pinv()`¶\nFor any non-singular square matrix, there is an inverse matrix that yields the identity matrix when multiplied by the original. Inverses have utility in various matrix transformations and solving systems of equations. Scripts can calculate the inverse of a matrix when one exists via the matrix.inv() function.\nFor singular (non-invertible) matrices, one can calculate a generalized inverse (pseudoinverse), regardless of whether the matrix is square or has a nonzero determinant, via the matrix.pinv() function. Keep in mind that unlike a true inverse, the product of a pseudoinverse and the original matrix does not necessarily equal the identity matrix unless the original matrix is invertible.\nThe following example forms a 2x2 m matrix from user inputs, then uses the m.inv() and m.pinv() methods to calculate the inverse or pseudoinverse of m. The script displays the original matrix, its inverse or pseudoinverse, and their product in labels on the chart:\nindicator(\"Inverse example\")\n// Element inputs for the 2x2 matrix.\nfloat r0c0 = input.float(4.0, \"Row 0, Col 0\")\nfloat r0c1 = input.float(3.0, \"Row 0, Col 1\")\nfloat r1c0 = input.float(2.0, \"Row 1, Col 0\")\nfloat r1c1 = input.float(1.0, \"Row 1, Col 1\")\n//@variable A 2x2 matrix of input values.\nm = matrix.new<float>()\n// Add input values to `m`.\nm.add_row(0, array.from(r0c0, r0c1))\nm.add_row(1, array.from(r1c0, r1c1))\n//@variable Is `true` if `m` is square with a nonzero determinant, indicating invertibility.\nbool isInvertible = m.is_square() and m.det()\n//@variable The inverse or pseudoinverse of `m`.\nmInverse = isInvertible ? m.inv() : m.pinv()\n//@variable The product of `m` and `mInverse`. Returns the identity matrix when `isInvertible` is `true`.\nmatrix<float> product = m.mult(mInverse)\n// Display `m`, `mInverse`, and their `product`.\nmInverse.debugLabel(bar_index + 10, color.purple, note = isInvertible ? \"Inverse\" : \"Pseudoinverse\")\nproduct.debugLabel(bar_index + 20, color.green, note = \"Product\")\nThis script will only call m.inv() when isInvertible is true, i.e., when m is square and has a nonzero determinant. Otherwise, it uses m.pinv() to calculate the generalized inverse.\n`matrix.rank()`¶\nThe rank of a matrix represents the number of linearly independent vectors (rows or columns) it contains. In essence, matrix rank measures the number of vectors one cannot express as a linear combination of others, or in other words, the number of vectors that contain unique information. Scripts can calculate the rank of a matrix via matrix.rank().\nThis script identifies the number of linearly independent vectors in two 3x3 matrices (m1 and m2) and plots the values in a separate pane. As we see on the chart, the m1.rank() value is 3 because each vector is unique. The m2.rank() value, on the other hand, is 1 because it has just one unique vector:\nindicator(\"Matrix rank example\")\n//@variable A 3x3 full-rank matrix.\nm1 = matrix.new<float>()\n//@variable A 3x3 rank-deficient matrix.\nm2 = matrix.new<float>()\n// Add linearly independent vectors to `m1`.\nm1.add_row(0, array.from(3, 2, 3))\nm1.add_row(1, array.from(4, 6, 6))\nm1.add_row(2, array.from(7, 4, 9))\n// Add linearly dependent vectors to `m2`.\nm2.add_row(0, array.from(1, 2, 3))\nm2.add_row(1, array.from(2, 4, 6))\nm2.add_row(2, array.from(3, 6, 9))\n// Plot `matrix.rank()` values.\nplot(m1.rank(), color = color.green, linewidth = 3)\nplot(m2.rank(), color = color.red, linewidth = 3)\nThe highest rank value a matrix can have is the minimum of its number of rows and columns. A matrix with the maximum possible rank is known as a full-rank matrix, and any matrix without full rank is known as a rank-deficient matrix.\nThe determinants of full-rank square matrices are nonzero, and such matrices have inverses. Conversely, the determinant of a rank-deficient matrix is always 0.\nFor any matrix that contains nothing but the same value in each of its elements (e.g., a matrix filled with 0), the rank is always 0 since none of the vectors hold unique information. For any other matrix with distinct values, the minimum possible rank is 1.\nError handling¶\nIn addition to usual compiler errors, which occur during a script’s compilation due to improper syntax, scripts using matrices can raise specific runtime errors during their execution. When a script raises a runtime error, it displays a red exclamation point next to the script title. Users can view the error message by clicking this icon.\nIn this section, we discuss runtime errors that users may encounter while utilizing matrices in their scripts.\nThe row/column index (xx) is out of bounds, row/column size is (yy).¶\nThis runtime error occurs when trying to access indices outside the matrix dimensions with functions including matrix.get(), matrix.set(), matrix.fill(), and matrix.submatrix(), as well as some of the functions relating to the rows and columns of a matrix.\nFor example, this code contains two lines that will produce this runtime error. The m.set() method references a row index that doesn’t exist (2). The m.submatrix() method references all column indices up to to_column - 1. A to_column value of 4 results in a runtime error because the last column index referenced (3) does not exist in m:\nindicator(\"Out of bounds demo\")\n//@variable A 2x3 matrix with a max row index of 1 and max column index of 2.\nmatrix<float> m = matrix.new<float>(2, 3, 0.0)\nm.set(row = 2, column = 0, value = 1.0) // The `row` index is out of bounds on this line. The max value is 1.\nm.submatrix(from_column = 1, to_column = 4) // The `to_column` index is invalid on this line. The max value is 3.\nlabel.new(bar_index, 0, str.tostring(m), color = color.navy, textcolor = color.white, size = size.huge)\nUsers can avoid this error in their scripts by ensuring their function calls do not reference indices greater than or equal to the number of rows/columns.\nThe array size does not match the number of rows/columns in the matrix.¶\nWhen using matrix.add_row() and matrix.add_col() functions to insert rows and columns into a non-empty matrix, the size of the inserted array must align with the matrix dimensions. The size of an inserted row must match the number of columns, and the size of an inserted column must match the number of rows. Otherwise, the script will raise this runtime error. For example:\nindicator(\"Invalid array size demo\")\n// Declare an empty matrix.\nm = matrix.new<float>()\nm.add_col(0, array.from(1, 2)) // Add a column. Changes the shape of `m` to 2x1.\nm.add_col(1, array.from(1, 2, 3)) // Raises a runtime error because `m` has 2 rows, not 3.\nplot(m.col(0).get(1))\nWhen m is empty, one can insert a row or column array of any size, as shown in the first m.add_col() line.\nCannot call matrix methods when the ID of matrix is ‘na’.¶\nWhen a matrix variable is assigned to na, it means that the variable doesn’t reference an existing object. Consequently, one cannot use built-in matrix.*() functions and methods with it. For example:\nindicator(\"na matrix methods demo\")\n//@variable A `matrix` variable assigned to `na`.\nmatrix<float> m = na\nmCopy = m.copy() // Raises a runtime error. You can't copy a matrix that doesn't exist.\nlabel.new(bar_index, 0, str.tostring(mCopy), color = color.navy, textcolor = color.white, size = size.huge)\nTo resolve this error, assign m to a valid matrix instance before using matrix.*() functions.\nMatrix is too large. Maximum size of the matrix is 100,000 elements.¶\nThe total number of elements in a matrix (matrix.elements_count()) cannot exceed 100,000, regardless of its shape. For example, this script will raise an error because it inserts 1000 rows with 101 elements into the m matrix:\nindicator(\"Matrix too large demo\")\nvar matrix<float> m = matrix.new<float>()\nfor i = 1 to 1000\n// This raises an error because the script adds 101 elements on each iteration.\n// 1000 rows * 101 elements per row = 101000 total elements. This is too large.\nm.add_row(m.rows(), array.new<float>(101, i))\nplot(m.get(0, 0))\nThe row/column index must be 0 <= from_row/column < to_row/column.¶\nWhen using matrix.*() functions with from_row/column and to_row/column indices, the from_* values must be less than the corresponding to_* values, with the minimum possible value being 0. Otherwise, the script will raise a runtime error.\nFor example, this script shows an attempt to declare a submatrix from a 4x4 m matrix with a from_row value of 2 and a to_row value of 2, which will result in an error:\nindicator(\"Invalid from_row, to_row demo\")\n//@variable A 4x4 matrix filled with a random value.\nmatrix<float> m = matrix.new<float>(4, 4, math.random())\nmatrix<float> mSub = m.submatrix(from_row = 2, to_row = 2) // Raises an error. `from_row` can't equal `to_row`.\nplot(mSub.get(0, 0))\nMatrices ‘id1’ and ‘id2’ must have an equal number of rows and columns to be added.¶\nWhen using matrix.sum() and matrix.diff() functions, the id1 and id2 matrices must have the same number of rows and the same number of columns. Attempting to add or subtract two matrices with mismatched dimensions will raise an error, as demonstrated by this code:\nindicator(\"Invalid sum dimensions demo\")\n//@variable A 2x3 matrix.\nmatrix<float> m1 = matrix.new<float>(2, 3, 1)\n//@variable A 3x4 matrix.\nmatrix<float> m2 = matrix.new<float>(3, 4, 2)\nmSum = matrix.sum(m1, m2) // Raises an error. `m1` and `m2` don't have matching dimensions.\nplot(mSum.get(0, 0))\nThe number of columns in the ‘id1’ matrix must equal the number of rows in the matrix (or the number of elements in the array) ‘id2’.¶\nWhen using matrix.mult() to multiply an id1 matrix by an id2 matrix or array, the matrix.rows() or array.size() of id2 must equal the matrix.columns() in id1. If they don’t align, the script will raise this error.\nFor example, this script tries to multiply two 2x3 matrices. While adding these matrices is possible, multiplying them is not:\nindicator(\"Invalid mult dimensions demo\")\n//@variable A 2x3 matrix.\nmatrix<float> m1 = matrix.new<float>(2, 3, 1)\n//@variable A 2x3 matrix.\nmatrix<float> m2 = matrix.new<float>(2, 3, 2)\nmSum = matrix.mult(m1, m2) // Raises an error. The number of columns in `m1` and rows in `m2` aren't equal.\nplot(mSum.get(0, 0))\nOperation not available for non-square matrices.¶\nSome matrix operations, including matrix.inv(), matrix.det(), matrix.eigenvalues(), and matrix.eigenvectors() only work with square matrices, i.e., matrices with the same number of rows and columns. When attempting to execute such functions on non-square matrices, the script will raise an error stating the operation isn’t available or that it cannot calculate the result for the matrix id. For example:\nindicator(\"Non-square demo\")\n//@variable A 3x5 matrix.\nmatrix<float> m = matrix.new<float>(3, 5, 1)\nplot(m.det()) // Raises a runtime error. You can't calculate the determinant of a 3x5 matrix."
},
{
  "text": "Alerts¶\nBackground\nWhich type of alert is best?\nScript alerts\n`alert()` function events\nUsing all `alert()` calls\nUsing selective `alert()` calls\nIn strategies\nOrder fill events\n`alertcondition()` events\nUsing one condition\nUsing compound conditions\nPlaceholders\nAvoiding repainting with alerts\nTradingView alerts run 24x7 on our servers and do not require users to be logged in to execute. Alerts are created from the charts user interface (UI). You will find all the information necessary to understand how alerts work and how to create them from the charts UI in the Help Center’s About TradingView alerts page.\nSome of the alert types available on TradingView (generic alerts, drawing alerts and script alerts on order fill events) are created from symbols or scripts loaded on the chart and do not require specific coding. Any user can create these types of alerts from the charts UI.\nOther types of alerts (script alerts triggering on alert() function calls, and alertcondition() alerts) require specific Pine Script™ code to be present in a script to create an alert event before script users can create alerts from them using the charts UI. Additionally, while script users can create script alerts triggering on order fill events from the charts UI on any strategy loaded on their chart, Programmers can specify explicit order fill alert messages in their script for each type of order filled by the broker emulator.\nThis page covers the different ways Pine Script™ programmers can code their scripts to create alert events from which script users will in turn be able to create alerts from the charts UI. We will cover:\nHow to use the alert() function to alert() function calls in indicators or strategies, which can then be included in script alerts created from the charts UI.\nHow to add custom alert messages to be included in script alerts triggering on the order fill events of strategies.\nHow to use the alertcondition() function to generate, in indicators only, alertcondition() events which can then be used to create alertcondition() alerts from the charts UI.\nKeep in mind that:\nNo alert-related Pine Script™ code can create a running alert in the charts UI; it merely creates alert events which can then be used by script users to create running alerts from the charts UI.\nAlerts only trigger in the realtime bar. The operational scope of Pine Script™ code dealing with any type of alert is therefore restricted to realtime bars only.\nWhen an alert is created in the charts UI, TradingView saves a mirror image of the script and its inputs, along with the chart’s main symbol and timeframe to run the alert on its servers. Subsequent changes to your script’s inputs or the chart will thus not affect running alerts previously created from them. If you want any changes to your context to be reflected in a running alert’s behavior, you will need to delete the alert and create a new one in the new context.\nBackground¶\nThe different methods Pine programmers can use today to create alert events in their script are the result of successive enhancements deployed throughout Pine Script™’s evolution. The alertcondition() function, which works in indicators only, was the first feature allowing Pine Script™ programmers to create alert events. Then came order fill alerts for strategies, which trigger when the broker emulator creates order fill events. Order fill events require no special code for script users to create alerts on them, but by way of the alert_message parameter for order-generating strategy.*() functions, programmers can customize the message of alerts triggering on order fill events by defining a distinct alert message for any number of order fulfillment events.\nThe alert() function is the most recent addition to Pine Script™. It more or less supersedes alertcondition(), and when used in strategies, provides a useful complement to alerts on order fill events.\nWhich type of alert is best?¶\nFor Pine Script™ programmers, the alert() function will generally be easier and more flexible to work with. Contrary to alertcondition(), it allows for dynamic alert messages, works in both indicators and strategies and the programmer decides on the frequency of alert() events.\nWhile alert() calls can be generated on any logic programmable in Pine, including when orders are sent to the broker emulator in strategies, they cannot be coded to trigger when orders are executed (or filled) because after orders are sent to the broker emulator, the emulator controls their execution and does not report fill events back to the script directly.\nWhen a script user wants to generate an alert on a strategy’s order fill events, he must include those events when creating a script alert on the strategy in the “Create Alert” dialog box. No special code is required in scripts for users to be able to do this. The message sent with order fill events can, however, be customized by programmers through use of the alert_message parameter in order-generating strategy.*() function calls. A combination of alert() calls and the use of custom alert_message arguments in order-generating strategy.*() calls should allow programmers to generate alert events on most conditions occurring in their script’s execution.\nThe alertcondition() function remains in Pine Script™ for backward compatibility, but it can also be used advantageously to generate distinct alerts available for selection as individual items in the “Create Alert” dialog box’s “Condition” field.\nScript alerts¶\nWhen a script user creates a script alert using the “Create Alert” dialog box, the events able to trigger the alert will vary depending on whether the alert is created from an indicator or a strategy.\nA script alert created from an indicator will trigger when:\nThe indicator contains alert() calls.\nThe code’s logic allows a specific alert() call to execute.\nThe frequency specified in the alert() call allows the alert to trigger.\nA script alert created from a strategy can trigger on alert() function calls, on order fill events, or both. The script user creating an alert on a strategy decides which type of events he wishes to include in his script alert. While users can create a script alert on order fill events without the need for a strategy to include special code, it must contain alert() calls for users to include alert() function calls in their script alert.\n`alert()` function events¶\nThe alert() function has the following signature:\nmessage A “series string” representing the message text sent when the alert triggers. Because this argument allows “series” values, it can be generated at runtime and differ bar to bar, making it dynamic. freq \nAn “input string” specifying the triggering frequency of the alert. Valid arguments are:\nalert.freq_once_per_bar: Only the first call per realtime bar triggers the alert (default value).\nalert.freq_once_per_bar_close: An alert is only triggered when the realtime bar closes and an alert() call is executed during that script iteration.\nalert.freq_all: All calls during the realtime bar trigger the alert.\nThe alert() function can be used in both indicators and strategies. For an alert() call to trigger a script alert configured on alert() function calls, the script’s logic must allow the alert() call to execute, and the frequency determined by the freq parameter must allow the alert to trigger.\nNote that by default, strategies are recalculated at the bar’s close, so if the alert() function with the frequency alert.freq_all or alert.freq_once_per_bar is used in a strategy, then it will be called no more often than once at the bar’s close. In order to enable the alert() function to be called during the bar construction process, you need to enable the calc_on_every_tick option.\nUsing all `alert()` calls¶\nLet’s look at an example where we detect crosses of the RSI centerline:\nindicator(\"All `alert()` calls\")\nr = ta.rsi(close, 20)\n// Detect crosses.\nxUp = ta.crossover( r, 50)\nxDn = ta.crossunder(r, 50)\n// Trigger an alert on crosses.\nif xUp\nalert(\"Go long (RSI is \" + str.tostring(r, \"#.00)\"))\nelse if xDn\nalert(\"Go short (RSI is \" + str.tostring(r, \"#.00)\"))\nplotchar(xUp, \"Go Long\", \"▲\", location.bottom, color.lime, size = size.tiny)\nplotchar(xDn, \"Go Short\", \"▼\", location.top, color.red, size = size.tiny)\nhline(50)\nplot(r)\nIf a script alert is created from this script:\nWhen RSI crosses the centerline up, the script alert will trigger with the “Go long…” message. When RSI crosses the centerline down, the script alert will trigger with the “Go short…” message.\nBecause no argument is specified for the freq parameter in the alert() call, the default value of alert.freq_once_per_bar will be used, so the alert will only trigger the first time each of the alert() calls is executed during the realtime bar.\nThe message sent with the alert is composed of two parts: a constant string and then the result of the str.tostring() call which will include the value of RSI at the moment where the alert() call is executed by the script. An alert message for a cross up would look like: “Go long (RSI is 53.41)”.\nBecause a script alert always triggers on any occurrence of a call to alert(), as long as the frequency used in the call allows for it, this particular script does not allow a script user to restrict his script alert to longs only, for example.\nContrary to an alertcondition() call which is always placed at column 0 (in the script’s global scope), the alert() call is placed in the local scope of an if branch so it only executes when our triggering condition is met. If an alert() call was placed in the script’s global scope at column 0, it would execute on all bars, which would likely not be the desired behavior.\nAn alertcondition() could not accept the same string we use for our alert’s message because of its use of the str.tostring() call. alertcondition() messages must be constant strings.\nLastly, because alert() messages can be constructed dynamically at runtime, we could have used the following code to generate our alert events:\n// Trigger an alert on crosses.\nif xUp or xDn\nfirstPart = (xUp ? \"Go long\" : \"Go short\") + \" (RSI is \"\nalert(firstPart + str.tostring(r, \"#.00)\"))\nUsing selective `alert()` calls¶\nWhen users create a script alert on alert() function calls, the alert will trigger on any call the script makes to the alert() function, provided its frequency constraints are met. If you want to allow your script’s users to select which alert() function call in your script will trigger a script alert, you will need to provide them with the means to indicate their preference in your script’s inputs, and code the appropriate logic in your script. This way, script users will be able to create multiple script alerts from a single script, each behaving differently as per the choices made in the script’s inputs prior to creating the alert in the charts UI.\nSuppose, for our next example, that we want to provide the option of triggering alerts on only longs, only shorts, or both. You could code your script like this:\nindicator(\"Selective `alert()` calls\")\ndetectLongsInput = input.bool(true, \"Detect Longs\")\ndetectShortsInput = input.bool(true, \"Detect Shorts\")\nrepaintInput = input.bool(false, \"Allow Repainting\")\n// Detect crosses.\nxUp = ta.crossover( r, 50)\nxDn = ta.crossunder(r, 50)\n// Only generate entries when the trade's direction is allowed in inputs.\nenterLong = detectLongsInput and xUp and (repaintInput or barstate.isconfirmed)\nenterShort = detectShortsInput and xDn and (repaintInput or barstate.isconfirmed)\n// Trigger the alerts only when the compound condition is met.\nif enterLong\nalert(\"Go long (RSI is \" + str.tostring(r, \"#.00)\"))\nelse if enterShort\nalert(\"Go short (RSI is \" + str.tostring(r, \"#.00)\"))\nplotchar(enterLong, \"Go Long\", \"▲\", location.bottom, color.lime, size = size.tiny)\nplotchar(enterShort, \"Go Short\", \"▼\", location.top, color.red, size = size.tiny)\nhline(50)\nplot(r)\nNote how:\nWe create a compound condition that is met only when the user’s selection allows for an entry in that direction. A long entry on a crossover of the centerline only triggers the alert when long entries have been enabled in the script’s Inputs.\nWe offer the user to indicate his repainting preference. When he does not allow the calculations to repaint, we wait until the bar’s confirmation to trigger the compound condition. This way, the alert and the marker only appear at the end of the realtime bar.\nIf a user of this script wanted to create two distinct script alerts from this script, i.e., one triggering only on longs, and one only on shorts, then he would need to:\nSelect only “Detect Longs” in the inputs and create a first script alert on the script.\nSelect only “Detect Shorts” in the Inputs and create another script alert on the script.\nIn strategies¶\nalert() function calls can be used in strategies also, with the provision that strategies, by default, only execute on the close of realtime bars. Unless calc_on_every_tick = true is used in the strategy() declaration statement, all alert() calls will use the alert.freq_once_per_bar_close frequency, regardless of the argument used for freq.\nWhile script alerts on strategies will use order fill events to trigger alerts when the broker emulator fills orders, alert() can be used advantageously to generate other alert events in strategies.\nThis strategy creates alert() function calls when RSI moves against the trade for three consecutive bars:\nstrategy(\"Strategy with selective `alert()` calls\")\n// Detect crosses.\nxUp = ta.crossover( r, 50)\nxDn = ta.crossunder(r, 50)\n// Place orders on crosses.\nif xUp\nstrategy.entry(\"Long\", strategy.long)\nelse if xDn\nstrategy.entry(\"Short\", strategy.short)\n// Trigger an alert when RSI diverges from our trade's direction.\ndivInLongTrade = strategy.position_size > 0 and ta.falling(r, 3)\ndivInShortTrade = strategy.position_size < 0 and ta.rising( r, 3)\nif divInLongTrade\nalert(\"WARNING: Falling RSI\", alert.freq_once_per_bar_close)\nif divInShortTrade\nalert(\"WARNING: Rising RSI\", alert.freq_once_per_bar_close)\nplotchar(xUp, \"Go Long\", \"▲\", location.bottom, color.lime, size = size.tiny)\nplotchar(xDn, \"Go Short\", \"▼\", location.top, color.red, size = size.tiny)\nplotchar(divInLongTrade, \"WARNING: Falling RSI\", \"•\", location.top, color.red, size = size.tiny)\nplotchar(divInShortTrade, \"WARNING: Rising RSI\", \"•\", location.bottom, color.lime, size = size.tiny)\nplot(r)\nIf a user created a script alert from this strategy and included both order fill events and alert() function calls in his alert, the alert would trigger whenever an order is executed, or when one of the alert() calls was executed by the script on the realtime bar’s closing iteration, i.e., when barstate.isrealtime and barstate.isconfirmed are both true. The alert() function events in the script would only trigger the alert when the realtime bar closes because alert.freq_once_per_bar_close is the argument used for the freq parameter in the alert() calls.\nOrder fill events¶\nWhen a script alert is created from an indicator, it can only trigger on alert() function calls. However, when a script alert is created from a strategy, the user can specify that order fill events also trigger the script alert. An order fill event is any event generated by the broker emulator which causes a simulated order to be executed. It is the equivalent of a trade order being filled by a broker/exchange. Orders are not necessarily executed when they are placed. In a strategy, the execution of orders can only be detected indirectly and after the fact, by analyzing changes in built-in variables such as strategy.opentrades or strategy.position_size. Script alerts configured on order fill events are thus useful in that they allow the triggering of alerts at the precise moment of an order’s execution, before a script’s logic can detect it.\nPine Script™ programmers can customize the alert message sent when specific orders are executed. While this is not a pre-requisite for order fill events to trigger, custom alert messages can be useful because they allow custom syntax to be included with alerts in order to route actual orders to a third-party execution engine, for example. Specifying custom alert messages for specific order fill events is done by means of the alert_message parameter in functions which can generate orders: strategy.close(), strategy.entry(), strategy.exit() and strategy.order().\nThe argument used for the alert_message parameter is a “series string”, so it can be constructed dynamically using any variable available to the script, as long as it is converted to string format.\nLet’s look at a strategy where we use the alert_message parameter in both our strategy.entry() calls:\nstrategy(\"Strategy using `alert_message`\")\n// Detect crosses.\nxUp = ta.crossover( r, 50)\nxDn = ta.crossunder(r, 50)\n// Place order on crosses using a custom alert message for each.\nif xUp\nstrategy.entry(\"Long\", strategy.long, stop = high, alert_message = \"Stop-buy executed (stop was \" + str.tostring(high) + \")\")\nelse if xDn\nstrategy.entry(\"Short\", strategy.short, stop = low, alert_message = \"Stop-sell executed (stop was \" + str.tostring(low) + \")\")\nplotchar(xUp, \"Go Long\", \"▲\", location.bottom, color.lime, size = size.tiny)\nplotchar(xDn, \"Go Short\", \"▼\", location.top, color.red, size = size.tiny)\nWe use the stop parameter in our strategy.entry() calls, which creates stop-buy and stop-sell orders. This entails that buy orders will only execute once price is higher than the high on the bar where the order is placed, and sell orders will only execute once price is lower than the low on the bar where the order is placed.\nThe up/down arrows which we plot with plotchar() are plotted when orders are placed. Any number of bars may elapse before the order is actually executed, and in some cases the order will never be executed because price does not meet the required condition.\nBecause we use the same id argument for all buy orders, any new buy order placed before a previous order’s condition is met will replace that order. The same applies to sell orders.\nVariables included in the alert_message argument are evaluated when the order is executed, so when the alert triggers.\nWhen the alert_message parameter is used in a strategy’s order-generating strategy.*() function calls, script users must include the {{strategy.order.alert_message}} placeholder in the “Create Alert” dialog box’s “Message” field when creating script alerts on order fill events. This is required so the alert_message argument used in the order-generating strategy.*() function calls is used in the message of alerts triggering on each order fill event. When only using the {{strategy.order.alert_message}} placeholder in the “Message” field and the alert_message parameter is present in only some of the order-generating strategy.*() function calls in your strategy, an empty string will replace the placeholder in the message of alerts triggered by any order-generating strategy.*() function call not using the alert_message parameter.\nWhile other placeholders can be used in the “Create Alert” dialog box’s “Message” field by users creating alerts on order fill events, they cannot be used in the argument of alert_message.\n`alertcondition()` events¶\nThe alertcondition() function allows programmers to create individual alertcondition events in their indicators. One indicator may contain more than one alertcondition() call. Each call to alertcondition() in a script will create a corresponding alert selectable in the “Condition” dropdown menu of the “Create Alert” dialog box.\nWhile the presence of alertcondition() calls in a strategy script will not cause a compilation error, alerts cannot be created from them.\nThe alertcondition() function has the following signature:\nalertcondition(condition, title, message)\ncondition A “series bool” value (true or false) which determines when the alert will trigger. It is a required argument. When the value is true the alert will trigger. When the value is false the alert will not trigger. Contrary to alert() function calls, alertcondition() calls must start at column zero of a line, so cannot be placed in conditional blocks. title A “const string” optional argument that sets the name of the alert condition as it will appear in the “Create Alert” dialog box’s “Condition” field in the charts UI. If no argument is supplied, “Alert” will be used. message A “const string” optional argument that specifies the text message to display when the alert triggers. The text will appear in the “Message” field of the “Create Alert” dialog box, from where script users can then modify it when creating an alert. As this argument must be a “const string”, it must be known at compilation time and thus cannot vary bar to bar. It can, however, contain placeholders which will be replaced at runtime by dynamic values that may change bar to bar. See this page’s Placeholders section for a list. \nThe alertcondition() function does not include a freq parameter. The frequency of alertcondition() alerts is determined by users in the “Create Alert” dialog box.\nUsing one condition¶\nHere is an example of code creating alertcondition() events:\nindicator(\"`alertcondition()` on single condition\")\nplot(r, \"RSI\")\nplotchar(xUp, \"Long\", \"▲\", location.bottom, color.lime, size = size.tiny)\nplotchar(xDn, \"Short\", \"▼\", location.top, color.red, size = size.tiny)\nalertcondition(xUp, \"Long Alert\", \"Go long\")\nalertcondition(xDn, \"Short Alert\", \"Go short \")\nBecause we have two alertcondition() calls in our script, two different alerts will be available in the “Create Alert” dialog box’s “Condition” field: “Long Alert” and “Short Alert”.\nIf we wanted to include the value of RSI when the cross occurs, we could not simply add its value to the message string using str.tostring(r), as we could in an alert() call or in an alert_message argument in a strategy. We can, however, include it using a placeholder. This shows two alternatives:\nalertcondition(xUp, \"Long Alert\", \"Go long. RSI is {{plot_0}}\")\nalertcondition(xDn, \"Short Alert\", 'Go short. RSI is {{plot(\"RSI\")}}')\nThe first line uses the {{plot_0}} placeholder, where the plot number corresponds to the order of the plot in the script.\nThe second line uses the {{plot(\"[plot_title]\")}} type of placeholder, which must include the title of the plot() call used in our script to plot RSI. Double quotes are used to wrap the plot’s title inside the {{plot(\"RSI\")}} placeholder. This requires that we use single quotes to wrap the message string.\nUsing one of these methods, we can include any numeric value that is plotted by our indicator, but as strings cannot be plotted, no string variable can be used.\nUsing compound conditions¶\nIf we want to offer script users the possiblity of creating a single alert from an indicator using multiple alertcondition() calls, we will need to provide options in the script’s inputs through which users will indicate the conditions they want to trigger their alert before creating it.\nThis script demonstrates one way to do it:\nindicator(\"`alertcondition()` on multiple conditions\")\ndetectLongsInput = input.bool(true, \"Detect Longs\")\ndetectShortsInput = input.bool(true, \"Detect Shorts\")\n// Only generate entries when the trade's direction is allowed in inputs.\nenterLong = detectLongsInput and xUp\nenterShort = detectShortsInput and xDn\nplotchar(enterLong, \"Go Long\", \"▲\", location.bottom, color.lime, size = size.tiny)\nplotchar(enterShort, \"Go Short\", \"▼\", location.top, color.red, size = size.tiny)\n// Trigger the alert when one of the conditions is met.\nalertcondition(enterLong or enterShort, \"Compound alert\", \"Entry\")\nNote how the alertcondition() call is allowed to trigger on one of two conditions. Each condition can only trigger the alert if the user enables it in the script’s inputs before creating the alert.\nPlaceholders¶\nThese placeholders can be used in the message argument of alertcondition() calls. They will be replaced with dynamic values when the alert triggers. They are the only way to include dynamic values (values that can vary bar to bar) in alertcondition() messages.\nNote that users creating alertcondition() alerts from the “Create Alert” dialog box in the charts UI are also able to use these placeholders in the dialog box’s “Message” field.\n{{exchange}} Exchange of the symbol used in the alert (NASDAQ, NYSE, MOEX, etc.). Note that for delayed symbols, the exchange will end with “_DL” or “_DLY.” For example, “NYMEX_DL.” {{interval}} Returns the timeframe of the chart the alert is created on. Note that Range charts are calculated based on 1m data, so the placeholder will always return “1” on any alert created on a Range chart. {{open}}, {{high}}, {{low}}, {{close}}, {{volume}} Corresponding values of the bar on which the alert has been triggered. {{plot_0}}, {{plot_1}}, […], {{plot_19}} Value of the corresponding plot number. Plots are numbered from zero to 19 in order of appearance in the script, so only one of the first 20 plots can be used. For example, the built-in “Volume” indicator has two output series: Volume and Volume MA, so you could use the following: \nalertcondition(volume > ta.sma(volume,20), \"Volume alert\", \"Volume ({{plot_0}}) > average ({{plot_1}})\")\n{{plot(\"[plot_title]\")}} This placeholder can be used when one needs to refer to a plot using the title argument used in a plot() call. Note that double quotation marks (\") must be used inside the placeholder to wrap the title argument. This requires that a single quotation mark (') be used to wrap the message string: \nr = ta.rsi(close, 14)\nxUp = ta.crossover(r, 50)\nplot(r, \"RSI\", display = display.none)\nalertcondition(xUp, \"xUp alert\", message = 'RSI is bullish at: {{plot(\"RSI\")}}')\n{{ticker}} Ticker of the symbol used in the alert (AAPL, BTCUSD, etc.). {{time}} Returns the time at the beginning of the bar. Time is UTC, formatted as yyyy-MM-ddTHH:mm:ssZ, so for example: 2019-08-27T09:56:00Z. {{timenow}} Current time when the alert triggers, formatted in the same way as {{time}}. The precision is to the nearest second, regardless of the chart’s timeframe. \nAvoiding repainting with alerts¶\nThe most common instances of repainting traders want to avoid with alerts are ones where they must prevent an alert from triggering at some point during the realtime bar when it would not have triggered at its close. This can happen when these conditions are met:\nThe calculations used in the condition triggering the alert can vary during the realtime bar. This will be the case with any calculation using high, low or close, for example, which includes almost all built-in indicators. It will also be the case with the result of any request.security() call using a higher timeframe than the chart’s, when the higher timeframe’s current bar has not closed yet.\nThe alert can trigger before the close of the realtime bar, so with any frequency other than “Once Per Bar Close”.\nThe simplest way to avoid this type of repainting is to configure the triggering frequency of alerts so they only trigger on the close of the realtime bar. There is no panacea; avoiding this type of repainting always entails waiting for confirmed information, which means the trader must sacrifice immediacy to achieve reliability.\nNote that other types of repainting such as those documented in our Repainting section may not be preventable by simply triggering alerts on the close of realtime bars."
},
{
  "text": "Backgrounds¶\nThe bgcolor() function changes the color of the script’s background. If the script is running in overlay = true mode, then it will color the chart’s background.\nThe function’s signature is:\nbgcolor(color, offset, editable, show_last, title) → void\nIts color parameter allows a “series color” to be used for its argument, so it can be dynamically calculated in an expression.\nIf the correct transparency is not part of the color to be used, it can be be generated using the color.new() function.\nHere is a script that colors the background of trading sessions (try it on 30min EURUSD, for example):\nindicator(\"Session backgrounds\", overlay = true)\n// Default color constants using tranparency of 25.\nBLUE_COLOR = #0050FF40\nPURPLE_COLOR = #0000FF40\nPINK_COLOR = #5000FF40\nNO_COLOR = color(na)\n// Allow user to change the colors.\npreMarketColor = input.color(BLUE_COLOR, \"Pre-market\")\nregSessionColor = input.color(PURPLE_COLOR, \"Pre-market\")\npostMarketColor = input.color(PINK_COLOR, \"Pre-market\")\n// Function returns `true` when the bar's time is\ntimeInRange(tf, session) =>\ntime(tf, session) != 0\n// Function prints a message at the bottom-right of the chart.\nf_print(_text) =>\nvar table _t = table.new(position.bottom_right, 1, 1)\ntable.cell(_t, 0, 0, _text, bgcolor = color.yellow)\nvar chartIs30MinOrLess = timeframe.isseconds or (timeframe.isintraday and timeframe.multiplier <=30)\nsessionColor = if chartIs30MinOrLess\ntimeInRange(timeframe.period, \"0400-0930\") => preMarketColor\ntimeInRange(timeframe.period, \"0930-1600\") => regSessionColor\ntimeInRange(timeframe.period, \"1600-2000\") => postMarketColor\n=> NO_COLOR\nf_print(\"No background is displayed.\\nChart timeframe must be <= 30min.\")\nNO_COLOR\nbgcolor(sessionColor)\nThe script only works on chart timeframes of 30min or less. It prints an error message when the chart’s timeframe is higher than 30min.\nWhen the if structure’s else branch is used because the chart’s timeframe is incorrect, the local block returns the NO_COLOR color so that no background is displayed in that case.\nWe first initialize constants using our base colors, which include the 40 transparency in hex notation at the end. 40 in the hexadecimal notation on the reversed 00-FF scale for transparency corresponds to 75 in Pine Script™’s 0-100 decimal scale for transparency.\nWe provide color inputs allowing script users to change the default colors we propose.\nIn our next example, we generate a gradient for the background of a CCI line:\nindicator(\"CCI Background\")\nbullColor = input.color(color.lime, \"🠅\", inline = \"1\")\nbearColor = input.color(color.fuchsia, \"🠇\", inline = \"1\")\n// Calculate CCI.\nmyCCI = ta.cci(hlc3, 20)\n// Get relative position of CCI in last 100 bars, on a 0-100% scale.\nmyCCIPosition = ta.percentrank(myCCI, 100)\n// Generate a bull gradient when position is 50-100%, bear gradient when position is 0-50%.\nbackgroundColor = if myCCIPosition >= 50\ncolor.from_gradient(myCCIPosition, 50, 100, color.new(bullColor, 75), bullColor)\ncolor.from_gradient(myCCIPosition, 0, 50, bearColor, color.new(bearColor, 75))\n// Wider white line background.\nplot(myCCI, \"CCI\", color.white, 3)\n// Think black line.\nplot(myCCI, \"CCI\", color.black, 1)\n// Zero level.\nhline(0)\n// Gradient background.\nbgcolor(backgroundColor)\nWe use the ta.cci() built-in function to calculate the indicator value.\nWe use the ta.percentrank() built-in function to calculate myCCIPosition, i.e., the percentage of past myCCI values in the last 100 bars that are below the current value of myCCI.\nTo calculate the gradient, we use two different calls of the color.from_gradient() built-in: one for the bull gradient when myCCIPosition is in the 50-100% range, which means that more past values are below its current value, and another for the bear gradient when myCCIPosition is in the 0-49.99% range, which means that more past values are above it.\nWe provide inputs so the user can change the bull/bear colors, and we place both color input widgets on the same line using inline = \"1\" in both input.color() calls.\nWe plot the CCI signal using two plot() calls to achieve the best contrast over the busy background: the first plot is a 3-pixel wide white background, the second plot() call plots the thin, 1-pixel wide black line.\nSee the Colors page for more examples of backgrounds."
},
{
  "text": "Maps¶\nDeclaring a map\nUsing `var` and `varip` keywords\nReading and writing\nPutting and getting key-value pairs\nInspecting keys and values\n`map.keys()` and `map.values()`\n`map.contains()`\nRemoving key-value pairs\nCombining maps\nLooping through a map\nCopying a map\nShallow copies\nDeep copies\nScope and history\nMaps of other collections\nPine Script™ Maps are collections that store elements in key-value pairs. They allow scripts to collect multiple value references associated with unique identifiers (keys).\nUnlike arrays and matrices, maps are considered unordered collections. Scripts quickly access a map’s values by referencing the keys from the key-value pairs put into them rather than traversing an internal index.\nA map’s keys can be of any fundamental type, and its values can be of any built-in or user-defined type. Maps cannot directly use other collections (maps, arrays, or matrices) as values, but they can hold UDT instances containing these data structures within their fields. See this section for more information.\nAs with other collections, maps can contain up to 100,000 elements in total. Since each key-value pair in a map consists of two elements (a unique key and its associated value), the maximum number of key-value pairs a map can hold is 50,000.\nDeclaring a map¶\nPine Script™ uses the following syntax to declare maps:\n[var/varip ][map<keyType, valueType> ]<identifier> = <expression>\nWhere <keyType, valueType> is the map’s type template that declares the types of keys and values it will contain, and the <expression> returns either a map instance or na.\nWhen declaring a map variable assigned to na, users must include the map keyword followed by a type template to tell the compiler that the variable can accept maps with keyType keys and valueType values.\nFor example, this line of code declares a new myMap variable that can accept map instances holding pairs of string keys and float values:\nmap<string, float> myMap = na\nWhen the <expression> is not na, the compiler does not require explicit type declaration, as it will infer the type information from the assigned map object.\nThis line declares a myMap variable assigned to an empty map with string keys and float values. Any maps assigned to this variable later must have the same key and value types:\nmyMap = map.new<string, float>()\nUsing `var` and `varip` keywords¶\nUsers can include the var or varip keywords to instruct their scripts to declare map variables only on the first chart bar. Variables that use these keywords point to the same map instances on each script iteration until explicitly reassigned.\nFor example, this script declares a colorMap variable assigned to a map that holds pairs of string keys and color values on the first chart bar. The script displays an oscillator on the chart and uses the values it put into the colorMap on the first bar to color the plots on all bars:\nindicator(\"var map demo\")\n//@variable A map associating color values with string keys.\nvar colorMap = map.new<string, color>()\n// Put `<string, color>` pairs into `colorMap` on the first bar.\ncolorMap.put(\"Bull\", color.green)\ncolorMap.put(\"Bear\", color.red)\ncolorMap.put(\"Neutral\", color.gray)\n//@variable The 14-bar RSI of `close`.\nfloat oscillator = ta.rsi(close, 14)\n//@variable The color of the `oscillator`.\ncolor oscColor = switch\noscillator > 50 => colorMap.get(\"Bull\")\noscillator < 50 => colorMap.get(\"Bear\")\n=> colorMap.get(\"Neutral\")\n// Plot the `oscillator` using the `oscColor` from our `colorMap`.\nplot(oscillator, \"Histogram\", oscColor, 2, plot.style_histogram, histbase = 50)\nplot(oscillator, \"Line\", oscColor, 3)\nMap variables declared using varip behave as ones using var on historical data, but they update their key-value pairs for realtime bars (i.e., the bars since the script’s last compilation) on each new price tick. Maps assigned to varip variables can only hold values of int, float, bool, color, or string types or user-defined types that exclusively contain within their fields these types or collections (arrays, matrices, or maps) of these types.\nReading and writing¶\nPutting and getting key-value pairs¶\nThe map.put() function is one that map users will utilize quite often, as it’s the primary method to put a new key-value pair into a map. It associates the key argument with the value argument in the call and adds the pair to the map id.\nIf the key argument in the map.put() call already exists in the map’s keys, the new pair passed into the function will replace the existing one.\nTo retrieve the value from a map id associated with a given key, use map.get(). This function returns the value if the id map contains the key. Otherwise, it returns na.\nThe following example calculates the difference between the bar_index values from when close was last rising and falling over a given length with the help of map.put() and map.get() methods. The script puts a (\"Rising\", bar_index) pair into the data map when the price is rising and puts a (\"Falling\", bar_index) pair into the map when the price is falling. It then puts a pair containing the “Difference” between the “Rising” and “Falling” values into the map and plots its value on the chart:\nindicator(\"Putting and getting demo\")\n//@variable The length of the `ta.rising()` and `ta.falling()` calculation.\nint length = input.int(2, \"Length\")\n//@variable A map associating `string` keys with `int` values.\nvar data = map.new<string, int>()\n// Put a new (\"Rising\", `bar_index`) pair into the `data` map when `close` is rising.\nif ta.rising(close, length)\ndata.put(\"Rising\", bar_index)\n// Put a new (\"Falling\", `bar_index`) pair into the `data` map when `close` is falling.\nif ta.falling(close, length)\ndata.put(\"Falling\", bar_index)\n// Put the \"Difference\" between current \"Rising\" and \"Falling\" values into the `data` map.\ndata.put(\"Difference\", data.get(\"Rising\") - data.get(\"Falling\"))\n//@variable The difference between the last \"Rising\" and \"Falling\" `bar_index`.\nint index = data.get(\"Difference\")\n//@variable Returns `color.green` when `index` is positive, `color.red` when negative, and `color.gray` otherwise.\ncolor indexColor = index > 0 ? color.green : index < 0 ? color.red : color.gray\nplot(index, color = indexColor, style = plot.style_columns)\nThis script replaces the values associated with the “Rising”, “Falling”, and “Difference” keys on successive data.put() calls, as each of these keys is unique and can only appear once in the data map.\nReplacing the pairs in a map does not change the internal insertion order of its keys. We discuss this further in the next section.\nSimilar to working with other collections, when putting a value of a special type (line, linefill, box, polyline, label, table, or chart.point) or a user-defined type into a map, it’s important to note the inserted pair’s value points to that same object without copying it. Modifying the value referenced by a key-value pair will also affect the original object.\nFor example, this script contains a custom ChartData type with o, h, l, and c fields. On the first chart bar, the script declares a myMap variable and adds the pair (\"A\", myData), where myData is a ChartData instance with initial field values of na. It adds the pair (\"B\", myData) to myMap and updates the object from this pair on every bar via the user-defined update() method.\nEach change to the object with the “B” key affects the one referenced by the “A” key, as shown by the candle plot of the “A” object’s fields:\nindicator(\"Putting and getting objects demo\")\n//@type A custom type to hold OHLC data.\ntype ChartData\nfloat o\nfloat h\nfloat l\nfloat c\n//@function Updates the fields of a `ChartData` object.\nmethod update(ChartData this) =>\nthis.o := open\nthis.h := high\nthis.l := low\nthis.c := close\n//@variable A new `ChartData` instance declared on the first bar.\nvar myData = ChartData.new()\n//@variable A map associating `string` keys with `ChartData` instances.\nvar myMap = map.new<string, ChartData>()\n// Put a new pair with the \"A\" key into `myMap` only on the first bar.\nmyMap.put(\"A\", myData)\n// Put a pair with the \"B\" key into `myMap` on every bar.\nmyMap.put(\"B\", myData)\n//@variable The `ChartData` value associated with the \"A\" key in `myMap`.\nChartData oldest = myMap.get(\"A\")\n//@variable The `ChartData` value associated with the \"B\" key in `myMap`.\nChartData newest = myMap.get(\"B\")\n// Update `newest`. Also affects `oldest` and `myData` since they all reference the same `ChartData` object.\nnewest.update()\n// Plot the fields of `oldest` as candles.\nplotcandle(oldest.o, oldest.h, oldest.l, oldest.c)\nThis script would behave differently if it passed a copy of myData into each myMap.put() call. For more information, see this section of our User Manual’s page on objects.\nInspecting keys and values¶\n`map.keys()` and `map.values()`¶\nTo retrieve all keys and values put into a map, use map.keys() and map.values(). These functions copy all key/value references within a map id to a new array object. Modifying the array returned from either of these functions does not affect the id map.\nAlthough maps are unordered collections, Pine Script™ internally maintains the insertion order of a map’s key-value pairs. As a result, the map.keys() and map.values() functions always return arrays with their elements ordered based on the id map’s insertion order.\nThe script below demonstrates this by displaying the key and value arrays from an m map in a label once every 50 bars. As we see on the chart, the order of elements in each array returned by m.keys() and m.values() aligns with the insertion order of the key-value pairs in m:\nindicator(\"Keys and values demo\")\nif bar_index % 50 == 0\n//@variable A map containing pairs of `string` keys and `float` values.\nm = map.new<string, float>()\n// Put pairs into `m`. The map will maintain this insertion order.\nm.put(\"First\", math.round(math.random(0, 100)))\nm.put(\"Second\", m.get(\"First\") + 1)\nm.put(\"Third\", m.get(\"Second\") + 1)\n//@variable An array containing the keys of `m` in their insertion order.\narray<string> keys = m.keys()\n//@variable An array containing the values of `m` in their insertion order.\narray<float> values = m.values()\n//@variable A label displaying the `size` of `m` and the `keys` and `values` arrays.\nlabel debugLabel = label.new(\nbar_index, 0,\nstr.format(\"Pairs: {0}\\nKeys: {1}\\nValues: {2}\", m.size(), keys, values),\ncolor = color.navy, style = label.style_label_center,\ntextcolor = color.white, size = size.huge\nThe value with the “First” key is a random whole number between 0 and 100. The “Second” value is one greater than the “First”, and the “Third” value is one greater than the “Second”.\nIt’s important to note a map’s internal insertion order does not change when replacing its key-value pairs. The locations of the new elements in the keys() and values() arrays will be the same as the old elements in such cases. The only exception is if the script completely removes the key beforehand.\nBelow, we’ve added a line of code to put a new value with the “Second” key into the m map, overwriting the previous value associated with that key. Although the script puts this new pair into the map after the one with the “Third” key, the pair’s key and value are still second in the keys and values arrays since the key was already present in m before the change:\nindicator(\"Keys and values demo\")\nif bar_index % 50 == 0\n//@variable A map containing pairs of `string` keys and `float` values.\nm = map.new<string, float>()\n// Put pairs into `m`. The map will maintain this insertion order.\nm.put(\"First\", math.round(math.random(0, 100)))\nm.put(\"Second\", m.get(\"First\") + 1)\nm.put(\"Third\", m.get(\"Second\") + 1)\n// Overwrite the \"Second\" pair in `m`. This will NOT affect the insertion order.\n// The key and value will still appear second in the `keys` and `values` arrays.\nm.put(\"Second\", -2)\n//@variable An array containing the keys of `m` in their insertion order.\narray<string> keys = m.keys()\n//@variable An array containing the values of `m` in their insertion order.\narray<float> values = m.values()\n//@variable A label displaying the `size` of `m` and the `keys` and `values` arrays.\nlabel debugLabel = label.new(\nbar_index, 0,\nstr.format(\"Pairs: {0}\\nKeys: {1}\\nValues: {2}\", m.size(), keys, values),\ncolor = color.navy, style = label.style_label_center,\ntextcolor = color.white, size = size.huge\nThe elements in a map.values() array point to the same values as the map id. Consequently, when the map’s values are of reference types, including line, linefill, box, polyline, label, table, chart.point, or UDTs, modifying the instances referenced by the map.values() array will also affect those referenced by the map id since the contents of both collections point to identical objects.\n`map.contains()`¶\nTo check if a specific key exists within a map id, use map.contains(). This function is a convenient alternative to calling array.includes() on the array returned from map.keys().\nFor example, this script checks if various keys exist within an m map, then displays the results in a label:\nindicator(\"Inspecting keys demo\")\n//@variable A map containing `string` keys and `string` values.\nm = map.new<string, string>()\n// Put key-value pairs into the map.\nm.put(\"A\", \"B\")\nm.put(\"C\", \"D\")\nm.put(\"E\", \"F\")\n//@variable An array of keys to check for in `m`.\narray<string> testKeys = array.from(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\")\n//@variable An array containing all elements from `testKeys` found in the keys of `m`.\narray<string> mappedKeys = array.new<string>()\nfor key in testKeys\n// Add the `key` to `mappedKeys` if `m` contains it.\nif m.contains(key)\nmappedKeys.push(key)\n//@variable A string representing the `testKeys` array and the elements found within the keys of `m`.\nstring testText = str.format(\"Tested keys: {0}\\nKeys found: {1}\", testKeys, mappedKeys)\n//@variable Displays the `testText` in a label at the `bar_index` before the last.\nlabel debugLabel = label.new(\nbar_index, 0, testText, style = label.style_label_center,\nRemoving key-value pairs¶\nTo remove a specific key-value pair from a map id, use map.remove(). This function removes the key and its associated value from the map while preserving the insertion order of other key-value pairs. It returns the removed value if the map contained the key. Otherwise, it returns na.\nTo remove all key-value pairs from a map id at once, use map.clear().\nThe following script creates a new m map, puts key-value pairs into the map, uses m.remove() within a loop to remove each valid key listed in the removeKeys array, then calls m.clear() to remove all remaining key-value pairs. It uses a custom debugLabel() method to display the size, keys, and values of m after each change:\nindicator(\"Removing key-value pairs demo\")\n//@function Returns a label to display the keys and values from a map.\nmap<string, int> this, int barIndex = bar_index,\ncolor bgColor = color.blue, string note = \"\"\n//@variable A string representing the size, keys, and values in `this` map.\nstring repr = str.format(\n\"{0}\\nSize: {1}\\nKeys: {2}\\nValues: {3}\",\nnote, this.size(), str.tostring(this.keys()), str.tostring(this.values())\nbarIndex, 0, repr, color = bgColor, style = label.style_label_center,\n//@variable A map containing `string` keys and `int` values.\nm = map.new<string, int>()\n// Put key-value pairs into `m`.\nfor [i, key] in array.from(\"A\", \"B\", \"C\", \"D\", \"E\")\nm.put(key, i)\nm.debugLabel(bar_index, color.green, \"Added pairs\")\n//@variable An array of keys to remove from `m`.\narray<string> removeKeys = array.from(\"B\", \"B\", \"D\", \"F\", \"a\")\n// Remove each `key` in `removeKeys` from `m`.\nfor key in removeKeys\nm.remove(key)\nm.debugLabel(bar_index + 10, color.red, \"Removed pairs\")\n// Remove all remaining keys from `m`.\nm.clear()\nm.debugLabel(bar_index + 20, color.purple, \"Cleared the map\")\nNot all strings in the removeKeys array were present in the keys of m. Attempting to remove non-existent keys (“F”, “a”, and the second “B” in this example) has no effect on a map’s contents.\nCombining maps¶\nScripts can combine two maps via map.put_all(). This function puts all key-value pairs from the id2 map, in their insertion order, into the id1 map. As with map.put(), if any keys in id2 are also present in id1, this function replaces the key-value pairs that contain those keys without affecting their initial insertion order.\nThis example contains a user-defined hexMap() function that maps decimal int keys to string representations of their hexadecimal forms. The script uses this function to create two maps, mapA and mapB, then uses mapA.put_all(mapB) to put all key-value pairs from mapB into mapA.\nThe script uses a custom debugLabel() function to display labels showing the keys and values of mapA and mapB, then another label displaying the contents of mapA after putting all key-value pairs from mapB into it:\nindicator(\"Combining maps demo\", \"Hex map\")\n//@variable An array of string hex digits.\nvar array<string> hexDigits = str.split(\"0123456789ABCDEF\", \"\")\n//@function Returns a hexadecimal string for the specified `value`.\nhex(int value) =>\n//@variable A string representing the hex form of the `value`.\nstring result = \"\"\n//@variable A temporary value for digit calculation.\nint tempValue = value\nwhile tempValue > 0\n//@variable The next integer digit.\nint digit = tempValue % 16\n// Add the hex form of the `digit` to the `result`.\nresult := hexDigits.get(digit) + result\n// Divide the `tempValue` by the base.\ntempValue := int(tempValue / 16)\nresult\n//@function Returns a map holding the `numbers` as keys and their `hex` strings as values.\nhexMap(array<int> numbers) =>\n//@variable A map associating `int` keys with `string` values.\nresult = map.new<int, string>()\nfor number in numbers\n// Put a pair containing the `number` and its `hex()` representation into the `result`.\nresult.put(number, hex(number))\nresult\n//@function Returns a label to display the keys and values of a hex map.\ndebugLabel(\nmap<int, string> this, int barIndex = bar_index, color bgColor = color.blue,\nstring style = label.style_label_center, string note = \"\"\nstring repr = str.format(\n\"{0}\\nDecimal: {1}\\nHex: {2}\",\nnote, str.tostring(this.keys()), str.tostring(this.values())\nbarIndex, 0, repr, color = bgColor, style = style,\n//@variable A map with decimal `int` keys and hexadecimal `string` values.\nmap<int, string> mapA = hexMap(array.from(101, 202, 303, 404))\ndebugLabel(mapA, bar_index, color.navy, label.style_label_down, \"A\")\n//@variable A map containing key-value pairs to add to `mapA`.\nmap<int, string> mapB = hexMap(array.from(303, 404, 505, 606, 707, 808))\ndebugLabel(mapB, bar_index, color.maroon, label.style_label_up, \"B\")\n// Put all pairs from `mapB` into `mapA`.\nmapA.put_all(mapB)\ndebugLabel(mapA, bar_index + 10, color.purple, note = \"Merge B into A\")\nLooping through a map¶\nThere are several ways scripts can iteratively access the keys and values in a map. For example, one could loop through a map’s keys() array and get() the value for each key, like so:\nfor key in thisMap.keys()\nvalue = thisMap.get(key)\nHowever, we recommend using a for...in loop directly on a map, as it iterates over the map’s key-value pairs in their insertion order, returning a tuple containing the next pair’s key and value on each iteration.\nFor example, this line of code loops through each key and value in thisMap, starting from the first key-value pair put into it:\nfor [key, value] in thisMap\nLet’s use this structure to write a script that displays a map’s key-value pairs in a table. In the example below, we’ve defined a custom toTable() method that creates a table, then uses a for...in loop to iterate over the map’s key-value pairs and populate the table’s cells. The script uses this method to visualize a map containing length-bar averages of price and volume data:\nindicator(\"Looping through a map demo\", \"Table of averages\")\n//@variable The length of the moving average.\n//@variable The size of the table text.\nstring txtSize = input.string(\nsize.huge, \"Text size\",\noptions = [size.auto, size.tiny, size.small, size.normal, size.large, size.huge]\n//@function Displays the pairs of `this` map within a table.\n//@param this A map with `string` keys and `float` values.\n//@param position The position of the table on the chart.\n//@param header The string to display on the top row of the table.\n//@param textSize The size of the text in the table.\n//@returns A new `table` object with cells displaying each pair in `this`.\nmethod toTable(\nmap<string, float> this, string position = position.middle_center, string header = na,\nstring textSize = size.huge\n// Color variables\nborderColor = #000000\nheaderColor = color.rgb(1, 88, 80)\npairColor = color.maroon\ntextColor = color.white\n//@variable A table that displays the key-value pairs of `this` map.\ntable result = table.new(\nposition, this.size() + 1, 3, border_width = 2, border_color = borderColor\n// Initialize top and side header cells.\nresult.cell(1, 0, header, bgcolor = headerColor, text_color = textColor, text_size = textSize)\nresult.merge_cells(1, 0, this.size(), 0)\nresult.cell(0, 1, \"Key\", bgcolor = headerColor, text_color = textColor, text_size = textSize)\nresult.cell(0, 2, \"Value\", bgcolor = headerColor, text_color = textColor, text_size = textSize)\n//@variable The column index of the table. Updates on each loop iteration.\nint col = 1\n// Loop over each `key` and `value` from `this` map in the insertion order.\nfor [key, value] in this\n// Initialize a `key` cell in the `result` table on row 1.\nresult.cell(\ncol, 1, str.tostring(key), bgcolor = color.maroon,\ntext_color = color.white, text_size = textSize\n// Initialize a `value` cell in the `result` table on row 2.\nresult.cell(\ncol, 2, str.tostring(value), bgcolor = color.maroon,\ntext_color = color.white, text_size = textSize\n// Move to the next column index.\ncol += 1\nresult // Return the `result` table.\n//@variable A map with `string` keys and `float` values to hold `length`-bar averages.\naverages = map.new<string, float>()\n// Put key-value pairs into the `averages` map.\naverages.put(\"Open\", ta.sma(open, length))\naverages.put(\"High\", ta.sma(high, length))\naverages.put(\"Low\", ta.sma(low, length))\naverages.put(\"Close\", ta.sma(close, length))\naverages.put(\"Volume\", ta.sma(volume, length))\n//@variable The text to display at the top of the table.\nstring headerText = str.format(\"{0} {1}-bar averages\", \"'\" + syminfo.tickerid + \"'\", length)\n// Display the `averages` map in a `table` with the `headerText`.\naverages.toTable(header = headerText, textSize = txtSize)\nCopying a map¶\nShallow copies¶\nScripts can make a shallow copy of a map id using the map.copy() function. Modifications to a shallow copy do not affect the original id map or its internal insertion order.\nFor example, this script constructs an m map with the keys “A”, “B”, “C”, and “D” assigned to four random values between 0 and 10. It then creates an mCopy map as a shallow copy of m and updates the values associated with its keys. The script displays the key-value pairs in m and mCopy on the chart using our custom debugLabel() method:\nindicator(\"Shallow copy demo\")\n//@function Displays the key-value pairs of `this` map in a label.\nmap<string, float> this, int barIndex = bar_index, color bgColor = color.blue,\n//@variable The text to display in the label.\nlabelText = note + \"\\n{\"\nfor [key, value] in this\nlabelText += str.format(\"{0}: {1}, \", key, value)\nlabelText := str.replace(labelText, \", \", \"}\", this.size() - 1)\nlabel result = label.new(\n//@variable A map of `string` keys and random `float` values.\nm = map.new<string, float>()\n// Assign random values to an array of keys in `m`.\nfor key in array.from(\"A\", \"B\", \"C\", \"D\")\nm.put(key, math.random(0, 10))\n//@variable A shallow copy of `m`.\nmCopy = m.copy()\n// Assign the insertion order value `i` to each `key` in `mCopy`.\nfor [i, key] in mCopy.keys()\nmCopy.put(key, i)\n// Display the labels.\nm.debugLabel(bar_index, note = \"Original\")\nmCopy.debugLabel(bar_index + 10, color.purple, note = \"Copied and changed\")\nDeep copies¶\nWhile a shallow copy will suffice when copying maps that have values of a fundamental type, it’s important to remember that shallow copies of a map holding values of a reference type (line, linefill, box, polyline, label, table, chart.point or a UDT) point to the same objects as the original. Modifying the objects referenced by a shallow copy will affect the instances referenced by the original map and vice versa.\nTo ensure changes to objects referenced by a copied map do not affect instances referenced in other locations, one can make a deep copy by creating a new map with key-value pairs containing copies of each value in the original map.\nThis example creates an original map of string keys and label values and puts a key-value pair into it. The script copies the map to a shallow variable via the built-in copy() method, then to a deep variable using a custom deepCopy() method.\nAs we see from the chart, changes to the label retrieved from the shallow copy also affect the instance referenced by the original map, but changes to the one from the deep copy do not:\nindicator(\"Deep copy demo\")\n//@function Returns a deep copy of `this` map.\nmethod deepCopy(map<string, label> this) =>\n//@variable A deep copy of `this` map.\nresult = map.new<string, label>()\n// Add key-value pairs with copies of each `value` to the `result`.\nfor [key, value] in this\nresult.put(key, value.copy())\nresult //Return the `result`.\n//@variable A map containing `string` keys and `label` values.\nvar original = map.new<string, label>()\n// Put a new key-value pair into the `original` map.\nmap.put(\noriginal, \"Test\",\nlabel.new(bar_index, 0, \"Original\", textcolor = color.white, size = size.huge)\n//@variable A shallow copy of the `original` map.\nmap<string, label> shallow = original.copy()\n//@variable A deep copy of the `original` map.\nmap<string, label> deep = original.deepCopy()\n//@variable The \"Test\" label from the `shallow` copy.\nlabel shallowLabel = shallow.get(\"Test\")\n//@variable The \"Test\" label from the `deep` copy.\nlabel deepLabel = deep.get(\"Test\")\n// Modify the \"Test\" label's `y` attribute in the `original` map.\n// This also affects the `shallowLabel`.\noriginal.get(\"Test\").set_y(label.all.size())\n// Modify the `shallowLabel`. Also modifies the \"Test\" label in the `original` map.\nshallowLabel.set_text(\"Shallow copy\")\nshallowLabel.set_color(color.red)\nshallowLabel.set_style(label.style_label_up)\n// Modify the `deepLabel`. Does not modify any other label instance.\ndeepLabel.set_text(\"Deep copy\")\ndeepLabel.set_color(color.navy)\ndeepLabel.set_style(label.style_label_left)\ndeepLabel.set_x(bar_index + 5)\nThe deepCopy() method loops through the original map, copying each value and putting key-value pairs containing the copies into a new map instance.\nScope and history¶\nAs with other collections in Pine, map variables leave historical trails on each bar, allowing a script to access past map instances assigned to a variable using the history-referencing operator []. Scripts can also assign maps to global variables and interact with them from the scopes of functions, methods, and conditional structures.\nAs an example, this script uses a global map and its history to calculate an aggregate set of EMAs. It declares a globalData map of int keys and float values, where each key in the map corresponds to the length of each EMA calculation. The user-defined update() function calculates each key-length EMA by mixing the values from the previous map assigned to globalData with the current source value.\nThe script plots the maximum and minimum values in the global map’s values() array and the value from globalData.get(50) (i.e., the 50-bar EMA):\nindicator(\"Scope and history demo\", overlay = true)\n//@variable The source value for EMA calculation.\nfloat source = input.source(close, \"Source\")\n//@variable A map containing global key-value pairs.\nglobalData = map.new<int, float>()\n//@function Calculates a set of EMAs and updates the key-value pairs in `globalData`.\nupdate() =>\n//@variable The previous map instance assigned to `globalData`.\nmap<int, float> previous = globalData[1]\n// Put key-value pairs with keys 10-200 into `globalData` if `previous` is `na`.\nif na(previous)\nfor i = 10 to 200\nglobalData.put(i, source)\n// Iterate each `key` and `value` in the `previous` map.\nfor [key, value] in previous\n//@variable The smoothing parameter for the `key`-length EMA.\nfloat alpha = 2.0 / (key + 1.0)\n//@variable The `key`-length EMA value.\nfloat ema = (1.0 - alpha) * value + alpha * source\n// Put the `key`-length `ema` into the `globalData` map.\nglobalData.put(key, ema)\n// Update the `globalData` map.\nupdate()\n//@variable The array of values from `globalData` in their insertion order.\narray<float> values = globalData.values()\n// Plot the max EMA, min EMA, and 50-bar EMA values.\nplot(values.max(), \"Max EMA\", color.green, 2)\nplot(values.min(), \"Min EMA\", color.red, 2)\nplot(globalData.get(50), \"50-bar EMA\", color.orange, 3)\nMaps of other collections¶\nMaps cannot directly use other maps, arrays, or matrices as values, but they can hold values of a user-defined type that contains collections within its fields.\nFor example, suppose we want to create a “2D” map that uses string keys to access nested maps that hold pairs of string keys and float values. Since maps cannot use other collections as values, we will first create a wrapper type with a field to hold a map<string, float> instance, like so:\n//@type A wrapper type for maps with `string` keys and `float` values.\ntype Wrapper\nmap<string, float> data\nWith our Wrapper type defined, we can create maps of string keys and Wrapper values, where the data field of each value in the map points to a map<string, float> instance:\nmapOfMaps = map.new<string, Wrapper>()\nThe script below uses this concept to construct a map containing maps that hold OHLCV data requested from multiple tickers. The user-defined requestData() function requests price and volume data from a ticker, creates a <string, float> map, puts the data into it, then returns a Wrapper instance containing the new map.\nThe script puts the results from each call to requestData() into the mapOfMaps, then creates a string representation of the nested maps with a user-defined toString() method, which it displays on the chart in a label:\nindicator(\"Nested map demo\")\n//@variable The timeframe of the requested data.\nstring tf = input.timeframe(\"D\", \"Timeframe\")\n// Symbol inputs.\nstring symbol1 = input.symbol(\"EURUSD\", \"Symbol 1\")\nstring symbol2 = input.symbol(\"GBPUSD\", \"Symbol 2\")\nstring symbol3 = input.symbol(\"EURGBP\", \"Symbol 3\")\n//@type A wrapper type for maps with `string` keys and `float` values.\ntype Wrapper\nmap<string, float> data\n//@function Returns a wrapped map containing OHLCV data from the `tickerID` at the `timeframe`.\nrequestData(string tickerID, string timeframe) =>\n// Request a tuple of OHLCV values from the specified ticker and timeframe.\n[o, h, l, c, v] = request.security(\ntickerID, timeframe,\n[open, high, low, close, volume]\n//@variable A map containing requested OHLCV data.\nresult = map.new<string, float>()\n// Put key-value pairs into the `result`.\nresult.put(\"Open\", o)\nresult.put(\"High\", h)\nresult.put(\"Low\", l)\nresult.put(\"Close\", c)\nresult.put(\"Volume\", v)\n//Return the wrapped `result`.\nWrapper.new(result)\n//@function Returns a string representing `this` map of `string` keys and `Wrapper` values.\nmethod toString(map<string, Wrapper> this) =>\n//@variable A string representation of `this` map.\nstring result = \"{\"\n// Iterate over each `key1` and associated `wrapper` in `this`.\nfor [key1, wrapper] in this\n// Add `key1` to the `result`.\nresult += key1\n//@variable A string representation of the `wrapper.data` map.\nstring innerStr = \": {\"\n// Iterate over each `key2` and associated `value` in the wrapped map.\nfor [key2, value] in wrapper.data\n// Add the key-value pair's representation to `innerStr`.\ninnerStr += str.format(\"{0}: {1}, \", key2, str.tostring(value))\n// Replace the end of `innerStr` with \"}\" and add to `result`.\nresult += str.replace(innerStr, \", \", \"},\\n\", wrapper.data.size() - 1)\n// Replace the blank line at the end of `result` with \"}\".\nresult := str.replace(result, \",\\n\", \"}\", this.size() - 1)\n//@variable A map of wrapped maps containing OHLCV data from multiple tickers.\nvar mapOfMaps = map.new<string, Wrapper>()\n//@variable A label showing the contents of the `mapOfMaps`.\nvar debugLabel = label.new(\nbar_index, 0, color = color.navy, textcolor = color.white, size = size.huge,\nstyle = label.style_label_center, text_font_family = font.family_monospace\n// Put wrapped maps into `mapOfMaps`.\nmapOfMaps.put(symbol1, requestData(symbol1, tf))\nmapOfMaps.put(symbol2, requestData(symbol2, tf))\nmapOfMaps.put(symbol3, requestData(symbol3, tf))\n// Update the label.\ndebugLabel.set_text(mapOfMaps.toString())\ndebugLabel.set_x(bar_index)"
},
{
  "text": "Bar coloring¶\nThe barcolor() function lets you color chart bars. It is the only Pine Script™ function that allows a script running in a pane to affect the chart.\nThe function’s signature is:\nbarcolor(color, offset, editable, show_last, title) → void\nThe coloring can be conditional because the color parameter accepts “series color” arguments.\nThe following script renders inside and outside bars in different colors:\nindicator(\"barcolor example\", overlay = true)\nisUp = close > open\nisDown = close <= open\nisOutsideUp = high > high[1] and low < low[1] and isUp\nisOutsideDown = high > high[1] and low < low[1] and isDown\nisInside = high < high[1] and low > low[1]\nbarcolor(isInside ? color.yellow : isOutsideUp ? color.aqua : isOutsideDown ? color.purple : na)\nThe na value leaves bars as is.\nIn the barcolor() call, we use embedded ?: ternary operator expressions to select the color."
},
{
  "text": "Chart information¶\nPrices and volume\nSymbol information\nChart timeframe\nSession information\nThe way scripts can obtain information about the chart and symbol they are currently running on is through a subset of Pine Script™’s built-in variables. The ones we cover here allow scripts to access information relating to:\nThe chart’s prices and volume\nThe chart’s symbol\nThe chart’s timeframe\nThe session (or time period) the symbol trades on\nPrices and volume¶\nThe built-in variables for OHLCV values are:\nopen: the bar’s opening price.\nhigh: the bar’s highest price, or the highest price reached during the realtime bar’s elapsed time.\nlow: the bar’s lowest price, or the lowest price reached during the realtime bar’s elapsed time.\nclose: the bar’s closing price, or the current price in the realtime bar.\nvolume: the volume traded during the bar, or the volume traded during the realtime bar’s elapsed time. The unit of volume information varies with the instrument. It is in shares for stocks, in lots for forex, in contracts for futures, in the base currency for crypto, etc.\nOther values are available through:\nhl2: the average of the bar’s high and low values.\nhlc3: the average of the bar’s high, low and close values.\nohlc4: the average of the bar’s open, high, low and close values.\nOn historical bars, the values of the above variables do not vary during the bar because only OHLCV information is available on them. When running on historical bars, scripts execute on the bar’s close, when all the bar’s information is known and cannot change during the script’s execution on the bar.\nRealtime bars are another story altogether. When indicators (or strategies using calc_on_every_tick = true) run in realtime, the values of the above variables (except open) will vary between successive iterations of the script on the realtime bar, because they represent their current value at one point in time during the progress of the realtime bar. This may lead to one form of repainting. See the page on Pine Script™’s execution model for more details.\nThe [] history-referencing operator can be used to refer to past values of the built-in variables, e.g., close[1] refers to the value of close on the previous bar, relative to the particular bar the script is executing on.\nSymbol information¶\nBuilt-in variables in the syminfo namespace provide scripts with information on the symbol of the chart the script is running on. This information changes every time a script user changes the chart’s symbol. The script then re-executes on all the chart’s bars using the new values of the built-in variables:\nsyminfo.basecurrency: the base currency, e.g., “BTC” in “BTCUSD”, or “EUR” in “EURUSD”.\nsyminfo.currency: the quote currency, e.g., “USD” in “BTCUSD”, or “CAD” in “USDCAD”.\nsyminfo.description: The long description of the symbol.\nsyminfo.mintick: The symbol’s tick value, or the minimum increment price can move in. Not to be confused with pips or points. On “ES1!” (“S&P 500 E-Mini”) the tick size is 0.25 because that is the minimal increment the price moves in.\nsyminfo.pointvalue: The point value is the multiple of the underlying asset determining a contract’s value. On “ES1!” (“S&P 500 E-Mini”) the point value is 50, so a contract is worth 50 times the price of the instrument.\nsyminfo.prefix: The prefix is the exchange or broker’s identifier: “NASDAQ” or “BATS” for “AAPL”, “CME_MINI_DL” for “ES1!”.\nsyminfo.root: It is the ticker’s prefix for structured tickers like those of futures. It is “ES” for “ES1!”, “ZW” for “ZW1!”.\nsyminfo.session: It reflects the session setting on the chart for that symbol. If the “Chart settings/Symbol/Session” field is set to “Extended”, it will only return “extended” if the symbol and the user’s feed allow for extended sessions. It is rarely displayed and used mostly as an argument to the session parameter in ticker.new().\nsyminfo.ticker: It is the symbol’s name, without the exchange part (syminfo.prefix): “BTCUSD”, “AAPL”, “ES1!”, “USDCAD”.\nsyminfo.tickerid: This string is rarely displayed. It is mostly used as an argument for request.security()’s symbol parameter. It includes session, prefix and ticker information.\nsyminfo.timezone: The timezone the symbol is traded in. The string is an IANA time zone database name (e.g., “America/New_York”).\nsyminfo.type: The type of market the symbol belongs to. The values are “stock”, “futures”, “index”, “forex”, “crypto”, “fund”, “dr”, “cfd”, “bond”, “warrant”, “structured” and “right”.\nThis script will display the values of those built-in variables on the chart:\nindicator(\"`syminfo.*` built-ins\", \"\", true)\nprintTable(txtLeft, txtRight) =>\nvar table t = table.new(position.middle_right, 2, 1)\ntable.cell(t, 0, 0, txtLeft, bgcolor = color.yellow, text_halign = text.align_right)\ntable.cell(t, 1, 0, txtRight, bgcolor = color.yellow, text_halign = text.align_left)\nnl = \"\\n\"\nleft =\n\"syminfo.basecurrency: \" + nl +\n\"syminfo.currency: \" + nl +\n\"syminfo.description: \" + nl +\n\"syminfo.mintick: \" + nl +\n\"syminfo.pointvalue: \" + nl +\n\"syminfo.prefix: \" + nl +\n\"syminfo.root: \" + nl +\n\"syminfo.session: \" + nl +\n\"syminfo.ticker: \" + nl +\n\"syminfo.tickerid: \" + nl +\n\"syminfo.timezone: \" + nl +\n\"syminfo.type: \"\nright =\nsyminfo.basecurrency + nl +\nsyminfo.currency + nl +\nsyminfo.description + nl +\nstr.tostring(syminfo.mintick) + nl +\nstr.tostring(syminfo.pointvalue) + nl +\nsyminfo.prefix + nl +\nsyminfo.root + nl +\nsyminfo.session + nl +\nsyminfo.ticker + nl +\nsyminfo.tickerid + nl +\nsyminfo.timezone + nl +\nsyminfo.type\nprintTable(left, right)\nChart timeframe¶\nA script can obtain information on the type of timeframe used on the chart using these built-ins, which all return a “simple bool” result:\ntimeframe.isseconds\ntimeframe.isminutes\ntimeframe.isintraday\ntimeframe.isdaily\ntimeframe.isweekly\ntimeframe.ismonthly\ntimeframe.isdwm\nTwo additional built-ins return more specific timeframe information:\ntimeframe.multiplier returns a “simple int” containing the multiplier of the timeframe unit. A chart timeframe of one hour will return 60 because intraday timeframes are expressed in minutes. A 30sec timeframe will return 30 (seconds), a daily chart will return 1 (day), a quarterly chart will return 3 (months), and a yearly chart will return 12 (months). The value of this variable cannot be used as an argument to timeframe parameters in built-in functions, as they expect a string in timeframe specifications format.\ntimeframe.period returns a string in Pine Script™’s timeframe specification format.\nSee the page on Timeframes for more information.\nSession information¶\nSession information is available in different forms:\nThe syminfo.session built-in variable returns a value that is either session.regular or session.extended. It reflects the session setting on the chart for that symbol. If the “Chart settings/Symbol/Session” field is set to “Extended”, it will only return “extended” if the symbol and the user’s feed allow for extended sessions. It is used when a session type is expected, for example as the argument for the session parameter in ticker.new().\nSession state built-ins provide information on the trading session a bar belongs to."
},
{
  "text": "Colors¶\nTransparency\nZ-index\nConstant colors\nConditional coloring\nCalculated colors\ncolor.new()\ncolor.rgb()\ncolor.from_gradient()\nMixing transparencies\nTips\nDesigning usable colors schemes\nPlot crisp lines\nCustomize gradients\nColor selection through script settings\nScript visuals can play a critical role in the usability of the indicators we write in Pine Script™. Well-designed plots and drawings make indicators easier to use and understand. Good visual designs establish a visual hierarchy that allows the more important information to stand out, and the less important one to not get in the way.\nUsing colors in Pine can be as simple as you want, or as involved as your concept requires. The 4,294,967,296 possible assemblies of color and transparency available in Pine Script™ can be applied to:\nAny element you can plot or draw in an indicator’s visual space, be it lines, fills, text or candles.\nThe background of a script’s visual space, whether the script is running in its own pane, or in overlay mode on the chart.\nThe color of bars or the body of candles appearing on a chart.\nA script can only color the elements it places in its own visual space. The only exception to this rule is that a pane indicator can color chart bars or candles.\nPine Script™ has built-in colors such as color.green, as well as functions like color.rgb() which allow you to dynamically generate any color in the RGBA color space.\nTransparency¶\nEach color in Pine Script™ is defined by four values:\nIts red, green and blue components (0-255), following the RGB color model.\nIts transparency (0-100), often referred to as the Alpha channel outside Pine, as defined in the RGBA color model. Even though transparency is expressed in the 0-100 range, its value can be a “float” when used in functions, which gives you access to the 256 underlying values of the alpha channel.\nThe transparency of a color defines how opaque it is: zero is fully opaque, 100 makes the color—whichever it is—invisible. Modulating transparency can be crucial in more involved color visuals or when using backgrounds, to control which colors dominate the others, and how they mix together when superimposed.\nZ-index¶\nWhen you place elements in a script’s visual space, they have relative depth on the z axis; some will appear on top of others. The z-index is a value that represents the position of elements on the z axis. Elements with the highest z-index appear on top.\nElements drawn in Pine Script™ are divided in groups. Each group has its own position in the z space, and within the same group, elements created last in the script’s logic will appear on top of other elements from the same group. An element of one group cannot be placed outside the region of the z space attributed to its group, so a plot can never appear on top of a table, for example, because tables have the highest z-index.\nThis list contains the groups of visual elements, ordered by increasing z-index, so background colors are always at the bottom of z space, and tables will always appear on top of all other elements:\nBackground colors\nFills\nPlots\nHlines\nLineFills\nLines\nBoxes\nLabels\nTables\nNote that by using explicit_plot_zorder = true in indicator() or strategy(), you can control the relative z-index of plot*(), hline() and fill() visuals using their sequential order in the script.\nConstant colors¶\nThere are 17 built-in colors in Pine Script™. This table lists their names, hexadecimal equivalent, and RGB values as arguments to color.rgb():\nName Hex RGB values \ncolor.aqua\t#00BCD4\tcolor.rgb(0, 188, 212)\t\ncolor.black\t#363A45\tcolor.rgb(54, 58, 69)\t\ncolor.blue\t#2196F3\tcolor.rgb(33, 150, 243)\t\ncolor.fuchsia\t#E040FB\tcolor.rgb(224, 64, 251)\t\ncolor.gray\t#787B86\tcolor.rgb(120, 123, 134)\t\ncolor.green\t#4CAF50\tcolor.rgb(76, 175, 80)\t\ncolor.lime\t#00E676\tcolor.rgb(0, 230, 118)\t\ncolor.maroon\t#880E4F\tcolor.rgb(136, 14, 79)\t\ncolor.navy\t#311B92\tcolor.rgb(49, 27, 146)\t\ncolor.olive\t#808000\tcolor.rgb(128, 128, 0)\t\ncolor.orange\t#FF9800\tcolor.rgb(255, 152, 0)\t\ncolor.purple\t#9C27B0\tcolor.rgb(156, 39, 176)\t\ncolor.red\t#FF5252\tcolor.rgb(255, 82, 82)\t\ncolor.silver\t#B2B5BE\tcolor.rgb(178, 181, 190)\t\ncolor.teal\t#00897B\tcolor.rgb(0, 137, 123)\t\ncolor.white\t#FFFFFF\tcolor.rgb(255, 255, 255)\t\ncolor.yellow\t#FFEB3B\tcolor.rgb(255, 235, 59)\t\nIn the following script, all plots use the same color.olive color with a transparency of 40, but expressed in different ways. All five methods are functionally equivalent:\n// ———— Transparency (#99) is included in the hex value.\nplot(ta.sma(close, 10), \"10\", #80800099)\n// ———— Transparency is included in the color-generating function's arguments.\nplot(ta.sma(close, 30), \"30\", color.new(color.olive, 40))\nplot(ta.sma(close, 50), \"50\", color.rgb(128, 128, 0, 40))\n// ———— Use `transp` parameter (deprecated and advised against)\nplot(ta.sma(close, 70), \"70\", color.olive, transp = 40)\nplot(ta.sma(close, 90), \"90\", #808000, transp = 40)\nThe last two plot() calls specify transparency using the transp parameter. This use should be avoided as the transp is deprecated in Pine Script™ v5. Using the transp parameter to define transparency is not as flexible because it requires an argument of input integer type, which entails it must be known before the script is executed, and so cannot be calculated dynamically, as your script executes bar to bar. Additionally, if you use a color argument that already includes transparency information, as is done in the next three plot() calls, any argument used for the transp parameter would have no effect. This is also true for other functions with a transp parameter.\nThe colors in the previous script do not vary as the script executes bar to bar. Sometimes, however, colors need to be created as the script executes on each bar because they depend on conditions that are unknown at compile time, or when the script begins execution on bar zero. For those cases, programmers have two options:\nUse conditional statements to select colors from a few pre-determined base colors.\nBuild new colors dynamically, by calculating them as the script executes bar to bar, to implement color gradients, for example.\nConditional coloring¶\nLet’s say you want to color a moving average in different colors, depending on some conditions you define. To do so, you can use a conditional statement that will select a different color for each of your states. Let’s start by coloring a moving average in a bull color when it’s rising, and in a bear color when it’s not:\nindicator(\"Conditional colors\", \"\", true)\nint lengthInput = input.int(20, \"Length\", minval = 2)\ncolor maBullColorInput = input.color(color.green, \"Bull\")\ncolor maBearColorInput = input.color(color.maroon, \"Bear\")\nfloat ma = ta.sma(close, lengthInput)\n// Define our states.\nbool maRising = ta.rising(ma, 1)\n// Build our color.\ncolor c_ma = maRising ? maBullColorInput : maBearColorInput\nplot(ma, \"MA\", c_ma, 2)\nWe provide users of our script a selection of colors for our bull/bear colors.\nWe define an maRising boolean variable which will hold true when the moving average is higher on the current bar than it was on the last.\nWe define a c_ma color variable that is assigned one of our two colors, depending on the value of the maRising boolean. We use the ? : ternary operator to write our conditional statement.\nYou can also use conditional colors to avoid plotting under certain conditions. Here, we plot high and low pivots using a line, but we do not want to plot anything when a new pivot comes in, to avoid the joints that would otherwise appear in pivot transitions. To do so, we test for pivot changes and use na as the color value when a change is detected, so that no line is plotted on that bar:\nindicator(\"Conditional colors\", \"\", true)\nint legsInput = input.int(5, \"Pivot Legs\", minval = 1)\ncolor pHiColorInput = input.color(color.olive, \"High pivots\")\ncolor pLoColorInput = input.color(color.orange, \"Low pivots\")\n// Intialize the pivot level variables.\nvar float pHi = na\nvar float pLo = na\n// When a new pivot is detected, save its value.\npHi := nz(ta.pivothigh(legsInput, legsInput), pHi)\npLo := nz(ta.pivotlow( legsInput, legsInput), pLo)\n// When a new pivot is detected, do not plot a color.\nplot(pHi, \"High\", ta.change(pHi) ? na : pHiColorInput, 2, plot.style_line)\nplot(pLo, \"Low\", ta.change(pLo) ? na : pLoColorInput, 2, plot.style_line)\nTo undertand how this code works, one must first know that ta.pivothigh() and ta.pivotlow(), used as they are here without an argument to the source parameter, will return a value when they find a high/low pivot, otherwise they return na.\nWhen we test the value returned by the pivot function for na using the nz() function, we allow the value returned to be assigned to the pHi or pLo variables only when it is not na, otherwise the previous value of the variable is simply reassigned to it, which has no impact on its value. Keep in mind that previous values of pHi and pLo are preserved bar to bar because we use the var keyword when initializing them, which causes the initialization to only occur on the first bar.\nAll that’s left to do next is, when we plot our lines, to insert a ternary conditional statement that will yield na for the color when the pivot value changes, or the color selected in the script’s inputs when the pivot level does not change.\nCalculated colors¶\nUsing functions like color.new(), color.rgb() and color.from_gradient(), one can build colors on the fly, as the script executes bar to bar.\ncolor.new() is most useful when you need to generate different transparency levels from a base color.\ncolor.rgb() is useful when you need to build colors dynamically from red, green, blue, or tranparency components. While color.rgb() creates a color, its sister functions color.r(), color.g(), color.b() and color.t() can be used to extract the red, green, blue or transparency values from a color, which can in turn be used to generate a variant.\ncolor.from_gradient() is useful to create linear gradients between two base colors. It determines which intermediary color to use by evaluating a source value against minimum and maximum values.\ncolor.new()¶\nLet’s put color.new(color, transp) to use to create different transparencies for volume columns using one of two bull/bear base colors:\nindicator(\"Volume\")\n// We name our color constants to make them more readable.\nvar color GOLD_COLOR = #CCCC00ff\nvar color VIOLET_COLOR = #AA00FFff\ncolor bullColorInput = input.color(GOLD_COLOR, \"Bull\")\ncolor bearColorInput = input.color(VIOLET_COLOR, \"Bear\")\nint levelsInput = input.int(10, \"Gradient levels\", minval = 1)\n// We initialize only once on bar zero with `var`, otherwise the count would reset to zero on each bar.\nvar float riseFallCnt = 0\n// Count the rises/falls, clamping the range to: 1 to `i_levels`.\nriseFallCnt := math.max(1, math.min(levelsInput, riseFallCnt + math.sign(volume - nz(volume[1]))))\n// Rescale the count on a scale of 80, reverse it and cap transparency to <80 so that colors remains visible.\nfloat transparency = 80 - math.abs(80 * riseFallCnt / levelsInput)\n// Build the correct transparency of either the bull or bear color.\ncolor volumeColor = color.new(close > open ? bullColorInput : bearColorInput, transparency)\nplot(volume, \"Volume\", volumeColor, 1, plot.style_columns)\nIn the next to last line of our script, we dynamically calculate the column color by varying both the base color used, depending on whether the bar is up or down, and the transparency level, which is calculated from the cumulative rises or falls of volume.\nWe offer the script user control over not only the base bull/bear colors used, but also on the number of brightness levels we use. We use this value to determine the maximum number of rises or falls we will track. Giving users the possiblity to manage this value allows them to adapt the indicator’s visuals to the timeframe or market they use.\nWe take care to control the maximum level of transparency we use so that it never goes higher than 80. This ensures our colors always retain some visibility.\nWe also set the minimum value for the number of levels to 1 in the inputs. When the user selects 1, the volume columns will be either in bull or bear color of maximum brightness—or transparency zero.\ncolor.rgb()¶\nIn our next example we use color.rgb(red, green, blue, transp) to build colors from RGBA values. We use the result in a holiday season gift for our friends, so they can bring their TradingView charts to parties:\nindicator(\"Holiday candles\", \"\", true)\nfloat r = math.random(0, 255)\nfloat g = math.random(0, 255)\nfloat b = math.random(0, 255)\nfloat t = math.random(0, 100)\ncolor holidayColor = color.rgb(r, g, b, t)\nplotcandle(open, high, low, close, color = c_holiday, wickcolor = holidayColor, bordercolor = c_holiday)\nWe generate values in the zero to 255 range for the red, green and blue channels, and in the zero to 100 range for transparency. Also note that because math.random() returns float values, the float 0.0-100.0 range provides access to the full 0-255 transparency values of the underlying alpha channel.\nWe use the math.random(min, max, seed) function to generate pseudo-random values. We do not use an argument for the third parameter of the function: seed. Using it is handy when you want to ensure the repeatability of the function’s results. Called with the same seed, it will produce the same sequence of values.\ncolor.from_gradient()¶\nOur last examples of color calculations will use color.from_gradient(value, bottom_value, top_value, bottom_color, top_color). Let’s first use it in its simplest form, to color a CCI signal in a version of the indicator that otherwise looks like the built-in:\nindicator(title=\"CCI line gradient\", precision=2, timeframe=\"\")\nvar color GOLD_COLOR = #CCCC00\nvar color VIOLET_COLOR = #AA00FF\nvar color BEIGE_COLOR = #9C6E1B\nfloat srcInput = input.source(close, title=\"Source\")\nint lenInput = input.int(20, \"Length\", minval = 5)\ncolor bullColorInput = input.color(GOLD_COLOR, \"Bull\")\ncolor bearColorInput = input.color(BEIGE_COLOR, \"Bear\")\nfloat signal = ta.cci(srcInput, lenInput)\ncolor signalColor = color.from_gradient(signal, -200, 200, bearColorInput, bullColorInput)\nplot(signal, \"CCI\", signalColor)\nbandTopPlotID = hline(100, \"Upper Band\", color.silver, hline.style_dashed)\nbandBotPlotID = hline(-100, \"Lower Band\", color.silver, hline.style_dashed)\nfill(bandTopPlotID, bandBotPlotID, color.new(BEIGE_COLOR, 90), \"Background\")\nTo calculate the gradient, color.from_gradient() requires minimum and maximum values against which the argument used for the value parameter will be compared. The fact that we want a gradient for an unbounded signal like CCI (i.e., without fixed boundaries such as RSI, which always oscillates between 0-100), does not entail we cannot use color.from_gradient(). Here, we solve our conundrum by providing values of -200 and 200 as arguments. They do not represent the real minimum and maximum values for CCI, but they are at levels from which we do not mind the colors no longer changing, as whenever the series is outside the bottom_value and top_value limits, the colors used for bottom_color and top_color will apply.\nThe color progression calculated by color.from_gradient() is linear. If the value of the series is halfway between the bottom_value and top_value arguments, the generated color’s RGBA components will also be halfway between those of bottom_color and top_color.\nMany common indicator calculations are available in Pine Script™ as built-in functions. Here we use ta.cci() instead of calculating it the long way.\nThe argument used for value in color.from_gradient() does not necessarily have to be the value of the line we are calculating. Anything we want can be used, as long as arguments for bottom_value and top_value can be supplied. Here, we enhance our CCI indicator by coloring the band using the number of bars since the signal has been above/below the centerline:\nindicator(title=\"CCI line gradient\", precision=2, timeframe=\"\")\nvar color GOLD_COLOR = #CCCC00\nvar color VIOLET_COLOR = #AA00FF\nvar color GREEN_BG_COLOR = color.new(color.green, 70)\nvar color RED_BG_COLOR = color.new(color.maroon, 70)\nfloat srcInput = input.source(close, \"Source\")\nint lenInput = input.int(20, \"Length\", minval = 5)\nint stepsInput = input.int(50, \"Gradient levels\", minval = 1)\ncolor bullColorInput = input.color(GOLD_COLOR, \"Line: Bull\", inline = \"11\")\ncolor bearColorInput = input.color(VIOLET_COLOR, \"Bear\", inline = \"11\")\ncolor bullBgColorInput = input.color(GREEN_BG_COLOR, \"Background: Bull\", inline = \"12\")\ncolor bearBgColorInput = input.color(RED_BG_COLOR, \"Bear\", inline = \"12\")\n// Plot colored signal line.\nfloat signal = ta.cci(srcInput, lenInput)\ncolor signalColor = color.from_gradient(signal, -200, 200, color.new(bearColorInput, 0), color.new(bullColorInput, 0))\nplot(signal, \"CCI\", signalColor, 2)\n// Detect crosses of the centerline.\nbool signalX = ta.cross(signal, 0)\n// Count no of bars since cross. Capping it to the no of steps from inputs.\nint gradientStep = math.min(stepsInput, nz(ta.barssince(signalX)))\n// Choose bull/bear end color for the gradient.\ncolor endColor = signal > 0 ? bullBgColorInput : bearBgColorInput\n// Get color from gradient going from no color to `c_endColor`\ncolor bandColor = color.from_gradient(gradientStep, 0, stepsInput, na, endColor)\nbandTopPlotID = hline(100, \"Upper Band\", color.silver, hline.style_dashed)\nbandBotPlotID = hline(-100, \"Lower Band\", color.silver, hline.style_dashed)\nfill(bandTopPlotID, bandBotPlotID, bandColor, title = \"Band\")\nThe signal plot uses the same base colors and gradient as in our previous example. We have however increased the width of the line from the default 1 to 2. It is the most important component of our visuals; increasing its width is a way to give it more prominence, and ensure users are not distracted by the band, which has become busier than it was in its original, flat beige color.\nThe fill must remain unobtrusive for two reasons. First, it is of secondary importance to the visuals, as it provides complementary information, i.e., the duration for which the signal has been in bull/bear territory. Second, since fills have a greater z-index than plots, the fill will cover the signal plot. For these reasons, we make the fill’s base colors fairly transparent, at 70, so they do not mask the plots. The gradient used for the band starts with no color at all (see the na used as the argument to bottom_color in the color.from_gradient() call), and goes to the base bull/bear colors from the inputs, which the conditional, c_endColor color variable contains.\nWe provide users with distinct bull/bear color selections for the line and the band.\nWhen we calculate the gradientStep variable, we use nz() on ta.barssince() because in early bars of the dataset, when the condition tested has not occurred yet, ta.barssince() will return na. Because we use nz(), the value returned is replaced with zero in those cases.\nMixing transparencies¶\nIn this example we take our CCI indicator in another direction. We will build dynamically adjusting extremes zone buffers using a Donchian Channel (historical highs/lows) calculated from the CCI. We build the top/bottom bands by making them 1/4 the height of the DC. We will use a dynamically adjusting lookback to calculate the DC. To modulate the lookback, we will calculate a simple measure of volatility by keeping a ratio of a short-period ATR to a long one. When that ratio is higher than 50 of its last 100 values, we consider the volatility high. When the volatility is high/low, we decrease/increase the lookback.\nOur aim is to provide users of our indicator with:\nThe CCI line colored using a bull/bear gradient, as we illustrated in our most recent examples.\nThe top and bottom bands of the Donchian Channel, filled in such a way that their color darkens as a historical high/low becomes older and older.\nA way to appreciate the state of our volatility measure, which we will do by painting the background with one color whose intensity increases when volatility increases.\nThis is what our indicator looks like using the light theme:\nAnd with the dark theme:\nindicator(\"CCI DC\", precision = 6)\ncolor GOLD_COLOR = #CCCC00ff\ncolor VIOLET_COLOR = #AA00FFff\nint lengthInput = input.int(20, \"Length\", minval = 5)\ncolor bullColorInput = input.color(GOLD_COLOR, \"Bull\")\ncolor bearColorInput = input.color(VIOLET_COLOR, \"Bear\")\n// ————— Function clamps `val` between `min` and `max`.\nclamp(val, min, max) =>\nmath.max(min, math.min(max, val))\n// ————— Volatility expressed as 0-100 value.\nfloat v = ta.atr(lengthInput / 5) / ta.atr(lengthInput * 5)\nfloat vPct = ta.percentrank(v, lengthInput * 5)\n// ————— Calculate dynamic lookback for DC. It increases/decreases on low/high volatility.\nbool highVolatility = vPct > 50\nvar int lookBackMin = lengthInput * 2\nvar int lookBackMax = lengthInput * 10\nvar float lookBack = math.avg(lookBackMin, lookBackMax)\nlookBack += highVolatility ? -2 : 2\nlookBack := clamp(lookBack, lookBackMin, lookBackMax)\n// ————— Dynamic lookback length Donchian channel of signal.\nfloat signal = ta.cci(close, lengthInput)\n// `lookBack` is a float; need to cast it to int to be used a length.\nfloat hiTop = ta.highest(signal, int(lookBack))\nfloat loBot = ta.lowest( signal, int(lookBack))\n// Get margin of 25% of the DC height to build high and low bands.\nfloat margin = (hiTop - loBot) / 4\nfloat hiBot = hiTop - margin\nfloat loTop = loBot + margin\n// Center of DC.\nfloat center = math.avg(hiTop, loBot)\n// ————— Create colors.\ncolor signalColor = color.from_gradient(signal, -200, 200, bearColorInput, bullColorInput)\n// Bands: Calculate transparencies so the longer since the hi/lo has changed,\n// the darker the color becomes. Cap highest transparency to 90.\nfloat hiTransp = clamp(100 - (100 * math.max(1, nz(ta.barssince(ta.change(hiTop)) + 1)) / 255), 60, 90)\nfloat loTransp = clamp(100 - (100 * math.max(1, nz(ta.barssince(ta.change(loBot)) + 1)) / 255), 60, 90)\ncolor hiColor = color.new(bullColorInput, hiTransp)\ncolor loColor = color.new(bearColorInput, loTransp)\n// Background: Rescale the 0-100 range of `vPct` to 0-25 to create 75-100 transparencies.\ncolor bgColor = color.new(color.gray, 100 - (vPct / 4))\n// ————— Plots\n// Invisible lines for band fills.\nhiTopPlotID = plot(hiTop, color = na)\nhiBotPlotID = plot(hiBot, color = na)\nloTopPlotID = plot(loTop, color = na)\nloBotPlotID = plot(loBot, color = na)\n// Plot signal and centerline.\np_signal = plot(signal, \"CCI\", signalColor, 2)\nplot(center, \"Centerline\", color.silver, 1)\n// Fill the bands.\nfill(hiTopPlotID, hiBotPlotID, hiColor)\nfill(loTopPlotID, loBotPlotID, loColor)\n// ————— Background.\nWe clamp the transparency of the background to a 100-75 range so that it doesn’t overwhelm. We also use a neutral color that will not distract too much. The darker the background is, the higher our measure of volatility.\nWe also clamp the transparency values for the band fills between 60 and 90. We use 90 so that when a new high/low is found and the gradient resets, the starting transparency makes the color somewhat visible. We do not use a transparency lower than 60 because we don’t want those bands to hide the signal line.\nWe use the very handy ta.percentrank() function to generate a 0-100 value from our ATR ratio measuring volatility. It is useful to convert values whose scale is unknown into known values that can be used to produce transparencies.\nBecause we must clamp values three times in our script, we wrote an f_clamp() function, instead of explicitly coding the logic three times.\nTips¶\nDesigning usable colors schemes¶\nIf you write scripts intended for other traders, try to avoid colors that will not work well in some environments, whether it be for plots, labels, tables or fills. At a minimum, test your visuals to ensure they perform satisfactorily with both the light and dark TradingView themes; they are the most commonly used. Colors such as black and white, for example, should be avoided.\nBuild the appropriate inputs to provide script users the flexibility to adapt your script’s visuals to their particular environments.\nTake care to build a visual hierarchy of the colors you use that matches the relative importance of your script’s visual components. Good designers understand how to achieve the optimal balance of color and weight so the eye is naturally drawn to the most important elements of the design. When you make everything stand out, nothing does. Make room for some elements to stand out by toning down the visuals surrounding it.\nProviding a selection of color presets in your inputs — rather than a single color that can be changed — can help color-challenged users. Our Technical Ratings demonstrates one way of achieving this.\nPlot crisp lines¶\nIt is best to use zero transparency to plot the important lines in your visuals, to keep them crisp. This way, they will show through fills more precisely. Keep in mind that fills have a higher z-index than plots, so they are placed on top of them. A slight increase of a line’s width can also go a long way in making it stand out.\nIf you want a special plot to stand out, you can also give it more importance by using multiple plots for the same line. These are examples where we modulate the successive width and transparency of plots to achieve this:\nplot(high, \"\", color.new(color.orange, 80), 8)\nplot(high, \"\", color.new(color.orange, 60), 4)\nplot(high, \"\", color.new(color.orange, 00), 1)\nplot(hl2, \"\", color.new(color.orange, 60), 4)\nplot(hl2, \"\", color.new(color.orange, 00), 1)\nplot(low, \"\", color.new(color.orange, 0), 1)\nCustomize gradients¶\nWhen building gradients, adapt them to the visuals they apply to. If you are using a gradient to color candles, for example, it is usually best to limit the number of steps in the gradient to ten or less, as it is more difficult for the eye to perceive intensity variations of discrete objects. As we did in our examples, cap minimum and maximum transparency levels so your visual elements remain visible and do not overwhelm when it’s not necessary.\nColor selection through script settings¶\nThe type of color you use in your scripts has an impact on how users of your script will be able to change the colors of your script’s visuals. As long as you don’t use colors whose RGBA components have to be calculated at runtime, script users will be able to modify the colors you use by going to your script’s “Settings/Style” tab. Our first example script on this page meets that criteria, and the following screenshot shows how we used the script’s “Settings/Style” tab to change the color of the first moving average:\nIf your script uses a calculated color, i.e., a color where at least one of its RGBA components can only be known at runtime, then the “Settings/Style” tab will NOT offer users the usual color widgets they can use to modify your plot colors. Plots of the same script not using calculated colors will also be affected. In this script, for example, our first plot() call uses a calculated color, and the second one doesn’t:\nindicator(\"Calculated colors\", \"\", true)\nfloat ma = ta.sma(close, 20)\nfloat maHeight = ta.percentrank(ma, 100)\nfloat transparency = math.min(80, 100 - maHeight)\n// This plot uses a calculated color.\nplot(ma, \"MA1\", color.rgb(156, 39, 176, transparency), 2)\n// This plot does not use a calculated color.\nplot(close, \"Close\", color.blue)\nThe color used in the first plot is a calculated color because its transparency can only be known at runtime. It is calculated using the relative position of the moving average in relation to its past 100 values. The greater percentage of past values are below the current value, the higher the 0-100 value of maHeight will be. Since we want the color to be the darkest when maHeight is 100, we subtract 100 from it to obtain the zero transparency then. We also cap the calculated transparency value to a maximum of 80 so that it always remains visible.\nBecause that calculated color is used in our script, the “Settings/Style” tab will not show any color widgets:\nThe solution to enable script users to control the colors used is to supply them with custom inputs, as we do here:\nindicator(\"Calculated colors\", \"\", true)\ncolor maInput = input.color(color.purple, \"MA\")\ncolor closeInput = input.color(color.blue, \"Close\")\nfloat ma = ta.sma(close, 20)\nfloat maHeight = ta.percentrank(ma, 100)\nfloat transparency = math.min(80, 100 - maHeight)\n// This plot uses a calculated color.\nplot(ma, \"MA1\", color.new(maInput, transparency), 2)\n// This plot does not use a calculated color.\nplot(close, \"Close\", closeInput)\nNotice how our script’s “Settings” now show an “Inputs” tab, where we have created two color inputs. The first one uses color.purple as its default value. Whether the script user changes that color or not, it will then be used in a color.new() call to generate a calculated transparency in the plot() call. The second input uses as its default the built-in color.blue color we previously used in the plot() call, and simply use it as is in the second plot() call."
},
{
  "text": "Bar plotting¶\nPlotting candles with `plotcandle()`\nPlotting bars with `plotbar()`\nThe plotcandle() built-in function is used to plot candles. plotbar() is used to plot conventional bars.\nBoth functions require four arguments that will be used for the OHLC prices (open, high, low, close) of the bars they will be plotting. If one of those is na, no bar is plotted.\nPlotting candles with `plotcandle()`¶\nThe signature of plotcandle() is:\nplotcandle(open, high, low, close, title, color, wickcolor, editable, show_last, bordercolor, display) → void\nThis plots simple candles, all in blue, using the habitual OHLC values, in a separate pane:\nindicator(\"Single-color candles\")\nplotcandle(open, high, low, close)\nTo color them green or red, we can use the following code:\nindicator(\"Example 2\")\npaletteColor = close >= open ? color.lime : color.red\nplotbar(open, high, low, close, color = paletteColor)\nNote that the color parameter accepts “series color” arguments, so constant values such as color.red, color.lime, \"#FF9090\", as well as expressions that calculate colors at runtime, as is done with the paletteColor variable here, will all work.\nYou can build bars or candles using values other than the actual OHLC values. For example you could calculate and plot smoothed candles using the following code, which also colors wicks depending on the position of close relative to the smoothed close (c) of our indicator:\nindicator(\"Smoothed candles\", overlay = true)\nlenInput = input.int(9)\nsmooth(source, length) =>\nta.sma(source, length)\no = smooth(open, lenInput)\nh = smooth(high, lenInput)\nl = smooth(low, lenInput)\nc = smooth(close, lenInput)\nourWickColor = close > c ? color.green : color.red\nplotcandle(o, h, l, c, wickcolor = ourWickColor)\nYou may find it useful to plot OHLC values taken from a higher timeframe. You can, for example, plot daily bars on an intraday chart:\n// NOTE: Use this script on an intraday chart.\nindicator(\"Daily bars\")\n// Use gaps to only return data when the 1D timeframe completes, `na` otherwise.\n[o, h, l, c] = request.security(syminfo.tickerid, \"D\", [open, high, low, close], gaps = barmerge.gaps_on)\nvar color UP_COLOR = color.silver\nvar color DN_COLOR = color.blue\ncolor wickColor = c >= o ? UP_COLOR : DN_COLOR\ncolor bodyColor = c >= o ? color.new(UP_COLOR, 70) : color.new(DN_COLOR, 70)\n// Only plot candles on intraday timeframes,\n// and when non `na` values are returned by `request.security()` because a HTF has completed.\nplotcandle(timeframe.isintraday ? o : na, h, l, c, color = bodyColor, wickcolor = wickColor)\nWe show the script’s plot after having used “Visual Order/Bring to Front” from the script’s “More” menu. This causes our script’s candles to appear on top of the chart’s candles.\nThe script will only display candles when two conditions are met:\nThe chart is using an intraday timeframe (see the check on timeframe.isintraday in the plotcandle() call). We do this because it’s not useful to show a daily value on timeframes higher or equal to 1D.\nThe request.security() function returns non na values (see gaps = barmerge.gaps_on in the function call).\nWe use a tuple ([open, high, low, close]) with request.security() to fetch four values in one call.\nWe use var to declare our UP_COLOR and DN_COLOR color constants on bar zero only. We use constants because those colors are used in more than one place in our code. This way, if we need to change them, we need only do so in one place.\nWe create a lighter transparency for the body of our candles in the bodyColor variable initialization, so they don’t obstruct the chart’s candles.\nPlotting bars with `plotbar()`¶\nThe signature of plotbar() is:\nplotbar(open, high, low, close, title, color, editable, show_last, display) → void\nNote that plotbar() has no parameter for bordercolor or wickcolor, as there are no borders or wicks on conventional bars.\nThis plots conventional bars using the same coloring logic as in the second example of the previous section:\nindicator(\"Dual-color bars\")\npaletteColor = close >= open ? color.lime : color.red\nplotbar(open, high, low, close, color = paletteColor)"
},
{
  "text": "Bar states¶\nBar state built-in variables\n`barstate.isfirst`\n`barstate.islast`\n`barstate.ishistory`\n`barstate.isrealtime`\n`barstate.isnew`\n`barstate.isconfirmed`\n`barstate.islastconfirmedhistory`\nExample\nA set of built-in variables in the barstate namespace allow your script to detect different properties of the bar on which the script is currently executing.\nThese states can be used to restrict the execution or the logic of your code to specific bars.\nSome built-ins return information on the trading session the current bar belongs to. They are explained in the Session states section.\nBar state built-in variables¶\nNote that while indicators and libraries run on all price or volume updates in real time, strategies not using calc_on_every_tick will not; they will only execute when the realtime bar closes. This will affect the detection of bar states in that type of script. On open markets, for example, this code will not display a background until the realtime closes because that is when the strategy runs:\nstrategy(\"S\")\nbgcolor(barstate.islast ? color.silver : na)\n`barstate.isfirst`¶\nbarstate.isfirst is only true on the dataset’s first bar, i.e., when bar_index is zero.\nIt can be useful to initialize variables on the first bar only, e.g.:\n// Declare array and set its values on the first bar only.\nFILL_COLOR = color.green\nvar fillColors = array.new_color(0)\n// Initialize the array elements with progressively lighter shades of the fill color.\narray.push(fillColors, color.new(FILL_COLOR, 70))\narray.push(fillColors, color.new(FILL_COLOR, 75))\narray.push(fillColors, color.new(FILL_COLOR, 80))\narray.push(fillColors, color.new(FILL_COLOR, 85))\narray.push(fillColors, color.new(FILL_COLOR, 90))\n`barstate.islast`¶\nbarstate.islast is true if the current bar is the last one on the chart, whether that bar is a realtime bar or not.\nIt can be used to restrict the execution of code to the chart’s last bar, which is often useful when drawing lines, labels or tables. Here, we use it to determine when to update a label which we want to appear only on the last bar. We create the label only once and then update its properties using label.set_*() functions because it is more efficient:\n// Create label on the first bar only.\nvar label hiLabel = label.new(na, na, \"\")\n// Update the label's position and text on the last bar,\n// including on all realtime bar updates.\nlabel.set_xy(hiLabel, bar_index, high)\nlabel.set_text(hiLabel, str.tostring(high, format.mintick))\n`barstate.ishistory`¶\nbarstate.ishistory is true on all historical bars. It can never be true on a bar when barstate.isrealtime is also true, and it does not become true on a realtime bar’s closing update, when barstate.isconfirmed becomes true. On closed markets, it can be true on the same bar where barstate.islast is also true.\n`barstate.isrealtime`¶\nbarstate.isrealtime is true if the current data update is a real-time bar update, false otherwise (thus it is historical). Note that barstate.islast is also true on all realtime bars.\n`barstate.isnew`¶\nbarstate.isnew is true on all historical bars and on the realtime bar’s first (opening) update.\nAll historical bars are considered new bars because the Pine Script™ runtime executes your script on each bar sequentially, from the chart’s first bar in time, to the last. Each historical bar is thus discovered by your script as it executes, bar to bar.\nbarstate.isnew can be useful to reset varip variables when a new realtime bar comes in. The following code will reset updateNo to 1 on all historical bars and at the beginning of each realtime bar. It calculates the number of realtime updates during each realtime bar:\nupdateNo() =>\nvarip int updateNo = na\nif barstate.isnew\nupdateNo := 1\nupdateNo += 1\nplot(updateNo())\n`barstate.isconfirmed`¶\nbarstate.isconfirmed is true on all historical bars and on the last (closing) update of a realtime bar.\nIt can be useful to avoid repainting by requiring the realtime bar to be closed before a condition can become true. We use it here to hold plotting of our RSI until the realtime bar closes and becomes an elapsed realtime bar. It will plot on historical bars because barstate.isconfirmed is always true on them:\nmyRSI = ta.rsi(close, 20)\nplot(barstate.isconfirmed ? myRSI : na)\nbarstate.isconfirmed will not work when used in a request.security() call.\n`barstate.islastconfirmedhistory`¶\nbarstate.islastconfirmedhistory is true if the script is executing on the dataset’s last bar when the market is closed, or on the bar immediately preceding the realtime bar if the market is open.\nIt can be used to detect the first realtime bar with barstate.islastconfirmedhistory[1], or to postpone server-intensive calculations until the last historical bar, which would otherwise be undetectable on open markets.\nExample¶\nHere is an example of a script using barstate.* variables:\nindicator(\"Bar States\", overlay = true, max_labels_count = 500)\nstateText() =>\nstring txt = \"\"\ntxt += barstate.isfirst ? \"isfirst\\n\" : \"\"\ntxt += barstate.islast ? \"islast\\n\" : \"\"\ntxt += barstate.ishistory ? \"ishistory\\n\" : \"\"\ntxt += barstate.isrealtime ? \"isrealtime\\n\" : \"\"\ntxt += barstate.isnew ? \"isnew\\n\" : \"\"\ntxt += barstate.isconfirmed ? \"isconfirmed\\n\" : \"\"\ntxt += barstate.islastconfirmedhistory ? \"islastconfirmedhistory\\n\" : \"\"\nlabelColor = switch\nbarstate.isfirst => color.fuchsia\nbarstate.islastconfirmedhistory => color.gray\nbarstate.ishistory => color.silver\nbarstate.isconfirmed => color.orange\nbarstate.isnew => color.red\n=> color.yellow\nlabel.new(bar_index, na, stateText(), yloc = yloc.abovebar, color = labelColor)\nEach state’s name will appear in the label’s text when it is true.\nThere are five possible colors for the label’s background:\nfuchsia on the first bar\nsilver on historical bars\ngray on the last confirmed historical bar\norange when a realtime bar is confirmed (when it closes and becomes an elapsed realtime bar)\nred on the realtime bar’s first execution\nyellow for other executions of the realtime bar\nWe begin by adding the indicator to the chart of an open market, but before any realtime update is received. Note how the last confirmed history bar is identified in #1, and how the last bar is identified as the last one, but is still considered a historical bar because no realtime updates have been received.\nLet’s look at what happens when realtime updates start coming in:\nThe realtime bar is red because it is its first execution, because barstate.isnew is true and barstate.ishistory is no longer true, so our switch structure determing our color uses the barstate.isnew => color.red branch. This will usually not last long because on the next update barstate.isnew will no longer be true so the label’s color will turn yellow.\nThe label of elapsed realtime bars is orange because those bars were not historical bars when they closed. Accordingly, the barstate.ishistory => color.silver branch in the switch structure was not executed, but the next one, barstate.isconfirmed => color.orange was.\nThis last example shows how the realtime bar’s label will turn yellow after the first execution on the bar. This is the way the label will usually appear on realtime bars:"
},
{
  "text": "Fills¶\n`plot()` and `hline()` fills\nLine fills\nThere are two different mechanisms dedicated to filling the space between Pine visuals:\nThe fill() function lets you color the background between either two plots plotted using plot() or two horizontal lines plotted using hline().\nThe linefill.new() function fills the space between lines created with line.new().\n`plot()` and `hline()` fills¶\nThe fill() function has two signatures:\nfill(plot1, plot2, color, title, editable, show_last, fillgaps) → void\nfill(hline1, hline2, color, title, editable, fillgaps) → void\nThe arguments used for the plot1, plot2, hline1 and hline2 parameters must be the IDs returned by the plot() and hline() calls. The fill() function is the only built-in function where these IDs are used.\nSee in this first example how the IDs returned by the plot() and hline() calls are captured in the p1, p2, p3, and h1, h2, h3 and h4 variables for reuse as fill() arguments:\nindicator(\"Example 1\")\np1 = plot(math.sin(high))\np2 = plot(math.cos(low))\np3 = plot(math.sin(close))\nfill(p1, p3, color.new(color.red, 90))\nfill(p2, p3, color.new(color.blue, 90))\nh1 = hline(0)\nh2 = hline(1.0)\nh3 = hline(0.5)\nh4 = hline(1.5)\nfill(h1, h2, color.new(color.yellow, 90))\nfill(h3, h4, color.new(color.lime, 90))\nBecause fill() requires two IDs from the same function, we sometimes need to use a plot() call where we would have otherwise used an hline() call, as in this example:\nindicator(\"Example 2\")\nsrc = close\nma = ta.sma(src, 10)\nosc = 100 * (ma - src) / ma\noscPlotID = plot(osc)\n// An `hline()` would not work here because two `plot()` calls are needed.\nzeroPlotID = plot(0, \"Zero\", color.silver, 1, plot.style_circles)\nfill(oscPlotID, zeroPlotID, color.new(color.blue, 90))\nBecause a “series color” can be used as an argument for the color parameter in fill(), you can use constants like color.red or #FF001A, as well as expressions calculating the color on each bar, as in this example:\nindicator(\"Example 3\", \"\", true)\nline1 = ta.sma(close, 5)\nline2 = ta.sma(close, 20)\np1PlotID = plot(line1)\np2PlotID = plot(line2)\nfill(p1PlotID, p2PlotID, line1 > line2 ? color.new(color.green, 90) : color.new(color.red, 90))\nLine fills¶\nLinefills are objects that allow you to fill the space between two line drawings created via the line.new() function. A linefill object is displayed on the chart when the linefill.new() function is called. The function has the following signature:\nlinefill.new(line1, line2, color) → series linefill\nThe line1 and line2 arguments are the line IDs of the two lines to fill between. The color argument is the color of the fill. Any two-line pair can only have one linefill between them, so successive calls to linefill.new() on the same pair of lines will replace the previous linefill with a new one. The function returns the ID of the linefill object it created, which can be saved in a variable for use in linefill.set_color() call that will change the color of an existing linefill.\nThe behavior of linefills is dependent on the lines they are attached to. Linefills cannot be moved directly; their coordinates follow those of the lines they are tied to. If both lines extend in the same direction, the linefill will also extend.\nNote that for line extensions to work correctly, a line’s x1 coordinate must be less than its x2 coordinate. If a line’s x1 argument is greater than its x2 argument and extend.left is used, the line will actually extend to the right because x2 is assumed to be the rightmost x coordinate.\nIn the example below, our indicator draws two lines connecting the last two high and low pivot points of the chart. We extend the lines to the right to project the short-term movement of the chart, and fill the space between them to enhance the visibility of the channel the lines create:\nindicator(\"Channel\", overlay = true)\nLEN_LEFT = 15\nLEN_RIGHT = 5\npH = ta.pivothigh(LEN_LEFT, LEN_RIGHT)\npL = ta.pivotlow(LEN_LEFT, LEN_RIGHT)\n// Bar indices of pivot points\npH_x1 = ta.valuewhen(pH, bar_index, 1) - LEN_RIGHT\npH_x2 = ta.valuewhen(pH, bar_index, 0) - LEN_RIGHT\npL_x1 = ta.valuewhen(pL, bar_index, 1) - LEN_RIGHT\npL_x2 = ta.valuewhen(pL, bar_index, 0) - LEN_RIGHT\n// Price values of pivot points\npH_y1 = ta.valuewhen(pH, pH, 1)\npH_y2 = ta.valuewhen(pH, pH, 0)\npL_y1 = ta.valuewhen(pL, pL, 1)\npL_y2 = ta.valuewhen(pL, pL, 0)\n// Lines\nlH = line.new(pH_x1, pH_y1, pH_x2, pH_y2, extend = extend.right)\nlL = line.new(pL_x1, pL_y1, pL_x2, pL_y2, extend = extend.right)\n// Fill\nfillColor = switch\npH_y2 > pH_y1 and pL_y2 > pL_y1 => color.green\npH_y2 < pH_y1 and pL_y2 < pL_y1 => color.red\n=> color.silver\nlinefill.new(lH, lL, color.new(fillColor, 90))"
},
{
  "text": "Inputs¶\nInput functions\nInput function parameters\nInput types\nSimple input\nInteger input\nFloat input\nBoolean input\nColor input\nTimeframe input\nSymbol input\nSession input\nSource input\nTime input\nOther features affecting Inputs\nTips\nInputs allow scripts to receive values that users can change. Using them for key values will make your scripts more adaptable to user preferences.\nThe following script plots a 20-period simple moving average (SMA) using ta.sma(close, 20). While it is simple to write, it is not very flexible because that specific MA is all it will ever plot:\nindicator(\"MA\", \"\", true)\nplot(ta.sma(close, 20))\nIf instead we write our script this way, it becomes much more flexible because its users will be able to select the source and the length they want to use for the MA’s calculation:\nindicator(\"MA\", \"\", true)\nsourceInput = input(close, \"Source\")\nlengthInput = input(20, \"Length\")\nplot(ta.sma(sourceInput, lengthInput))\nInputs can only be accessed when a script is running on the chart. Script users access them through the script’s “Settings” dialog box, which can be reached by either:\nDouble-clicking on the name of an on-chart indicator\nRight-clicking on the script’s name and choosing the “Settings” item from the dropdown menu\nChoosing the “Settings” item from the “More” menu icon (three dots) that appears when one hovers over the indicator’s name on the chart\nDouble-clicking on the indicator’s name from the Data Window (fourth icon down to the right of the chart)\nThe “Settings” dialog box always contains the “Style” and “Visibility” tabs, which allow users to specify their preferences about the script’s visuals and the chart timeframes where it should be visible.\nWhen a script contains calls to input.*() functions, an “Inputs” tab appears in the “Settings” dialog box.\nIn the flow of a script’s execution, inputs are processed when the script is already on a chart and a user changes values in the “Inputs” tab. The changes trigger a re-execution of the script on all the chart bars, so when a user changes an input value, your script recalculates using that new value.\nInput functions¶\nThe following input functions are available:\ninput()\ninput.int()\ninput.float()\ninput.bool()\ninput.color()\ninput.string()\ninput.timeframe()\ninput.symbol()\ninput.price()\ninput.source()\ninput.session()\ninput.time()\nA specific input widget is created in the “Inputs” tab to accept each type of input. Unless otherwise specified in the input.*() call, each input appears on a new line of the “Inputs” tab, in the order the input.*() calls appear in the script.\nOur Style guide recommends placing input.*() calls at the beginning of the script.\nInput function definitions typically contain many parameters, which allow you to control the default value of inputs, their limits, and their organization in the “Inputs” tab.\nAn input*.() call being just another function call in Pine Script™, its result can be combined with arithmetic, comparison, logical or ternary operators to form an expression to be assigned to the variable. Here, we compare the result of our call to input.string() to the string \"On\". The expression’s result is then stored in the plotDisplayInput variable. Since that variable holds a true or false value, it is a of “input bool” type:\nindicator(\"Input in an expression`\", \"\", true)\nbool plotDisplayInput = input.string(\"On\", \"Plot Display\", options = [\"On\", \"Off\"]) == \"On\"\nplot(plotDisplayInput ? close : na)\nAll values returned by input.*() functions except “source” ones are “input” qualified values. See our User Manual’s section on type qualifiers for more information.\nInput function parameters¶\nThe parameters common to all input functions are: defval, title, tooltip, inline and group. Some parameters are used by the other input functions: options, minval, maxval, step and confirm.\nAll these parameters expect “const” arguments (except if it’s an input used for a “source”, which returns a “series float” result). This means they must be known at compile time and cannot change during the script’s execution. Because the result of an input.*() function is always qualified as “input” or “series”, it follows that the result of one input.*() function call cannot be used as an argument in a subsequent input.*() call because the “input” qualifier is stronger than “const”.\nLet’s go over each parameter:\ndefval is the first parameter of all input functions. It is the default value that will appear in the input widget. It requires an argument of the type of input value the function is used for.\ntitle requires a “const string” argument. It is the field’s label.\ntooltip requires a “const string” argument. When the parameter is used, a question mark icon will appear to the right of the field. When users hover over it, the tooltip’s text will appear. Note that if multiple input fields are grouped on one line using inline, the tooltip will always appear to the right of the rightmost field, and display the text of the last tooltip argument used in the line. Newlines (\\n) are supported in the argument string.\ninline requires a “const string” argument. Using the same argument for the parameter in multiple input.*() calls will group their input widgets on the same line. There is a limit to the width the “Inputs” tab will expand, so a limited quantity of input fields can be fitted on one line. Using one input.*() call with a unique argument for inline has the effect of bringing the input field left, immediately after the label, foregoing the default left-alignment of all input fields used when no inline argument is used.\ngroup requires a “const string” argument. It used to group any number of inputs in the same section. The string used as the group argument becomes the section’s heading. All input.*() calls to be grouped together must use the same string for their group argument.\noptions requires a comma-separated list of elements enclosed in square brackets (e.g., [\"ON\", \"OFF\"]. It is used to create a dropdown menu offering the list’s elements in the form of menu selections. Only one menu item can be selected. When an options list is used, the defval value must be one of the list’s elements. When options is used in input functions allowing minval, maxval or step, those parameters cannot be used simultaneously.\nminval requires a “const int/float” argument, depending on the type of the defval value. It is the minimum valid value for the input field.\nmaxval requires a “const int/float” argument, depending on the type of the defval value. It is the maximum valid value for the input field.\nstep is the increment by which the field’s value will move when the widget’s up/down arrows are used.\nconfirm requires a “const bool” (true or false) argument. This parameter affect the behavior of the script when it is added to a chart. input.*() calls using confirm = true will cause the “Settings/Inputs” tab to popup when the script is added to the chart. confirm is useful to ensure that users configure a particular field.\nThe minval, maxval and step parameters are only present in the signature of the input.int() and input.float() functions.\nInput types¶\nThe next sections explain what each input function does. As we proceed, we will explore the different ways you can use input functions and organize their display.\nSimple input¶\ninput() is a simple, generic function that supports the fundamental Pine Script™ types: “int”, “float”, “bool”, “color” and “string”. It also supports “source” inputs, which are price-related values such as close, hl2, hlc3, and hlcc4, or which can be used to receive the output value of another script.\nIts signature is:\ninput(defval, title, tooltip, inline, group) → input int/float/bool/color/string | series float\nThe function automatically detects the type of input by analyzing the type of the defval argument used in the function call. This script shows all the supported types and the qualified type returned by the function when used with defval arguments of different types:\nindicator(\"`input()`\", \"\", true)\na = input(1, \"input int\")\nb = input(1.0, \"input float\")\nc = input(true, \"input bool\")\nd = input(color.orange, \"input color\")\ne = input(\"1\", \"input string\")\nf = input(close, \"series float\")\nplot(na)\nInteger input¶\nTwo signatures exist for the input.int() function; one when options is not used, the other when it is:\ninput.int(defval, title, minval, maxval, step, tooltip, inline, group, confirm) → input int\ninput.int(defval, title, options, tooltip, inline, group, confirm) → input int\nThis call uses the options parameter to propose a pre-defined list of lengths for the MA:\nindicator(\"MA\", \"\", true)\nmaLengthInput = input.int(10, options = [3, 5, 7, 10, 14, 20, 50, 100, 200])\nma = ta.sma(close, maLengthInput)\nplot(ma)\nThis one uses the minval parameter to limit the length:\nindicator(\"MA\", \"\", true)\nmaLengthInput = input.int(10, minval = 2)\nma = ta.sma(close, maLengthInput)\nplot(ma)\nThe version with the options list uses a dropdown menu for its widget. When the options parameter is not used, a simple input widget is used to enter the value.\nFloat input¶\nTwo signatures exist for the input.float() function; one when options is not used, the other when it is:\ninput.int(defval, title, minval, maxval, step, tooltip, inline, group, confirm) → input int\ninput.int(defval, title, options, tooltip, inline, group, confirm) → input int\nHere, we use a “float” input for the factor used to multiple the standard deviation, to calculate Bollinger Bands:\nmaLengthInput = input.int(10, minval = 1)\nbbFactorInput = input.float(1.5, minval = 0, step = 0.5)\nma = ta.sma(close, maLengthInput)\nbbWidth = ta.stdev(ma, maLengthInput) * bbFactorInput\nbbHi = ma + bbWidth\nbbLo = ma - bbWidth\nplot(bbHi, \"BB Hi\", color.gray)\nplot(bbLo, \"BB Lo\", color.gray)\nThe input widgets for floats are similar to the ones used for integer inputs.\nBoolean input¶\nLet’s continue to develop our script further, this time by adding a boolean input to allow users to toggle the display of the BBs:\nmaLengthInput = input.int(10, \"MA length\", minval = 1)\nbbFactorInput = input.float(1.5, \"BB factor\", inline = \"01\", minval = 0, step = 0.5)\nshowBBInput = input.bool(true, \"Show BB\", inline = \"01\")\nma = ta.sma(close, maLengthInput)\nbbWidth = ta.stdev(ma, maLengthInput) * bbFactorInput\nbbHi = ma + bbWidth\nbbLo = ma - bbWidth\nplot(ma, \"MA\", color.aqua)\nplot(showBBInput ? bbHi : na, \"BB Hi\", color.gray)\nplot(showBBInput ? bbLo : na, \"BB Lo\", color.gray)\nWe have added an input using input.bool() to set the value of showBBInput.\nWe use the inline parameter in that input and in the one for bbFactorInput to bring them on the same line. We use \"01\" for its argument in both cases. That is how the Pine Script™ compiler recognizes that they belong on the same line. The particular string used as an argument is unimportant and does not appear anywhere in the “Inputs” tab; it is only used to identify which inputs go on the same line.\nWe have vertically aligned the title arguments of our input.*() calls to make them easier to read.\nWe use the showBBInput variable in our two plot() calls to plot conditionally. When the user unchecks the checkbox of the showBBInput input, the variable’s value becomes false. When that happens, our plot() calls plot the na value, which displays nothing. We use true as the default value of the input, so the BBs plot by default.\nBecause we use the inline parameter for the bbFactorInput variable, its input field in the “Inputs” tab does not align vertically with that of maLengthInput, which doesn’t use inline.\nColor input¶\nAs is explained in the Color selection through script settings section of the “Colors” page, the color selections that usually appear in the “Settings/Style” tab are not always available. When that is the case, script users will have no means to change the colors your script uses. For those cases, it is essential to provide color inputs if you want your script’s colors to be modifiable through the script’s “Settings”. Instead of using the “Settings/Style” tab to change colors, you will then allow your script users to change the colors using calls to input.color().\nSuppose we wanted to plot our BBs in a ligther shade when the high and low values are higher/lower than the BBs. You could use code like this to create your colors:\nbbHiColor = color.new(color.gray, high > bbHi ? 60 : 0)\nbbLoColor = color.new(color.gray, low < bbLo ? 60 : 0)\nWhen using dynamic (or “series”) color components like the transparency here, the color widgets in the “Settings/Style” will no longer appear. Let’s create our own, which will appear in our “Inputs” tab:\nmaLengthInput = input.int(10, \"MA length\", inline = \"01\", minval = 1)\nmaColorInput = input.color(color.aqua, \"\", inline = \"01\")\nbbFactorInput = input.float(1.5, \"BB factor\", inline = \"02\", minval = 0, step = 0.5)\nbbColorInput = input.color(color.gray, \"\", inline = \"02\")\nshowBBInput = input.bool(true, \"Show BB\", inline = \"02\")\nbbWidth = ta.stdev(ma, maLengthInput) * bbFactorInput\nbbHi = ma + bbWidth\nbbLo = ma - bbWidth\nbbHiColor = color.new(bbColorInput, high > bbHi ? 60 : 0)\nbbLoColor = color.new(bbColorInput, low < bbLo ? 60 : 0)\nplot(ma, \"MA\", maColorInput)\nplot(showBBInput ? bbHi : na, \"BB Hi\", bbHiColor, 2)\nplot(showBBInput ? bbLo : na, \"BB Lo\", bbLoColor, 2)\nWe have added two calls to input.color() to gather the values of the maColorInput and bbColorInput variables. We use maColorInput directly in the plot(ma, \"MA\", maColorInput) call, and we use bbColorInput to build the bbHiColor and bbLoColor variables, which modulate the transparency using the position of price relative to the BBs. We use a conditional value for the transp value we call color.new() with, to generate different transparencies of the same base color.\nWe do not use a title argument for our new color inputs because they are on the same line as other inputs allowing users to understand to which plots they apply.\nWe have reorganized our inline arguments so they reflect the fact we have inputs grouped on two distinct lines.\nTimeframe input¶\nTimeframe inputs can be useful when you want to be able to change the timeframe used to calculate values in your scripts.\nLet’s do away with our BBs from the previous sections and add a timeframe input to a simple MA script:\ntfInput = input.timeframe(\"D\", \"Timeframe\")\nma = ta.sma(close, 20)\nsecurityNoRepaint(sym, tf, src) =>\nrequest.security(sym, tf, src[barstate.isrealtime ? 1 : 0])[barstate.isrealtime ? 0 : 1]\nmaHTF = securityNoRepaint(syminfo.tickerid, tfInput, ma)\nplot(maHTF, \"MA\", color.aqua)\nWe use the input.timeframe() function to receive the timeframe input.\nThe function creates a dropdown widget where some standard timeframes are proposed. The list of timeframes also includes any you have favorated in the chart user interface.\nWe use the tfInput in our request.security() call. We also use gaps = barmerge.gaps_on in the call, so the function only returns data when the higher timeframe has completed.\nSymbol input¶\nThe input.symbol() function creates a widget that allows users to search and select symbols like they would from the chart’s user interface.\nLet’s add a symbol input to our script:\ntfInput = input.timeframe(\"D\", \"Timeframe\")\nsymbolInput = input.symbol(\"\", \"Symbol\")\nma = ta.sma(close, 20)\nsecurityNoRepaint(sym, tf, src) =>\nrequest.security(sym, tf, src[barstate.isrealtime ? 1 : 0])[barstate.isrealtime ? 0 : 1]\nmaHTF = securityNoRepaint(symbolInput, tfInput, ma)\nplot(maHTF, \"MA\", color.aqua)\nThe defval argument we use is an empty string. This causes request.security(), where we use the symbolInput variable containing that input, to use the chart’s symbol by default. If the user selects another symbol and wants to return to the default value using the chart’s symbol, he will need to use the “Reset Settings” selection from the “Inputs” tab’s “Defaults” menu.\nWe use the securityNoRepaint() user-defined function to use request.security() in such a way that it does not repaint; it only returns values when the higher timeframe has completed.\nSession input¶\nSession inputs are useful to gather start-stop values for periods of time. The input.session() built-in function creates an input widget allowing users to specify the beginning and end time of a session. Selections can be made using a dropdown menu, or by entering time values in “hh:mm” format.\nThe value returned by input.session() is a valid string in session format. See the manual’s page on sessions for more information.\nSession information can also contain information on the days where the session is valid. We use an input.string() function call here to input that day information:\nindicator(\"Session input\", \"\", true)\nstring sessionInput = input.session(\"0600-1700\", \"Session\")\nstring daysInput = input.string(\"1234567\", tooltip = \"1 = Sunday, 7 = Saturday\")\nsessionString = sessionInput + \":\" + daysInput\ninSession = not na(time(timeframe.period, sessionString))\nbgcolor(inSession ? color.silver : na)\nThis script proposes a default session of “0600-1700”.\nThe input.string() call uses a tooltip to provide users with help on the format to use to enter day information.\nA complete session string is built by concatenating the two strings the script receives as inputs.\nWe explicitly declare the type of our two inputs with the string keyword to make it clear those variables will contain a string.\nWe detect if the chart bar is in the user-defined session by calling time() with the session string. If the current bar’s time value (the time at the bar’s open) is not in the session, time() returns na, so inSession will be true whenever time() returns a value that is not na.\nSource input¶\nSource inputs are useful to provide a selection of two types of sources:\nPrice values, namely: open, high, low, close, hl2, hlc3, and ohlc4.\nThe values plotted by other scripts on the chart. This can be useful to “link” two or more scripts together by sending the output of one as an input to another script.\nThis script simply plots the user’s selection of source. We propose the high as the default value:\nindicator(\"Source input\", \"\", true)\nsrcInput = input.source(high, \"Source\")\nplot(srcInput, \"Src\", color.new(color.purple, 70), 6)\nThis shows a chart where, in addition to our script, we have loaded an “Arnaud Legoux Moving Average” indicator. See here how we use our script’s source input widget to select the output of the ALMA script as an input into our script. Because our script plots that source in a light-purple thick line, you see the plots from the two scripts overlap because they plot the same value:\nTime input¶\nTime inputs use the input.time() function. The function returns a Unix time in milliseconds (see the Time page for more information). This type of data also contains date information, so the input.time() function returns a time and a date. That is the reason why its widget allows for the selection of both.\nHere, we test the bar’s time against an input value, and we plot an arrow when it is greater:\nindicator(\"Time input\", \"T\", true)\ntimeAndDateInput = input.time(timestamp(\"1 Aug 2021 00:00 +0300\"), \"Date and time\")\nbarIsLater = time > timeAndDateInput\nplotchar(barIsLater, \"barIsLater\", \"🠆\", location.top, size = size.tiny)\nNote that the defval value we use is a call to the timestamp() function.\nOther features affecting Inputs¶\nSome parameters of the indicator() function, when used, will populate the script’s “Inputs” tab with a field. The parameters are timeframe and timeframe_gaps. An example:\nindicator(\"MA\", \"\", true, timeframe = \"D\", timeframe_gaps = false)\nplot(ta.vwma(close, 10))\nTips¶\nThe design of your script’s inputs has an important impact on the usability of your scripts. Well-designed inputs are more intuitively usable and make for a better user experience:\nChoose clear and concise labels (your input’s title argument).\nChoose your default values carefully.\nProvide minval and maxval values that will prevent your code from producing unexpected results, e.g., limit the minimal value of lengths to 1 or 2, depending on the type of MA you are using.\nProvide a step value that is congruent with the value you are capturing. Steps of 5 can be more useful on a 0-200 range, for example, or steps of 0.05 on a 0.0-1.0 scale.\nGroup related inputs on the same line using inline; bull and bear colors for example, or the width and color of a line.\nWhen you have many inputs, group them into meaningful sections using group. Place the most important sections at the top.\nDo the same for individual inputs within sections.\nIt can be advantageous to vertically align different arguments of multliple input.*() calls in your code. When you need to make global changes, this will allow you to use the Editor’s multi-cursor feature to operate on all the lines at once.\nBecause It is sometimes necessary to use Unicode spaces to In order to achieve optimal alignment in inputs. This is an example:\nindicator(\"Aligned inputs\", \"\", true)\nvar GRP1 = \"Not aligned\"\nma1SourceInput = input(close, \"MA source\", inline = \"11\", group = GRP1)\nma1LengthInput = input(close, \"Length\", inline = \"11\", group = GRP1)\nlong1SourceInput = input(close, \"Signal source\", inline = \"12\", group = GRP1)\nlong1LengthInput = input(close, \"Length\", inline = \"12\", group = GRP1)\nvar GRP2 = \"Aligned\"\n// The three spaces after \"MA source\" are Unicode EN spaces (U+2002).\nma2SourceInput = input(close, \"MA source \", inline = \"21\", group = GRP2)\nma2LengthInput = input(close, \"Length\", inline = \"21\", group = GRP2)\nlong2SourceInput = input(close, \"Signal source\", inline = \"22\", group = GRP2)\nlong2LengthInput = input(close, \"Length\", inline = \"22\", group = GRP2)\nplot(ta.vwma(close, 10))\nWe use the group parameter to distinguish between the two sections of inputs. We use a constant to hold the name of the groups. This way, if we decide to change the name of the group, we only need to change it in one place.\nThe first sections inputs widgets do not align vertically. We are using inline, which places the input widgets immediately to the right of the label. Because the labels for the ma1SourceInput and long1SourceInput inputs are of different lengths the labels are in different y positions.\nTo make up for the misalignment, we pad the title argument in the ma2SourceInput line with three Unicode EN spaces (U+2002). Unicode spaces are necessary because ordinary spaces would be stripped from the label. You can achieve precise alignment by combining different quantities and types of Unicode spaces. See here for a list of Unicode spaces of different widths."
},
{
  "text": "v4 to v5 converter\nRenamed functions and variables\nRenamed function parameters\nRemoved an `rsi()` overload\nReserved keywords\nRemoved `iff()` and `offset()`\nSplit of `input()` into several functions\nSome function parameters now require built-in arguments\nDeprecated the `transp` parameter\nChanged the default session days for `time()` and `time_close()`\n`strategy.exit()` now must do something\nCommon script conversion errors\nAll variable, function, and parameter name changes\nThis guide documents the changes made to Pine Script™ from v4 to v5. It will guide you in the adaptation of existing Pine scripts to Pine Script™ v5. See our Release notes for a list of the new features in Pine Script™ v5.\nThe most frequent adaptations required to convert older scripts to v5 are:\nChanging study() for indicator() (the function’s signature has not changed).\nRenaming built-in function calls to include their new namespace (e.g., highest() in v4 becomes ta.highest() in v5).\nRestructuring inputs to use the more specialized input.*() functions.\nEliminating uses of the deprecated transp parameter by using color.new() to simultaneously define color and transparency for use with the color parameter.\nIf you used the resolution and resolution_gaps parameters in v4’s study(), they will require changing to timeframe and timeframe_gaps in v5’s indicator().\nv4 to v5 converter¶\nThe Pine Editor includes a utility to automatically convert v4 scripts to v5. To access it, open a script with //@version=4 in it and select the “Convert to v5” option in the “More” menu identified by three dots at the top-right of the Editor’s pane:\nNot all scripts can be automatically converted from v4 to v5. If you want to convert the script manually or if your indicator returns a compilation error after conversion, use the following sections to determine how to complete the conversion. A list of some errors you can encounter during the automatic conversion and how to fix them can be found in the Common script conversion errors section of this guide.\nRenamed functions and variables¶\nFor clarity and consistency, many built-in functions and variables were renamed in v5. The inclusion of v4 function names in a new namespace is the cause of most changes. For example, the sma() function in v4 is moved to the ta. namespace in v5: ta.sma(). Remembering the new namespaces is not necessary; if you type the older name of a function without its namespace in the Editor and press the ‘Auto-complete’ hotkey (Ctrl + Space, or Cmd + Space on MacOS), a popup showing matching suggestions appears:\nNot counting functions moved to new namespaces, only two functions have been renamed:\nstudy() is now indicator().\ntickerid() is now ticker.new().\nThe full list of renamed functions and variables can be found in the All variable, function, and parameter name changes section of this guide.\nRenamed function parameters¶\nThe parameter names of some built-in functions were changed to improve the nomenclature. This has no bearing on most scripts, but if you used these parameter names when calling functions, they will require adaptation. For example, we have standardized all mentions:\n// Valid in v4. Not valid in v5.\ntimev4 = time(resolution = \"1D\")\n// Valid in v5.\ntimev5 = time(timeframe = \"1D\")\n// Valid in v4 and v5.\ntimeBoth = time(\"1D\")\nThe full list of renamed function parameters can be found in the All variable, function, and parameter name changes section of this guide.\nRemoved an `rsi()` overload¶\nIn v4, the rsi() function had two different overloads:\nrsi(series float, simple int) for the normal RSI calculation, and\nrsi(series float, series float) for an overload used in the MFI indicator, which did a calculation equivalent to 100.0 - (100.0 / (1.0 + arg1 / arg2)).\nThis caused a single built-in function to behave in two very different ways, and it was difficult to distinguish which one applied because it depended on the type of the second argument. As a result, a number of indicators misused the function and were displaying incorrect results. To avoid this, the second overload was removed in v5.\nThe ta.rsi() function in v5 only accepts a “simple int” argument for its length parameter. If your v4 code used the now deprecated overload of the function with a float second argument, you can replace the whole rsi() call with the following formula, which is equivalent:\n100.0 - (100.0 / (1.0 + arg1 / arg2))\nNote that when your v4 code used a “series int” value as the second argument to rsi(), it was automatically cast to “series float” and the second overload of the function was used. While this was syntactically correct, it most probably did not yield the result you expected. In v5, ta.rsi() requires a “simple int” for the argument to length, which precludes dynamic (or “series”) lengths. The reason for this is that RSI calculations use the ta.rma() moving average, which is similar to ta.ema() in that it relies on a length-dependent recursive process using the values of previous bars. This makes it impossible to achieve correct results with a “series” length that could vary bar to bar.\nIf your v4 code used a length that was “const int”, “input int” or “simple int”, no changes are required.\nReserved keywords¶\nA number of words are reserved and cannot be used for variable or function names. They are: catch, class, do, ellipse, in, is, polygon, range, return, struct, text, throw, try. If your v4 indicator uses any of these, rename your variable or function for the script to work in v5.\nRemoved `iff()` and `offset()`¶\nThe iff() and offset() functions have been removed. Code using the iff() function can be rewritten using the ternary operator:\n// iff(<condition>, <return_when_true>, <return_when_false>)\n// Valid in v4, not valid in v5\nbarColorIff = iff(close >= open, color.green, color.red)\n// <condition> ? <return_when_true> : <return_when_false>\n// Valid in v4 and v5\nbarColorTernary = close >= open ? color.green : color.red\nNote that the ternary operator is evaluated “lazily”; only the required value is calculated (depending on the condition’s evaluation to true or false). This is different from iff(), which always evaluated both values but returned only the relevant one.\nSome functions require evaluation on every bar to correctly calculate, so you will need to make special provisions for these by pre-evaluating them before the ternary:\n// `iff()` in v4: `highest()` and `lowest()` are calculated on every bar\nv1 = iff(close > open, highest(10), lowest(10))\nplot(v1)\n// In v5: forced evaluation on every bar prior to the ternary statement.\nh1 = ta.highest(10)\nl1 = ta.lowest(10)\nv1 = close > open ? h1 : l1\nplot(v1)\nThe offset() function was deprecated because the more readable [] operator is equivalent:\nprevClosev4 = offset(close, 1)\nprevClosev5 = close[1]\nSplit of `input()` into several functions¶\nThe v4 input() function was becoming crowded with a plethora of overloads and parameters. We split its functionality into different functions to clear that space and provide a more robust structure to accommodate the additions planned for inputs. Each new function uses the name of the input.* type of the v4 input() call it replaces. E.g., there is now a specialized input.float() function replacing the v4 input(1.0, type = input.float) call. Note that you can still use input(1.0) in v5, but because only input.float() allows for parameters such as minval, maxval, etc., it is more powerful. Also note that input.int() is the only specialized input function that does not use its equivalent v4 input.integer name. The input.* constants have been removed because they were used as arguments for the type parameter, which was deprecated.\nTo convert, for example, a v4 script using an input of type input.symbol, the input.symbol() function must be used in v5:\naaplTicker = input(\"AAPL\", type = input.symbol)\n// Valid in v5\naaplTicker = input.symbol(\"AAPL\")\nThe input() function persists in v5, but in a simpler form, with less parameters. It has the advantage of automatically detecting input types “bool/color/int/float/string/source” from the argument used for defval:\n// While \"AAPL\" is a valid symbol, it is only a string here because `input.symbol()` is not used.\ntickerString = input(\"AAPL\", title = \"Ticker string\")\nSome function parameters now require built-in arguments¶\nIn v4, built-in constants such as plot.style_area used as arguments when calling Pine Script™ functions corresponded to pre-defined values of a specific type. For example, the value of barmerge.lookahead_on was true, so you could use true instead of the named constant when supplying an argument to the lookahead parameter in a security() function call. We found this to be a common source of confusion, which caused unsuspecting programmers to produce code yielding unintended results.\nIn v5, the use of correct built-in named constants as arguments to function parameters requiring them is mandatory:\n// Not valid in v5: `true` is used as an argument for `lookahead`.\nrequest.security(syminfo.tickerid, \"1D\", close, lookahead = true)\n// Valid in v5: uses a named constant instead of `true`.\nrequest.security(syminfo.tickerid, \"1D\", close, lookahead = barmerge.lookahead_on)\n// Would compile in v4 because `plot.style_columns` was equal to 5.\n// Won't compile in v5.\na = 2 * plot.style_columns\nplot(a)\nTo convert your script from v4 to v5, make sure you use the correct named built-in constants as function arguments.\nDeprecated the `transp` parameter¶\nThe transp= parameter used in the signature of many v4 plotting functions was deprecated because it interfered with RGB functionality. Transparency must now be specified along with the color as an argument to parameters such as color, textcolor, etc. The color.new() or color.rgb() functions will be needed in those cases to join a color and its transparency.\nNote that in v4, the bgcolor() and fill() functions had an optional transp parameter that used a default value of 90. This meant that the code below could display Bollinger Bands with a semi-transparent fill between two bands and a semi-transparent backround color where bands cross price, even though no argument is used for the transp parameter in its bgcolor() and fill() calls:\nstudy(\"Bollinger Bands\", overlay = true)\n[middle, upper, lower] = bb(close, 5, 4)\nplot(middle, color=color.blue)\np1PlotID = plot(upper, color=color.green)\np2PlotID = plot(lower, color=color.green)\ncrossUp = crossover(high, upper)\ncrossDn = crossunder(low, lower)\n// Both `fill()` and `bgcolor()` have a default `transp` of 90\nfill(p1PlotID, p2PlotID, color = color.green)\nbgcolor(crossUp ? color.green : crossDn ? color.red : na)\nIn v5 we need to explictly mention the 90 transparency with the color, yielding:\nindicator(\"Bollinger Bands\", overlay = true)\n[middle, upper, lower] = ta.bb(close, 5, 4)\nplot(middle, color=color.blue)\np1PlotID = plot(upper, color=color.green)\np2PlotID = plot(lower, color=color.green)\ncrossUp = ta.crossover(high, upper)\ncrossDn = ta.crossunder(low, lower)\nvar TRANSP = 90\n// We use `color.new()` to explicitly pass transparency to both functions\nfill(p1PlotID, p2PlotID, color = color.new(color.green, TRANSP))\nbgcolor(crossUp ? color.new(color.green, TRANSP) : crossDn ? color.new(color.red, TRANSP) : na)\nChanged the default session days for `time()` and `time_close()`¶\nThe default set of days for session strings used in the time() and time_close() functions, and returned by input.session(), has changed from \"23456\" (Monday to Friday) to \"1234567\" (Sunday to Saturday):\n// On symbols that are traded during weekends, this will behave differently in v4 and v5.\nt0 = time(\"1D\", \"1000-1200\")\n// v5 equivalent of the behavior of `t0` in v4.\nt1 = time(\"1D\", \"1000-1200:23456\")\n// v5 equivalent of the behavior of `t0` in v5.\nt2 = time(\"1D\", \"1000-1200:1234567\")\nThis change in behavior should not have much impact on scripts running on conventional markets that are closed during weekends. If it is important for you to ensure your session definitions preserve their v4 behavior in v5 code, add \":23456\" to your session strings. See this manual’s page on Sessions for more information.\n`strategy.exit()` now must do something¶\nGone are the days when the strategy.exit() function was allowed to loiter. Now it must actually have an effect on the strategy by using at least one of the following parameters: profit, limit, loss, stop, or one of the following pairs: trail_offset combined with either trail_price or trail_points. When uses of strategy.exit() not meeting these criteria trigger an error while converting a strategy to v5, you can safely eliminate these lines, as they didn’t do anything in your code anyway.\nCommon script conversion errors¶\nInvalid argument ‘style’/’linestyle’ in ‘plot’/’hline’ call¶\nTo make this work, you need to change the “int” arguments used for the style and linestyle arguments in plot() and hline() for built-in constants:\n// Will cause an error during conversion\nplotStyle = input(1)\nhlineStyle = input(1)\nplot(close, style = plotStyle)\nhline(100, linestyle = hlineStyle)\n// Will work in v5\nplotStyleInput = input.string(\"Line\", options = [\"Line\", \"Stepline\", \"Histogram\", \"Cross\", \"Area\", \"Columns\", \"Circles\"])\nhlineStyleInput = input.string(\"Solid\", options = [\"Solid\", \"Dashed\", \"Dotted\"])\nplotStyle = plotStyleInput == \"Line\" ? plot.style_line :\nplotStyleInput == \"Stepline\" ? plot.style_stepline :\nplotStyleInput == \"Histogram\" ? plot.style_histogram :\nplotStyleInput == \"Cross\" ? plot.style_cross :\nplotStyleInput == \"Area\" ? plot.style_area :\nplotStyleInput == \"Columns\" ? plot.style_columns :\nplot.style_circles\nhlineStyle = hlineStyleInput == \"Solid\" ? hline.style_solid :\nhlineStyleInput == \"Dashed\" ? hline.style_dashed :\nhline.style_dotted\nplot(close, style = plotStyle)\nhline(100, linestyle = hlineStyle)\nSee the Some function parameters now require built-in arguments section of this guide for more information.\nUndeclated identifier ‘input.%input_name%’¶\nTo fix this issue, remove the input.* constants from your code:\n_integer = input.integer\n_bool = input.bool\ni1 = input(1, \"Integer\", _integer)\ni2 = input(true, \"Boolean\", _bool)\n// Will work in v5\ni1 = input.int(1, \"Integer\")\ni2 = input.bool(true, \"Boolean\")\nSee the User Manual’s page on Inputs, and the Some function parameters now require built-in arguments section of this guide for more information.\nInvalid argument ‘when’ in ‘strategy.close’ call¶\nThis is caused by a confusion between strategy.entry() and strategy.close().\nThe second parameter of strategy.close() is when, which expects a “bool” argument. In v4, it was allowed to use strategy.long an argument because it was a “bool”. With v5, however, named built-in constants must be used as arguments, so strategy.long is no longer allowed as an argument to the when parameter.\nThe strategy.close(\"Short\", strategy.long) call in this code is equivalent to strategy.close(\"Short\"), which is what must be used in v5:\nstrategy.close(\"Short\", strategy.long)\n// Will work in v5:\nstrategy.close(\"Short\")\nSee the Some function parameters now require built-in arguments section of this guide for more information.\nCannot call ‘input.int’ with argument ‘minval’=’%value%’. An argument of ‘literal float’ type was used but a ‘const int’ is expected¶\nIn v4, it was possible to pass a “float” argument to minval when an “int” value was being input. This is no longer possible in v5; “int” values are required for “int” inputs:\n// Works in v4, will break on conversion because minval is a 'float' value\nint_input = input(1, \"Integer\", input.integer, minval = 1.0)\n// Works in v5\nint_input = input.int(1, \"Integer\", minval = 1)\nSee the User Manual’s page on Inputs, and the Some function parameters now require built-in arguments section of this guide for more information.\nAll variable, function, and parameter name changes¶\nRemoved functions and variables¶\ninput.bool input\tReplaced by input.bool()\t\ninput.color input\tReplaced by input.color()\t\ninput.float input\tReplaced by input.float()\t\ninput.integer input\tReplaced by input.int()\t\ninput.resolution input\tReplaced by input.timeframe()\t\ninput.session input\tReplaced by input.session()\t\ninput.source input\tReplaced by input.source()\t\ninput.string input\tReplaced by input.string()\t\ninput.symbol input\tReplaced by input.symbol()\t\ninput.time input\tReplaced by input.time()\t\niff()\tUse the ?: operator instead\t\noffset()\tUse the [] operator instead\t\nRenamed functions and parameters¶\nNo namespace change¶\nstudy(<...>, resolution, resolution_gaps, <...>)\tindicator(<...>, timeframe, timeframe_gaps, <...>)\t\nstrategy.entry(long)\tstrategy.entry(direction)\t\nstrategy.order(long)\tstrategy.order(direction)\t\ntime(resolution)\ttime(timeframe)\t\ntime_close(resolution)\ttime_close(timeframe)\t\nnz(x, y)\tnz(source, replacement)\t\n“ta” namespace for technical analysis functions and variables¶\nIndicator functions and variables\t\naccdist\tta.accdist\t\nalma()\tta.alma()\t\natr()\tta.atr()\t\nbb()\tta.bb()\t\nbbw()\tta.bbw()\t\ncci()\tta.cci()\t\ncmo()\tta.cmo()\t\ncog()\tta.cog()\t\ndmi()\tta.dmi()\t\nema()\tta.ema()\t\nhma()\tta.hma()\t\niii\tta.iii\t\nkc()\tta.kc()\t\nkcw()\tta.kcw()\t\nlinreg()\tta.linreg()\t\nmacd()\tta.macd()\t\nmfi()\tta.mfi()\t\nmom()\tta.mom()\t\nnvi\tta.nvi\t\nobv\tta.obv\t\npvi\tta.pvi\t\npvt\tta.pvt\t\nrma()\tta.rma()\t\nroc()\tta.roc()\t\nrsi(x, y)\tta.rsi(source, length)\t\nsar()\tta.sar()\t\nsma()\tta.sma()\t\nstoch()\tta.stoch()\t\nsupertrend()\tta.supertrend()\t\nswma(x)\tta.swma(source)\t\ntr\tta.tr\t\ntr()\tta.tr()\t\ntsi()\tta.tsi()\t\nvwap\tta.vwap\t\nvwap(x)\tta.vwap(source)\t\nvwma()\tta.vwma()\t\nwad\tta.wad\t\nwma()\tta.wma()\t\nwpr()\tta.wpr()\t\nwvad\tta.wvad\t\nSupporting functions\t\nbarsince()\tta.barsince()\t\nchange()\tta.change()\t\ncorrelation(source_a, source_b, length)\tta.correlation(source1, source2, length)\t\ncross(x, y)\tta.cross(source1, source2)\t\ncrossover(x, y)\tta.crossover(source1, source2)\t\ncrossunder(x, y)\tta.crossunder(source1, source2)\t\ncum(x)\tta.cum(source)\t\ndev()\tta.dev()\t\nfalling()\tta.falling()\t\nhighest()\tta.highest()\t\nhighestbars()\tta.highestbars()\t\nlowest()\tta.lowest()\t\nlowestbars()\tta.lowestbars()\t\nmedian()\tta.median()\t\nmode()\tta.mode()\t\npercentile_linear_interpolation()\tta.percentile_linear_interpolation()\t\npercentile_nearest_rank()\tta.percentile_nearest_rank()\t\npercentrank()\tta.percentrank()\t\npivothigh()\tta.pivothigh()\t\npivotlow()\tta.pivotlow()\t\nrange()\tta.range()\t\nrising()\tta.rising()\t\nstdev()\tta.stdev()\t\nvaluewhen()\tta.valuewhen()\t\nvariance()\tta.variance()\t\n“request” namespace for functions that request external data¶\nfinancial()\trequest.financial()\t\nquandl()\trequest.quandl()\t\nsecurity(<...>, resolution, <...>)\trequest.security(<...>, timeframe, <...>)\t\nsplits()\trequest.splits()\t\ndividends()\trequest.dividends()\t\nearnings()\trequest.earnings()\t\n“ticker” namespace for functions that help create tickers¶\nheikinashi()\tticker.heikinashi()\t\nkagi()\tticker.kagi()\t\nlinebreak()\tticker.linebreak()\t\npointfigure()\tticker.pointfigure()\t\nrenko()\tticker.renko()\t\ntickerid()\tticker.new()\t\n“str” namespace for functions that manipulate strings¶\ntostring(x, y)\tstr.tostring(value, format)\t\ntonumber(x)\tstr.tonumber(string)"
},
{
  "text": "We define repainting as: script behavior causing historical vs realtime calculations or plots to behave differently.\nRepainting behavior is widespread and many factors can cause it. Following our definition, our estimate is that more than 95% of indicators in existence exhibit some form of repainting behavior. Commony used indicators such as MACD and RSI, for example, show confirmed values on historical bars, but will fluctuate on a realtime, unconfirmed chart bar until it closes. Therefore, they behave differently in historical and realtime states.\nNot all repainting behavior is inherently useless or misleading, nor does such behavior prevent knowledgeable traders from using indicators with such behavior. For example, who would think of discrediting a volume profile indicator solely because it updates its values on realtime bars?\nOne may encounter any of the following forms of repainting in the scripts they use, depending on what a script’s calculations entail:\nWidespread but often acceptable: A script may use values that update with realtime price changes on the unconfirmed bar. For example, if one uses the close variable in calculations performed on an open chart bar, its values will reflect the most recent price in the bar. However, the script will only commit a new data point to its historical series once the bar closes. Another common case is using request.security() to fetch higher-timeframe data on realtime bars, as explained in the Historical and realtime behavior section of the Other timeframes and data page. As with the unconfirmed chart bar in the chart’s timeframe, request.security() can track unconfirmed values from a higher-timeframe context on realtime bars, which can lead to repainting after the script restarts its execution. There is often nothing wrong with using such scripts, provided you understand how they work. When electing to use such scripts to issue alerts or trade orders, however, it’s important to understand the difference between their realtime and historical behavior and decide for yourself whether it provides utility for your needs.\nPotentially misleading: Scripts that plot values into the past, calculate results on realtime bars that one cannot replicate on historical bars, or relocate past events are potentially misleading. For example, Ichimoku, most scripts based on pivots, most strategies using calc_on_every_tick = true, scripts using request.security() when it behaves differently on realtime bars, many scripts using varip, many scripts using timenow, and some scripts that use barstate.* variables can exhibit misleading repainting behavior.\nUnacceptable: Scripts that leak future information into the past, strategies that execute on non-standard charts, and scripts using realtime intrabars to generate alerts or orders, are examples that can produce heavily misleading repainting behavior.\nUnavoidable: Revisions of the data feed from a provider and variations in the starting bar of the chart’s history can cause repainting behavior that may be unavoidable in a script.\nThe first two types of repainting can be perfectly acceptable if:\nYou are aware of the behavior.\nYou can live with it, or\nYou can circumvent it.\nIt should now be clear that not all repainting behavior is wrong and requires avoiding at all costs. In many situations, some forms of repainting may be exactly what a script needs. What’s important is to know when repainting behavior is not acceptable for one’s needs. To avoid repainting that’s not acceptable, it’s important to understand how a tool works or how you should design the tools you build. If you publish scripts, ensure you mention any potentially misleading behavior along with the other limitations of your script in the publication’s description.\nFor script users¶\nOne can decide to use repainting indicators if they understand the behavior, and whether that behavior meets their analysis requirements. Don’t be one of those newcomers who slap “repaint” sentences on published scripts in an attempt to discredit them, as doing so reveals a lack of foundational knowledge on the subject.\nSimply asking whether a script repaints is relatively meaningless, given that there are forms of repainting behavior that are perfectly acceptable in a script. Therefore, such a question will not beget a meaningful answer. One should instead ask specific questions about a script’s potential repainting behavior, such as:\nDoes the script calculate/display in the same way on historical and realtime bars?\nDo alerts from the script wait for the end of a realtime bar before triggering?\nDo signal markers shown by the script wait for the end of a realtime bar before showing?\nDoes the script plot/draw values into the past?\nDoes the strategy use calc_on_every_tick = true?\nDo the script’s request.security() calls leak future information into the past on historical bars?\nWhat’s important is that you understand how the tools you use work, and whether their behavior is compatible with your objectives, repainting or not. As you will learn if you read this page, repainting is a complex matter. It has many faces and many causes. Even if you don’t program in Pine Script™, this page will help you understand the array of causes that can lead to repainting, and hopefully enable more meaningful discussions with script authors.\nFor Pine Script™ programmers¶\nAs discussed above, not all forms of repainting behavior must be avoided at all costs, nor is all potential repainting behavior necessarily avoidable. We hope this page helps you better understand the dynamics at play so that you can design your trading tools with these behaviors in mind. This page’s content should help make you aware of common coding mistakes that produce misleading repainting results.\nWhatever your design decisions are, if you publish your script, explain the script to traders so they can understand how it behaves.\nThis page covers three broad categories of repainting causes:\nHistorical vs realtime calculations\nPlotting in the past\nDataset variations\nHistorical vs realtime calculations¶\nFluid data values¶\nHistorical data does not include records of intermediary price movements on bars; only open, high, low and close values (OHLC).\nOn realtime bars (bars running when the instrument’s market is open), however, the high, low and close values are not fixed; they can change values many times before the realtime bar closes and its HLC values are fixed. They are fluid. This leads to a script sometimes working differently on historical data and in real time, where only the open price will not change during the bar.\nAny script using values like high, low and close in realtime is subject to producing calculations that may not be repeatable on historical bars — thus repaint.\nLet’s look at this simple script. It detects crosses of the close value (in the realtime bar, this corresponds to the current price of the instrument) over and under an EMA:\nxUp = ta.crossover(close, ma)\nxDn = ta.crossunder(close, ma)\nThe script uses bgcolor() to color the background green when close crosses over the EMA, and red on crosses under the EMA.\nThe screen snapshot shows the script in realtime on a 30sec chart. A cross over the EMA has been detected, thus the background of the realtime bar is green.\nThe problem here is that nothing guarantees this condition will hold true until the end of the realtime bar. The arrow points to the timer showing that 21 seconds remain in the realtime bar, and anything could happen until then.\nWe are witnessing a repainting script.\nTo prevent this repainting, we must rewrite our script so that it does not use values that fluctuate during the realtime bar. This will require using values from a bar that has elapsed (typically the preceding bar), or the open price, which does not vary in realtime.\nWe can achieve this in many ways. This method adds a and barstate.isconfirmed condition to our cross detections, which requires the script to be executing on the bar’s last iteration, when it closes and prices are confirmed. It is a simple way to avoid repainting:\nxUp = ta.crossover(close, ma) and barstate.isconfirmed\nxDn = ta.crossunder(close, ma) and barstate.isconfirmed\nThis uses the crosses detected on the previous bar:\nxUp = ta.crossover(close, ma)[1]\nxDn = ta.crossunder(close, ma)[1]\nThis uses only confirmed close and EMA values for its calculations:\nma = ta.ema(close[1], 5)\nxUp = ta.crossover(close[1], ma)\nxDn = ta.crossunder(close[1], ma)\nThis detects crosses between the realtime bar’s open and the value of the EMA from the previous bars. Notice that the EMA is calculated using close, so it repaints. We must ensure we use a confirmed value to detect crosses, thus ma[1] in the cross detection logic:\nxUp = ta.crossover(open, ma[1])\nxDn = ta.crossunder(open, ma[1])\nAll these methods have one thing in common: while they prevent repainting, they will also trigger signals later than repainting scripts. This is an inevitable compromise if one wants to avoid repainting. You can’t have your cake and eat it too.\nRepainting `request.security()` calls¶\nThe request.security() function behaves differently on historical and realtime bars. On historical bars, it only returns confirmed values from its requested context, wheras it can return unconfirmed values on realtime bars. When the script restarts its execution, the bars that had a realtime state become historical bars, and will therefore only contain the values it confirmed on those bars. If the values returned by request.security() fluctuate on realtime bars without confirmation from the context, the script will repaint them when it restarts its execution. See the Historical and realtime behavior section of the Other timeframes and data page for a detailed explanation.\nOne can ensure higher-timeframe data requests only return confirmed values on all bars, regardless of bar state, by offsetting the expression argument by at least one bar with the history-referencing operator [] and using barmerge.lookahead_on for the lookahead argument in the request.security() call, as explained here.\nThe script below demonstrates the difference between repainting and non-repainting HTF data requests. It contains two request.security() calls. The first function call requests close data from the higherTimeframe without additional specification, and the second call requests the same series with an offset and barmerge.lookahead_on.\nAs we see on all realtime bars (the ones with an orange background), the repaintingClose contains values that fluctuate without confirmation from the higherTimeframe, meaning it will repaint when the script restarts its execution. The nonRepaintingClose, on the other hand, behaves the same on realtime and historical bars, i.e., it only changes its value when new, confirmed data is available:\nindicator(\"Repainting vs non-repainting `request.security()` demo\", overlay = true)\n//@variable The timeframe to request data from.\nstring higherTimeframe = input.timeframe(\"30\", \"Timeframe\")\nif timeframe.in_seconds() > timeframe.in_seconds(higherTimeframe)\nruntime.error(\"The 'Timeframe' input is smaller than the chart's timeframe. Choose a higher timeframe.\")\n//@variable The current `close` requested from the `higherTimeframe`. Fluctuates without confirmation on realtime bars.\nfloat repaintingClose = request.security(syminfo.tickerid, higherTimeframe, close)\n//@variable The last confirmed `close` requested from the `higherTimeframe`.\n// Behaves the same on historical and realtime bars.\nfloat nonRepaintingClose = request.security(\nsyminfo.tickerid, higherTimeframe, close[1], lookahead = barmerge.lookahead_on\nplot(repaintingClose, \"Repainting close\", color.new(color.purple, 50), 8)\nplot(nonRepaintingClose, \"Non-repainting close\", color.teal, 3)\n// Plot a shape when a new `higherTimeframe` starts.\nplotshape(timeframe.change(higherTimeframe), \"Timeframe change marker\", shape.square, location.top, size = size.small)\n// Color the background on realtime bars.\nbgcolor(barstate.isrealtime ? color.new(color.orange, 60) : na, title = \"Realtime bar highlight\")\nWe used the plotshape() function to mark the chart when there’s a change on the higherTimeframe.\nThis script produces a runtime error if the higherTimeframe is lower than the chart’s timeframe.\nOn historical bars, the repaintingClose has a new value at the end of each timeframe, and the nonRepaintingClose has a new value at the start of each timeframe.\nFor the sake of easy reusability, below is a simple a noRepaintSecurity() function that one can apply in their scripts to request non-repainting higher-timeframe values:\n//@function Requests non-repainting `expression` values from the context of the `symbol` and `timeframe`.\nnoRepaintSecurity(symbol, timeframe, expression) =>\nrequest.security(symbol, timeframe, expression[1], lookahead = barmerge.lookahead_on)\nThe [1] offset to the series and the use of lookahead = barmerge.lookahead_on are interdependent. One cannot be removed without compromising the integrity of the function.\nUnlike a plain request.security() call, this wrapper function cannot accept tuple expression arguments. For multi-element use cases, one can pass a user-defined type whose fields contain the desired elements to request.\nUsing `request.security()` at lower timeframes¶\nSome scripts use request.security() to request data from a timeframe lower than the chart’s timeframe. This can be useful when functions specifically designed to handle intrabars at lower timeframes are sent down the timeframe. When this type of user-defined function requires the detection of the intrabars’ first bar, as most do, the technique will only work on historical bars. This is due to the fact that realtime intrabars are not yet sorted. The impact of this is that such scripts cannot reproduce in real time their behavior on historical bars. Any logic generating alerts, for example, will be flawed, and constant refreshing will be required to recalculate elapsed realtime bars as historical bars.\nWhen used at lower timeframes than the chart’s without specialized functions able to distinguish between intrabars, request.security() will only return the value of the last intrabar in the dilation of the chart’s bar, which is usually not useful, and will also not reproduce in real time, so lead to repainting.\nFor all these reasons, unless you understand the subtleties of using request.security() at lower timeframes than the chart’s, it is best to avoid using the function at those timeframes. Higher-quality scripts will have logic to detect such anomalies and prevent the display of results which would be invalid when a lower timeframe is used.\nFor more reliable lower-timeframe data requests, use request.security_lower_tf(), as explained in this section of the Other timeframes and data page.\nFuture leak with `request.security()`¶\nWhen request.security() is used with lookahead = barmerge.lookahead_on to fetch prices without offsetting the series by [1], it will return data from the future on historical bars, which is dangerously misleading.\nWhile historical bars will magically display future prices before they should be known, no lookahead is possible in realtime because the future there is unknown, as it should, so no future bars exist.\nThis is an example:\n// FUTURE LEAK! DO NOT USE!\nindicator(\"Future leak\", \"\", true)\nfutureHigh = request.security(syminfo.tickerid, \"1D\", high, lookahead = barmerge.lookahead_on)\nplot(futureHigh)\nNote how the higher timeframe line is showing the timeframe’s high value before it occurs. The solution to avoid this effect is to use the function as demonstrated in this section.\nUsing lookahead to produce misleading results is not allowed in script publications, as explained in the lookahead section of the Other timeframes and data page. Script publications that use this misleading technique will be moderated.\n`varip`¶\nScripts using the varip declaration mode for variables (see our section on varip for more information) save information across realtime updates, which cannot be reproduced on historical bars where only OHLC information is available. Such scripts may be useful in realtime, including to generate alerts, but their logic cannot be backtested, nor can their plots on historical bars reflect calculations that will be done in realtime.\nBar state built-ins¶\nScripts using bar states may or may not repaint. As we have seen in the previous section, using barstate.isconfirmed is actually one way to avoid repainting that will reproduce on historical bars, which are always “confirmed”. Uses of other bar states such as barstate.isnew, however, will lead to repainting. The reason is that on historical bars, barstate.isnew is true on the bar’s close, yet in realtime, it is true on the bar’s open. Using the other bar state variables will usually cause some type of behavioral discrepancy between historical and realtime bars.\n`timenow`¶\nThe timenow built-in returns the current time. Scripts using this variable cannot show consistent historical and realtime behavior, so they necessarily repaint.\nStrategies¶\nStrategies using calc_on_every_tick = true execute on each realtime update, while strategies run on the close of historical bars. They will most probably not generate the same order executions, and so repaint. Note that when this happens, it also invalidates backtesting results, as they are not representative of the strategy’s behavior in realtime.\nPlotting in the past¶\nScripts detecting pivots after 5 bars have elapsed will often go back in the past to plot pivot levels or values on the actual pivot, 5 bars in the past. This will often cause unsuspecting traders looking at plots on historical bars to infer that when the pivot happens in realtime, the same plots will apppear on the pivot when it occurs, as opposed to when it is detected.\nLet’s look at a script showing the price of high pivots by placing the price in the past, 5 bars after the pivot was detected:\nindicator(\"Plotting in the past\", \"\", true)\npHi = ta.pivothigh(5, 5)\nif not na(pHi)\nlabel.new(bar_index[5], na, str.tostring(pHi, format.mintick) + \"\\n🠇\", yloc = yloc.abovebar, style = label.style_none, textcolor = color.black, size = size.normal)\nThis script repaints because an elapsed realtime bar showing no price may get a price placed on it if it is identified as a pivot, 5 bars after the actual pivot occurs.\nThe display looks great, but it can be misleading.\nThe best solution to this problem when developing script for others is to plot without an offset by default, but give the option for script users to turn on plotting in the past through inputs, so they are necessarily aware of what the script is doing, e.g.:\nindicator(\"Plotting in the past\", \"\", true)\nplotInThePast = input(false, \"Plot in the past\")\npHi = ta.pivothigh(5, 5)\nlabel.new(bar_index[plotInThePast ? 5 : 0], na, str.tostring(pHi, format.mintick) + \"\\n🠇\", yloc = yloc.abovebar, style = label.style_none, textcolor = color.black, size = size.normal)\nDataset variations¶\nStarting points¶\nScripts begin executing on the chart’s first historical bar, and then execute on each bar sequentially, as is explained in this manual’s page on Pine Script™’s execution model. If the first bar changes, then the script will often not calculate the same way it did when the dataset began at a different point in time.\nThe following factors have an impact on the quantity of bars you see on your charts, and their starting point:\nThe type of account you hold\nThe historical data available from the data supplier\nThe alignment requirements of the dataset, which determine its starting point\nThese are the account-specific bar limits:\n20000 historical bars for the Premium plan.\n10000 historical bars for Pro and Pro+ plans.\n5000 historical bars for other plans.\nStarting points are determined using the following rules, which depend on the chart’s timeframe:\n1, 5, 10, 15, 30 seconds: aligns to the beginning of a day.\n1 - 14 minutes: aligns to the beginning of a week.\n15 - 29 minutes: aligns to the beginning of a month.\n30 - 1439 minutes: aligns to the beginning of a year.\n1440 minutes and higher: aligns to the first available historical data point.\nAs time goes by, these factors cause your chart’s history to start at different points in time. This often has an impact on your scripts calculations, because changes in calculation results in early bars can ripple through all the other bars in the dataset. Using functions like ta.valuewhen(), ta.barssince() or ta.ema(), for example, will yield results that vary with early history.\nRevision of historical data¶\nHistorical and realtime bars are built using two different data feeds supplied by exchanges/brokers: historical data, and realtime data. When realtime bars elapse, exchanges/brokers sometimes make what are usually small adjustments to bar prices, which are then written to their historical data. When the chart is refreshed or the script is re-executed on those elapsed realtime bars, they will then be built and calculated using the historical data, which will contain those usually small price revisions, if any have been made.\nHistorical data may also be revised for other reasons, e.g., for stock splits."
},
{
  "text": "Declaration statements¶\n`indicator()`\n`strategy()`\n`library()`\n`indicator()`¶\nEvery indicator [1] script must contain one call to the indicator function, which has the following signature:\nindicator(title, shorttitle, overlay, format, precision, scale, max_bars_back, timeframe, timeframe_gaps, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count)\nThe indicator function determines the indicator’s general properties. The most important arguments of the indicator function are described below, a full overview of all indicator()` parameters can be found in its Reference Manual entry.\nOnly the title parameter is mandatory. It defines the name of the indicator. This name will be used in the Indicators dialog box and is independent of the name used to save the script in your Personal Library.\nshorttitle is the short name of the indicator displayed on the chart, if it must be different than the value of title.\noverlay is a “bool” parameter. If it is true then the study will be added as an overlay on top of the main chart. If it is false then it will be added in a separate pane. False is the default setting. Note that if you change the parameter’s value in a script that is already on a chart, you need to use the Add to Chart button to apply the change.\nformat defines the type of formatting used for study values appearing on the price axis, in indicator values or in the Data Window. Possible values are: format.inherit, format.price and format.volume. The default is format.inherit, which uses the format settings from the chart, unless precision = is also used, in which case it will override the effect of format.inherit. When format.price is used, the default precision will be “2”, unless one is specified using precision =. When format.volume is used, the format is equivalent to precision = 0 used in earlier versions of Pine Script™, where “5183” becomes “5.183K”.\nprecision is the number of digits after the floating point used to format study values. It must be a non-negative integer and not greater than 16. If omitted, then formatting from the parent series on the chart will be used. If the format is format.inherit and the precision parameter is used with a value, then the study will not inherit formatting from the chart’s settings and the value specified will be used instead, as if format = format.price had been used.\n`strategy()`¶\n`library()`¶\nFootnote"
}]