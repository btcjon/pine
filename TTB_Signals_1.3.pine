//@thetradingbot
//@version=5
indicator(title='TTB Signals 1.3', overlay=true, shorttitle='TTB Signals 1.3', max_bars_back = 4900)

import thetradingbot/TTB_TableBuilder/1 as TTBTableBuilder
import jdehorty/MLExtensions/2 as ml
import jdehorty/KernelFunctions/2 as kernels

//main colors
color bullish = #00a2ff
color bullish2 = #00a2ffa5
color bullish3 = #00a2ff1f
color bearish = #C70A80ff
color bearish2 = color.rgb(238, 2, 147, 34)
color bearish3 = color.rgb(199, 10, 126, 88)

// f_security function for MTF
f_security(_sym, _res, _src, _rep) =>
    request.security(_sym, _res, _src[not _rep and barstate.isrealtime ? 1 : 0])[_rep or barstate.isrealtime ? 0 : 1]
var bool i_repaint = false // Set to false to avoid repainting
var string ticker = syminfo.tickerid

HTF1 = input.int(30, title='HTF1')
HTF_Factor = input.int(2, title='ATRP Length', minval=1)
HTF2 = HTF1 * HTF_Factor
HTF3 = HTF1 * HTF_Factor

// Convert integer timeframes to string
HTF1_str = str.tostring(HTF1)
HTF2_str = str.tostring(HTF2)
HTF3_str = str.tostring(HTF3)







// lorentzian start

type Settings
    float source
    int neighborsCount
    int maxBarsBack
    int featureCount
    int colorCompression
    bool showExits
    bool useDynamicExits

type Label
    int long
    int short
    int neutral

type FeatureArrays
    array<float> f1
    array<float> f2
    array<float> f3
    array<float> f4
    array<float> f5

type FeatureSeries
    float f1
    float f2
    float f3
    float f4
    float f5

type MLModel
    int firstBarIndex
    array<int> trainingLabels
    int loopSize
    float lastDistance
    array<float> distancesArray
    array<int> predictionsArray
    int prediction

type FilterSettings 
    bool useVolatilityFilter
    bool useRegimeFilter
    bool useAdxFilter
    float regimeThreshold
    int adxThreshold

type Filter
    bool volatility
    bool regime
    bool adx 

// ==========================
// ==== Helper Functions ====
// ==========================

series_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, f_paramA, f_paramB)
        "WT" => ml.n_wt(_hlc3, f_paramA, f_paramB)
        "CCI" => ml.n_cci(_close, f_paramA, f_paramB)
        "ADX" => ml.n_adx(_high, _low, _close, f_paramA)

get_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays featureArrays) =>
    switch featureCount
        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + 
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + 
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + 
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i))) + 
             math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)))
        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) +
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)))
        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)))
        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)))

// ================  
// ==== Inputs ==== 
// ================ 

// Settings Object: General User-Defined Inputs
Settings settings = 
 Settings.new(
   input.source(title='Source', defval=close, group="General Settings", tooltip="Source of the input data"),
   input.int(title='Neighbors Count', defval=8, group="General Settings", minval=1, maxval=100, step=1, tooltip="Number of neighbors to consider"),
   input.int(title="Max Bars Back", defval=2000, group="General Settings"),
   input.int(title="Feature Count", defval=5, group="Feature Engineering", minval=2, maxval=5, tooltip="Number of features to use for ML predictions."),
   input.int(title="Color Compression", defval=1, group="General Settings", minval=1, maxval=10, tooltip="Compression factor for adjusting the intensity of the color scale."),
   input.bool(title="Show Default Exits", defval=false, group="General Settings", tooltip="Default exits occur exactly 4 bars after an entry signal. This corresponds to the predefined length of a trade during the model's training process.", inline="exits"),
   input.bool(title="Use Dynamic Exits", defval=true, group="General Settings", tooltip="Dynamic exits attempt to let profits ride by dynamically adjusting the exit threshold based on kernel regression logic.", inline="exits")
 )
   
// Trade Stats Settings
// Note: The trade stats section is NOT intended to be used as a replacement for proper backtesting. It is intended to be used for calibration purposes only.
showTradeStats = input.bool(true, 'Show Trade Stats', tooltip='Displays the trade stats for a given configuration. Useful for optimizing the settings in the Feature Engineering section. This should NOT replace backtesting and should be used for calibration purposes only. Early Signal Flips represent instances where the model changes signals before 4 bars elapses; high values can indicate choppy (ranging) market conditions.', group="General Settings")
useWorstCase = input.bool(false, "Use Worst Case Estimates", tooltip="Whether to use the worst case scenario for backtesting. This option can be useful for creating a conservative estimate that is based on close prices only, thus avoiding the effects of intrabar repainting. This option assumes that the user does not enter when the signal first appears and instead waits for the bar to close as confirmation. On larger timeframes, this can mean entering after a large move has already occurred. Leaving this option disabled is generally better for those that use this indicator as a source of confluence and prefer estimates that demonstrate discretionary mid-bar entries. Leaving this option enabled may be more consistent with traditional backtesting results.", group="General Settings")

// Settings object for user-defined settings
FilterSettings filterSettings =
 FilterSettings.new(
   input.bool(title="Use Volatility Filter", defval=true, tooltip="Whether to use the volatility filter.", group="Filters"),
   input.bool(title="Use Regime Filter", defval=true, group="Filters", inline="regime"),
   input.bool(title="Use ADX Filter", defval=false, group="Filters", inline="adx"),
   input.float(title="Threshold", defval=0.2, minval=-10, maxval=10, step=0.1, tooltip="Whether to use the trend detection filter. Threshold for detecting Trending/Ranging markets.", group="Filters", inline="regime"),
   input.int(title="Threshold", defval=20, minval=0, maxval=100, step=1, tooltip="Whether to use the ADX filter. Threshold for detecting Trending/Ranging markets.", group="Filters", inline="adx")
 )

// Filter object for filtering the ML predictions
Filter filter =
 Filter.new(
   ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter), 
   ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter),
   ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.useAdxFilter)
  )

// Feature Variables: User-Defined Inputs for calculating Feature Series. 
f1_string = input.string(title="Feature 1", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "01", tooltip="The first feature to use for ML predictions.", group="Feature Engineering")
f1_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 1.", defval=14, inline = "02", group="Feature Engineering")
f1_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=1, inline = "02", group="Feature Engineering")
f2_string = input.string(title="Feature 2", options=["RSI", "WT", "CCI", "ADX"], defval="WT", inline = "03", tooltip="The second feature to use for ML predictions.", group="Feature Engineering")
f2_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 2.", defval=10, inline = "04", group="Feature Engineering")
f2_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=11, inline = "04", group="Feature Engineering")
f3_string = input.string(title="Feature 3", options=["RSI", "WT", "CCI", "ADX"], defval="CCI", inline = "05", tooltip="The third feature to use for ML predictions.", group="Feature Engineering")
f3_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 3.", defval=20, inline = "06", group="Feature Engineering")
f3_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 3 (if applicable).", defval=1, inline = "06", group="Feature Engineering")
f4_string = input.string(title="Feature 4", options=["RSI", "WT", "CCI", "ADX"], defval="ADX", inline = "07", tooltip="The fourth feature to use for ML predictions.", group="Feature Engineering")
f4_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 4.", defval=20, inline = "08", group="Feature Engineering")
f4_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 4 (if applicable).", defval=2, inline = "08", group="Feature Engineering")
f5_string = input.string(title="Feature 5", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "09", tooltip="The fifth feature to use for ML predictions.", group="Feature Engineering")
f5_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 5.", defval=9, inline = "10", group="Feature Engineering")
f5_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 5 (if applicable).", defval=1, inline = "10", group="Feature Engineering")

// FeatureSeries Object: Calculated Feature Series based on Feature Variables
featureSeries = 
 FeatureSeries.new(
   series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB), // f1
   series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB), // f2 
   series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB), // f3
   series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB), // f4
   series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)  // f5
 )

// FeatureArrays Variables: Storage of Feature Series as Feature Arrays Optimized for ML
// Note: These arrays cannot be dynamically created within the FeatureArrays Object Initialization and thus must be set-up in advance.
var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()
array.push(f1Array, featureSeries.f1)
array.push(f2Array, featureSeries.f2)
array.push(f3Array, featureSeries.f3)
array.push(f4Array, featureSeries.f4)
array.push(f5Array, featureSeries.f5)

// FeatureArrays Object: Storage of the calculated FeatureArrays into a single object
featureArrays = 
 FeatureArrays.new(
  f1Array, // f1
  f2Array, // f2
  f3Array, // f3
  f4Array, // f4
  f5Array  // f5
 )

// Label Object: Used for classifying historical data as training data for the ML Model
Label direction = 
 Label.new(
   long=1, 
   short=-1, 
   neutral=0
  )

// Derived from General Settings
maxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings.maxBarsBack : 0

// EMA Settings 
useEmaFilter = input.bool(title="Use EMA Filter", defval=false, group="Filters", inline="ema")
emaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="ema", tooltip="The period of the EMA used for the EMA Filter.")
isEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true
isEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true
useSmaFilter = input.bool(title="Use SMA Filter", defval=false, group="Filters", inline="sma")
smaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="sma", tooltip="The period of the SMA used for the SMA Filter.")
isSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true
isSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true

// Nadaraya-Watson Kernel Regression Settings
useKernelFilter = input.bool(true, "Trade with Kernel", group="Kernel Settings", inline="kernel")
showKernelEstimate = input.bool(false, "Show Kernel Estimate", group="Kernel Settings", inline="kernel")
useKernelSmoothing = input.bool(false, "Enhance Kernel Smoothing", tooltip="Uses a crossover based mechanism to smoothen kernel color changes. This often results in less color transitions overall and may result in more ML entry signals being generated.", inline='1', group='Kernel Settings')
h = input.int(8, 'Lookback Window', minval=3, tooltip='The number of bars used for the estimation. This is a sliding value that represents the most recent historical bars. Recommended range: 3-50', group="Kernel Settings", inline="kernel")
r = input.float(8., 'Relative Weighting', step=0.25, tooltip='Relative weighting of time frames. As this value approaches zero, the longer time frames will exert more influence on the estimation. As this value approaches infinity, the behavior of the Rational Quadratic Kernel will become identical to the Gaussian kernel. Recommended range: 0.25-25', group="Kernel Settings", inline="kernel")
x = input.int(25, "Regression Level", tooltip='Bar index on which to start regression. Controls how tightly fit the kernel estimate is to the data. Smaller values are a tighter fit. Larger values are a looser fit. Recommended range: 2-25', group="Kernel Settings", inline="kernel")
lag = input.int(2, "NW_lag", tooltip="NW_lag for crossover detection. Lower values result in earlier crossovers. Recommended range: 1-2", inline='1', group='Kernel Settings')

// Display Settings
showBarColors = input.bool(false, "Show Bar Colors", tooltip="Whether to show the bar colors.", group="Display Settings")
showBarPredictions = input.bool(defval = false, title = "Show Bar Prediction Values", tooltip = "Will show the ML model's evaluation of each bar as an integer.", group="Display Settings")
useAtrOffset = input.bool(defval = false, title = "Use ATR Offset", tooltip = "Will use the ATR offset instead of the bar prediction offset.", group="Display Settings")
barPredictionsOffset = input.float(0, "Bar Prediction Offset", minval=0, tooltip="The offset of the bar predictions as a percentage from the bar high or close.", group="Display Settings")

// =================================
// ==== Next Bar Classification ====
// =================================

// This model specializes specifically in predicting the direction of price action over the course of the next 4 bars. 
// To avoid complications with the ML model, this value is hardcoded to 4 bars but support for other training lengths may be added in the future.
src = settings.source
y_train_series = src[4] < src[0] ? direction.short : src[4] > src[0] ? direction.long : direction.neutral
var y_train_array = array.new_int(0)

// Variables used for ML Logic
var predictions = array.new_float(0)
var prediction = 0.
var LC_signal = direction.neutral
var distances = array.new_float(0)

array.push(y_train_array, y_train_series)

// =========================
// ====  Core ML Logic  ====
// =========================

lastDistance = -1.0
size = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)
sizeLoop = math.min(settings.maxBarsBack-1, size)

if bar_index >= maxBarsBackIndex //{
    for i = 0 to sizeLoop //{
        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays) 
        if d >= lastDistance and i%4 //{
            lastDistance := d            
            array.push(distances, d)
            array.push(predictions, math.round(array.get(y_train_array, i)))
            if array.size(predictions) > settings.neighborsCount //{
                lastDistance := array.get(distances, math.round(settings.neighborsCount*3/4))
                array.shift(distances)
                array.shift(predictions)
            //}
        //}
    //}
    prediction := array.sum(predictions)
//}

// ============================
// ==== Prediction Filters ====
// ============================

// User Defined Filters: Used for adjusting the frequency of the ML Model's predictions
filter_all = filter.volatility and filter.regime and filter.adx

// Filtered Signal: The model's prediction of future price movement direction with user-defined filters applied
LC_signal := prediction > 0 and filter_all ? direction.long : prediction < 0 and filter_all ? direction.short : nz(LC_signal[1])

// Bar-Count Filters: Represents strict filters based on a pre-defined holding period of 4 bars
var int barsHeld = 0
barsHeld := ta.change(LC_signal) ? 0 : barsHeld + 1
isHeldFourBars = barsHeld == 4
isHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4

// Fractal Filters: Derived from relative appearances of signals in a given time series fractal/segment with a default length of 4 bars
isDifferentSignalType = ta.change(LC_signal)
isEarlySignalFlip = ta.change(LC_signal) and (ta.change(LC_signal[1]) or ta.change(LC_signal[2]) or ta.change(LC_signal[3]))
isBuySignal = LC_signal == direction.long and isEmaUptrend and isSmaUptrend
isSellSignal = LC_signal == direction.short and isEmaDowntrend and isSmaDowntrend
isLastSignalBuy = LC_signal[4] == direction.long and isEmaUptrend[4] and isSmaUptrend[4]
isLastSignalSell = LC_signal[4] == direction.short and isEmaDowntrend[4] and isSmaDowntrend[4]
isNewBuySignal = isBuySignal and isDifferentSignalType
isNewSellSignal = isSellSignal and isDifferentSignalType

// Kernel Regression Filters: Filters based on Nadaraya-Watson Kernel Regression using the Rational Quadratic Kernel
// For more information on this technique refer to my other open source indicator located here: 
// https://www.tradingview.com/script/AWNvbPRM-Nadaraya-Watson-Rational-Quadratic-Kernel-Non-Repainting/
c_green = color.new(#009988, 20)
c_red = color.new(#CC3311, 20)
transparent = color.new(#000000, 100)
yhat1 = kernels.rationalQuadratic(settings.source, h, r, x)
yhat2 = kernels.gaussian(settings.source, h-lag, x)
kernelEstimate = yhat1
// Kernel Rates of Change
bool wasBearishRate = yhat1[2] > yhat1[1]
bool wasBullishRate = yhat1[2] < yhat1[1]
bool isBearishRate = yhat1[1] > yhat1
bool isBullishRate = yhat1[1] < yhat1
isBearishChange = isBearishRate and wasBullishRate
isBullishChange = isBullishRate and wasBearishRate
// Kernel Crossovers
bool isBullishCrossAlert = ta.crossover(yhat2, yhat1)
bool isBearishCrossAlert = ta.crossunder(yhat2, yhat1) 
bool isBullishSmooth = yhat2 >= yhat1
bool isBearishSmooth = yhat2 <= yhat1
// Kernel Colors
color colorByCross = isBullishSmooth ? c_green : c_red
color colorByRate = isBullishRate ? c_green : c_red
color plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent
//plot(kernelEstimate, color=plotColor, linewidth=2, title="Kernel Regression Estimate")
// Alert Variables
bool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange
bool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange
// // Bullish and Bearish Filters based on Kernel
isBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true
isBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true

// ===========================
// ==== Entries and Exits ====
// ===========================

// Entry Conditions: Booleans for ML Model Position Entries
startLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend
startShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend

// Dynamic Exit Conditions: Booleans for ML Model Position Exits based on Fractal Filters and Kernel Regression Filters
lastSignalWasBullish = ta.barssince(startLongTrade) < ta.barssince(startShortTrade)
lastSignalWasBearish = ta.barssince(startShortTrade) < ta.barssince(startLongTrade)
barsSinceRedEntry = ta.barssince(startShortTrade)
barsSinceRedExit = ta.barssince(alertBullish)
barsSinceGreenEntry = ta.barssince(startLongTrade)
barsSinceGreenExit = ta.barssince(alertBearish)
isValidShortExit = barsSinceRedExit > barsSinceRedEntry
isValidLongExit = barsSinceGreenExit > barsSinceGreenEntry
endLongTradeDynamic = (isBearishChange and isValidLongExit[1])
endShortTradeDynamic = (isBullishChange and isValidShortExit[1])

// Fixed Exit Conditions: Booleans for ML Model Position Exits based on a Bar-Count Filters
endLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars and isNewSellSignal and isLastSignalBuy)) and startLongTrade[4]
endShortTradeStrict = ((isHeldFourBars and isLastSignalSell) or (isHeldLessThanFourBars and isNewBuySignal and isLastSignalSell)) and startShortTrade[4]
isDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing
endLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic : endLongTradeStrict 
endShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic : endShortTradeStrict

// =========================
// ==== Plotting Labels ====
// =========================

// Note: These will not repaint once the most recent bar has fully closed. By default, signals appear over the last closed bar; to override this behavior set offset=0.
plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=bullish, size=size.small, offset=0)
plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, color=bearish, size=size.small, offset=0)
//plotshape(endLongTrade and settings.showExits ? high : na, 'StopBuy', shape.xcross, location.absolute, color=bullish, size=size.tiny, offset=0)
//plotshape(endShortTrade and settings.showExits ? low : na, 'StopSell', shape.xcross, location.absolute, color=bearish, size=size.tiny, offset=0)

// ================
// ==== Alerts ====
// ================ 

// Separate Alerts for Entries and Exits
// alertcondition(startLongTrade, title='Open Long ▲', message='LDC Open Long ▲ | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(endLongTrade, title='Close Long ▲', message='LDC Close Long ▲ | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(startShortTrade, title='Open Short ▼', message='LDC Open Short  | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(endShortTrade, title='Close Short ▼', message='LDC Close Short ▼ | {{ticker}}@{{close}} | ({{interval}})')

// Combined Alerts for Entries and Exits
// alertcondition(startShortTrade or startLongTrade, title='Open Position ▲▼', message='LDC Open Position ▲▼ | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(endShortTrade or endLongTrade, title='Close Position ▲▼', message='LDC Close Position  ▲▼ | {{ticker}}@[{{close}}] | ({{interval}})')

// Kernel Estimate Alerts
// alertcondition(condition=alertBullish, title='Kernel Bullish Color Change', message='LDC Kernel Bullish ▲ | {{ticker}}@{{close}} | ({{interval}})')
// alertcondition(condition=alertBearish, title='Kernel Bearish Color Change', message='LDC Kernel Bearish ▼ | {{ticker}}@{{close}} | ({{interval}})')

// =========================
// ==== Display Signals ==== 
// =========================

atrSpaced = useAtrOffset ? ta.atr(1) : na
compressionFactor = settings.neighborsCount / settings.colorCompression
c_pred = prediction > 0 ? color.from_gradient(prediction, 0, compressionFactor, #787b86, #009988) : prediction <= 0 ? color.from_gradient(prediction, -compressionFactor, 0, #CC3311, #787b86) : na
c_label = showBarPredictions ? c_pred : na
c_bars = showBarColors ? color.new(c_pred, 50) : na
x_val = bar_index
y_val = useAtrOffset ? prediction > 0 ? high + atrSpaced: low - atrSpaced : prediction > 0 ? high + hl2*barPredictionsOffset/20 : low - hl2*barPredictionsOffset/30
label.new(x_val, y_val, str.tostring(prediction), xloc.bar_index, yloc.price, color.new(color.white, 100), label.style_label_up, c_label, size.normal, text.align_left)
barcolor(showBarColors ? color.new(c_pred, 50) : na)

// ===================== 
// ==== Backtesting ====
// =====================

// The following can be used to stream signals to a backtest adapter
// backTestStream = switch 
//     startLongTrade => 1
//     endLongTrade => 2
//     startShortTrade => -1
//     endShortTrade => -2
// plot(backTestStream, "Backtest Stream", display=display.none)

// The following can be used to display real-time trade stats. This can be a useful mechanism for obtaining real-time feedback during Feature Engineering. This does NOT replace the need to properly backtest.
// Note: In this context, a "Stop-Loss" is defined instances where the ML LC_signal prematurely flips directions before an exit LC_signal can be generated.
[totalWins, totalLosses, totalEarlySignalFlips, totalTrades, tradeStatsHeader, winLossRatio, winRate] = ml.backtest(high, low, open, startLongTrade, endLongTrade, startShortTrade, endShortTrade, isEarlySignalFlip, maxBarsBackIndex, bar_index, settings.source, useWorstCase)

init_table() =>
    c_transparent = color.new(color.black, 100)
    table.new(position.top_right, columns=2, rows=7, frame_color=color.new(color.black, 100), frame_width=1, border_width=1, border_color=c_transparent)

update_table(tbl, tradeStatsHeader, totalTrades, totalWins, totalLosses, winLossRatio, winRate, stopLosses) => 
    c_transparent = color.new(color.black, 100)
    table.cell(tbl, 0, 0, tradeStatsHeader, text_halign=text.align_center, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 0, 1, 'Winrate', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 1, 1, str.tostring(totalWins / totalTrades, '#.#%'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 0, 2, 'Trades', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 1, 2, str.tostring(totalTrades, '#') + ' (' + str.tostring(totalWins, '#') + '|' + str.tostring(totalLosses, '#') + ')', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 0, 5, 'WL Ratio', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 1, 5, str.tostring(totalWins / totalLosses, '0.00'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 0, 6, 'Early LC_signal Flips', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
    table.cell(tbl, 1, 6, str.tostring(totalEarlySignalFlips, '#'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)

if showTradeStats
    var tbl = ml.init_table()
    if barstate.islast
        update_table(tbl, tradeStatsHeader, totalTrades, totalWins, totalLosses, winLossRatio, winRate, totalEarlySignalFlips)
// lorentzian end



// vars
var float signal = na
var float SO_filter = na
var float SO_triggers = na
var float chart_trend = na
var float HTF1_trend = na
var float HTF2_trend = na
var float HTF3_trend = na


// ATRP
atrp_length = input.int(14, title='ATRP Length', minval=1)
atrp_length_d = input.int(2, title='ATRP Length for Daily', minval=1)
atrp_length_deviation = input.int(7, title='ATRP Length for deviation', minval=1)
ATRP_deviation_factor = input.float(1.0, title='ATRP Daily Factor', step=0.01)
ATRP_daily_factor = input.float(0.15, title='ATRP Daily Factor', step=0.01)

// Declare variables
var trp = float(0)
var atrp = float(0)
var float atrp_daily = na

//True Range Percentage Calculation
trp := ta.tr / hl2 * 100

round_to(n, decimals) =>
    mult = 1.0
    for i = 1 to decimals
        mult := mult * 10
    round_n = na(n * mult + 0.5) ? na : (n * mult + 0.5) - (n * mult + 0.5) % 1
    round_n / mult

// Smoothed true range percentage calculation
atrp := ta.sma(trp, atrp_length)

// Daily ATRP calculation
atrp_daily_temp = round_to(f_security(ticker, "D", atrp, i_repaint), 4)
// Get and store yesterday's ATRP value
atrp_daily_yesterday = atrp_daily_temp[1]

if not barstate.isfirst
    atrp_daily := atrp_daily_yesterday
//define ATRP Target to be used in Take Profit Calculations
atrp_target = atrp_daily * ATRP_daily_factor

atrp_deviation_temp = round_to(f_security(ticker, "D", ta.sma(trp, atrp_length_deviation), i_repaint), 4)
atrp_deviation = atrp_deviation_temp * ATRP_deviation_factor
//end atrp



// atr
atr_length = 100
ma_function(_source, _length) => ta.rma(_source, _length)
avg_atr = ma_function(ta.tr, atr_length)
ATR = ta.atr(100)
//end atr



// TD 8s and 9s
// inputs
grouptitleTD8s9s = "TD 8s & 9s"
showBuy8TDs = input(false, title="Show TD Buy 8", group = grouptitleTD8s9s)
showSell8TDs = input(false, title="Show TD Sell 8", group = grouptitleTD8s9s)
showBuy9TDs = input(false, title="Show TD Buy 9", group = grouptitleTD8s9s)
showSell9TDs = input(false, title="Show TD Sell 9", group = grouptitleTD8s9s)
// // TD CALCS 
buySignals = 0
buySignals := (close < close[4]) ? buySignals[1] == 9 ? 1 : buySignals[1] + 1 : 0

sellSignals = 0
sellSignals := (close > close[4]) ? sellSignals[1] == 9 ? 1 : sellSignals[1] + 1 : 0

BuyOrSell = buySignals > sellSignals ? buySignals : sellSignals

// TD8buy = showBuy8TDs and buySignals and BuyOrSell == 8
// TD9buy = showBuy9TDs and buySignals and BuyOrSell == 9

TD8buy = showBuy8TDs and buySignals > 0 and BuyOrSell == 8
TD9buy = showBuy9TDs and buySignals > 0 and BuyOrSell == 9

TD8sell = showSell8TDs and sellSignals > 0 and BuyOrSell == 8
TD9sell = showSell9TDs and sellSignals > 0 and BuyOrSell == 9

// TD8sell = showSell8TDs and sellSignals and BuyOrSell == 8
// TD9sell = showSell9TDs and sellSignals and BuyOrSell == 9


//DCA Plots
TDbuycondition = (close < close[4]) ? buySignals[1] == 9 ? 1 : buySignals[1] + 1 : 0
TDsellcondition = (close > close[4]) ? sellSignals[1] == 9 ? 1 : sellSignals[1] + 1 : 0
// plot (buycondition, 'buycondition', color=bullish2)
// plot (sellcondition, 'sellcondition', color=bearish2)

// ALERTS /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//alertcondition(TD8buy, "TD 8 Buy", "TD 8 Buy") // Once per bar close
alertcondition(TD9buy, "TD 9 Buy", "TD 9 Buy") // Once per bar close
//alertcondition(TD8sell, "TD 8 Sell", "TD 8 Sell") // Once per bar close
alertcondition(TD9sell, "TD 9 Sell", "TD 9 Sell") // Once per bar close
// end TD 8s and 9s









// half trend
ht_groupTitleHalfTrend = "Half Trend"
ht_amplitude = input(title='Amplitude', defval=20, group = ht_groupTitleHalfTrend)
ht_channelDeviation = 10
ht_showArrows = input(title='Show Arrows', defval=false, group = ht_groupTitleHalfTrend)
//ht_showChannels = input(title='Show Channels', defval=false, group = ht_groupTitleHalfTrend)

var int ht_trend = 0
var int ht_nextTrend = 0
var float ht_maxLowPrice = nz(low[1], low)
var float ht_minHighPrice = nz(high[1], high)

var float ht_up = 0.0
var float ht_down = 0.0
float ht_atrHigh = 0.0
float ht_atrLow = 0.0
float ht_arrowUp = na
float ht_arrowDown = na

ht_atr2 = ta.atr(100) / 2
ht_dev = ht_channelDeviation * ht_atr2

ht_highPrice = high[math.abs(ta.highestbars(ht_amplitude))]
ht_lowPrice = low[math.abs(ta.lowestbars(ht_amplitude))]
ht_highma = ta.sma(high, ht_amplitude)
ht_lowma = ta.sma(low, ht_amplitude)

if ht_nextTrend == 1
    ht_maxLowPrice := math.max(ht_lowPrice, ht_maxLowPrice)

    if ht_highma < ht_maxLowPrice and close < nz(low[1], low)
        ht_trend := 1
        ht_nextTrend := 0
        ht_minHighPrice := ht_highPrice
        ht_minHighPrice
else
    ht_minHighPrice := math.min(ht_highPrice, ht_minHighPrice)

    if ht_lowma > ht_minHighPrice and close > nz(high[1], high)
        ht_trend := 0
        ht_nextTrend := 1
        ht_maxLowPrice := ht_lowPrice
        ht_maxLowPrice

if ht_trend == 0
    if not na(ht_trend[1]) and ht_trend[1] != 0
        ht_up := na(ht_down[1]) ? ht_down : ht_down[1]
        ht_arrowUp := ht_up - ht_atr2
        ht_arrowUp
    else
        ht_up := na(ht_up[1]) ? ht_maxLowPrice : math.max(ht_maxLowPrice, ht_up[1])
        ht_up
    ht_atrHigh := ht_up + ht_dev
    ht_atrLow := ht_up - ht_dev
    ht_atrLow
else
    if not na(ht_trend[1]) and ht_trend[1] != 1
        ht_down := na(ht_up[1]) ? ht_up : ht_up[1]
        ht_arrowDown := ht_down + ht_atr2
        ht_arrowDown
    else
        ht_down := na(ht_down[1]) ? ht_minHighPrice : math.min(ht_minHighPrice, ht_down[1])
        ht_down
    ht_atrHigh := ht_down + ht_dev
    ht_atrLow := ht_down - ht_dev
    ht_atrLow

ht = ht_trend == 0 ? ht_up : ht_down

var color ht_buyColor = bullish
var color ht_sellColor = bearish

ht_htColor = ht_trend == 0 ? ht_buyColor : ht_sellColor


ht_buySignal = not na(ht_arrowUp) and ht_trend == 0 and ht_trend[1] == 1
ht_sellSignal = not na(ht_arrowDown) and ht_trend == 1 and ht_trend[1] == 0

// end half trend
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}








//Nadaraya-Watson non repainting
//src = close
NW_h = input.float(8., 'Lookback Window', minval=3., tooltip='The number of bars used for the estimation. This is a sliding value that represents the most recent historical bars. Recommended range: 3-50')
NW_r = input.float(8., 'Relative Weighting', step=0.25, tooltip='Relative weighting of time frames. As this value approaches zero, the longer time frames will exert more influence on the estimation. As this value approaches infinity, the behavior of the Rational Quadratic Kernel will become identical to the Gaussian kernel. Recommended range: 0.25-25')
x_0 = input.int(25, "Start Regression at Bar", tooltip='Bar index on which to start regression. The first bars of a chart are often highly volatile, and omission of these initial bars often leads to a better overall fit. Recommended range: 5-25')
showMiddle = false
smoothColors = false
NW_lag = 2
showNWplots = input(false, "Show NW Plots")
showNWSignals = input(false, "Show NW Signals")

lenjeje = input(32, "NW ATR Period", tooltip= 'Period to calculate upper and lower band', group='Bands')
coef = input(2.7,"NW Multiplier",tooltip= 'Multiplier to calculate upper and lower band', group='Bands')
float y1 = 0.
float y2 = 0.
srcArray = array.new<float>(0)
array.push(srcArray, src)
NW_size = array.size(srcArray)


kernel_regression1(_src, _size, _h) =>
    float _currentWeight = 0.
    float _cumulativeWeight = 0.
    for i = 0 to _size + x_0
        y = _src[i] 
        w = math.pow(1 + (math.pow(i, 2) / ((math.pow(_h, 2) * 2 * NW_r))), -NW_r)
        _currentWeight += y*w
        _cumulativeWeight += w
    [_currentWeight, _cumulativeWeight]

[currentWeight1, cumulativeWeight1] = kernel_regression1(src, size, NW_h)
NW_yhat1 = currentWeight1 / cumulativeWeight1
[currentWeight2, cumulativeWeight2] = kernel_regression1(src, size, NW_h-NW_lag)
NW_yhat2 = currentWeight2 / cumulativeWeight2

// Rates of Change
bool NW_wasBearish = NW_yhat1[2] > NW_yhat1[1]
bool NW_wasBullish = NW_yhat1[2] < NW_yhat1[1]
bool NW_isBearish = NW_yhat1[1] > NW_yhat1
bool NW_isBullish = NW_yhat1[1] < NW_yhat1
bool NW_isBearishChange = NW_isBearish and NW_wasBullish
bool NW_isBullishChange = NW_isBullish and NW_wasBearish

// Crossovers
bool isBullishCross = ta.crossover(yhat2, yhat1)
bool isBearishCross = ta.crossunder(yhat2, yhat1) 
bool NW_isBullishSmooth = NW_yhat2 > NW_yhat1
bool NW_isBearishSmooth = NW_yhat2 < NW_yhat1

// Colors
color NW_colorByCross = isBullishSmooth ? bullish : bearish
color NW_colorByRate = isBullish ? bullish : bearish
color NW_plotColor = smoothColors ? colorByCross : colorByRate


upperjeje = yhat1 + coef*ta.atr(lenjeje)
lowerjeje = yhat1 - coef*ta.atr(lenjeje)
//upperje = plot(showNWplots ? upperjeje : na, "Rational Quadratic Kernel Upper", color=bullish, linewidth=1)
//lowerje = plot(showNWplots ? lowerjeje : na, "Rational Quadratic Kernel Lower", color=bearish, linewidth=1)

NW_short = ta.crossover(close, upperjeje)
NW_long = ta.crossunder(close, lowerjeje)
//  END Nadaraya-Watson non repainting










// Structure
groupTitleStructureSettings = "Structure Settings"
MSlength  = input(5, 'Pivot Lookback', group = groupTitleStructureSettings)
incr    = input.float(95, 'Increment Factor %', minval = 0, group = groupTitleStructureSettings)
showTS  = input(false, "Show TS", group = groupTitleStructureSettings)
showTrendChange = input.bool(false, "Show Trend Change", group = groupTitleStructureSettings)
show_ts_htf1 = input.bool(false, title="Show HTF1 Trailing Stop", group = groupTitleStructureSettings)
show_ts_htf2 = input.bool(false, title="Show HTF2 Trailing Stop", group = groupTitleStructureSettings)
show_ts_htf3 = input.bool(false, title="Show HTF3 Trailing Stop", group = groupTitleStructureSettings)
//showTrendChangeBG = input.bool(false, title="Show Trend Change Background", group = groupTitleStructureSettings)

resetOn = 'CHoCH'

//Style 
bullCss    = bullish2
bearCss    = bearish2
retCss     = #413002
areaTransp = 90

bullCss2    = bullish2
bearCss2    = bearish2
retCss2    = #413002
areaTransp2 = 90

//structure Global variables
var float ph_y = na , var int ph_x = na
var float pl_y = na , var int pl_x = na
var float top = na  , var float btm = na
var ph_cross = false, var pl_cross = false

var float max = na
var float min = na
var float ts = na

var os = 0
ms = 0

//Detect pivots and get coordinates
n = bar_index
ph = ta.pivothigh(MSlength, MSlength)
pl = ta.pivotlow(MSlength, MSlength)

if ph > 0
    ph_y := ph
    ph_x := n - MSlength
    ph_cross := false

if pl > 0
    pl_y := pl
    pl_x := n - MSlength
    pl_cross := false

//Bullish structures
if close > ph_y and not ph_cross
    if resetOn == 'CHoCH'
        ms := os == -1 ? 1 : 0
    else
        ms := 1

    ph_cross := true


    os := 1

    //Search for local minima
    btm := low
    for i = 0 to (n - ph_x)-1
        btm := math.min(low[i], btm)

    osChange = os != os[1]

//Bearish structures
if close < pl_y and not pl_cross
    if resetOn == 'CHoCH'
        ms := os == 1 ? -1 : 0
    else
        ms := -1

    pl_cross := true

    os := -1

    //Search for local maxima
    top := high
    for i = 0 to (n - pl_x)-1
        top := math.max(high[i], top)

    osChange = os != os[1]

//Trailing stop max/min
if ms == 1
    max := close
else if ms == -1
    min := close
else
    max := math.max(close, max)
    min := math.min(close, min)

//Trailing stop
ts := ms == 1 ? btm
  : ms == -1 ? top
  : os == 1 ? ts + (max - max[1]) * incr / 100
  : ts + (min - min[1]) * incr / 100

css = (ms > 0) ? na 
  : os == 1 ? bullCss
  : bearCss

css2 = (ms > 0) ? na 
  : os == 1 ? bullCss2
  : bearCss2

css_area = (close - ts) * os < 0 ? retCss
  : css

osChange = os != os[1]


var float ts_htf1 = na
var float ts_htf2 = na
var float ts_htf3 = na


// MTF
ts_htf1 := f_security(ticker, HTF1_str, ts, i_repaint)
ts_htf2 := f_security(ticker, HTF2_str, ts, i_repaint)
ts_htf3 := f_security(ticker, HTF3_str, ts, i_repaint)

os_htf1 = f_security(ticker, HTF1_str, os, i_repaint)
os_htf2 = f_security(ticker, HTF2_str, os, i_repaint)
os_htf3 = f_security(ticker, HTF3_str, os, i_repaint)

trendUp = os == 1 and osChange
trendDown = os == -1 and osChange

trendingUp = os == 1
trendingDown = os == -1

//MTF os
trendingUpHTF1 = os_htf1 == 1
trendingDownHTF1 = os_htf1 == -1
trendingUpHTF2 = os_htf2 == 1
trendingDownHTF2 = os_htf2 == -1
trendingUpHTF3 = os_htf3 == 1
trendingDownHTF3 = os_htf3 == -1

trendstatusHTF1 = trendingUpHTF1 ? 'Up'
  : trendingDownHTF1 ? 'Down'
  : 'Neutral'

trendstatusHTF2 = trendingUpHTF2 ? 'Up'
  : trendingDownHTF2 ? 'Down'
  : 'Neutral'

trendstatusHTF3 = trendingUpHTF3 ? 'Up'
  : trendingDownHTF3 ? 'Down'
  : 'Neutral'

trendChangeUpHTF1 = os_htf1 == 1 and (os_htf1 != os_htf1[1])
trendChangeDownHTF1 = os_htf1 == -1 and (os_htf1 != os_htf1[1])
trendChangeUpHTF2 = os_htf2 == 1 and (os_htf2 != os_htf2[1])
trendChangeDownHTF2 = os_htf2 == -1 and (os_htf2 != os_htf2[1])
trendChangeUpHTF3 = os_htf3 == 1 and (os_htf3 != os_htf3[1])
trendChangeDownHTF3 = os_htf3 == -1 and (os_htf3 != os_htf3[1])


above_ts_htf1 = close > ts_htf1
below_ts_htf1 = close < ts_htf1
above_ts_htf2 = close > ts_htf2
below_ts_htf2 = close < ts_htf2
above_ts_htf3 = close > ts_htf3
below_ts_htf3 = close < ts_htf3

alertcondition(ta.crossunder(close,ts), title='Price crossed down under Trail', message='{{ticker}} Price crossed down under Trail')
alertcondition(ta.crossover(close,ts), title='Price crossed up over Trail', message='{{ticker}}Price crossed up over Trail')
alertcondition(trendUp, title='Trend Change Up', message='{{ticker}} Trend Change Up')
alertcondition(trendDown, title='Trend Change Down', message='{{ticker}} Trend Change Down')
// end structure




// random rules
twobarup = close[1] > open[1] and close > open
twobardown = close[1] < open[1] and close < open
threebarup = close[2] > open[2] and close[1] > open[1] and close > open
threebardown = close[2] < open[2] and close[1] < open[1] and close < open













groupTitleLongEntry = "Long Entry"
Struc_trigger_long_Input = input.bool(false, "Struc Trigger Long", group = groupTitleLongEntry)
ht_long_trigger = input.bool(false, "Long HT Trigger", group = groupTitleLongEntry)
//exRev_long_trigger = input.bool(false, "Long Ex Rev Trigger", group = groupTitleLongEntry)
NW_long_trigger = input.bool(false, "Long NW Trigger", group = groupTitleLongEntry)
LC_long_trigger = input.bool(false, "LC Long Trigger", group = groupTitleLongEntry)

groupTitleLongFilters = "Long Filters"
trendingUp_filter = input.bool(false, "trendingUp long trend filter", group = groupTitleLongFilters)
twobarup_filter = input.bool(false, "2nd bar up filter", group = groupTitleLongFilters)
above_ts_htf1_filter = input.bool(false, "Use hft1 long trend filter", group = groupTitleLongFilters)
above_ts_htf2_filter = input.bool(false, "Use hft2 long trend filter", group = groupTitleLongFilters)
above_ts_htf3_filter = input.bool(false, "Use hft3 long trend filter", group = groupTitleLongFilters)


groupTitleShortEntry = "Short Entry"
Struc_trigger_short_Input = input.bool(false, "Struc Trigger Short", group = groupTitleShortEntry)
ht_short_trigger = input.bool(false, "Short HT Trigger", group = groupTitleShortEntry)
//exRev_short_trigger = input.bool(false, "Short Ex Rev Trigger", group = groupTitleShortEntry)
NW_short_trigger = input.bool(false, "Short NW Trigger", group = groupTitleShortEntry)
LC_short_trigger = input.bool(false, "LC Short Trigger", group = groupTitleShortEntry)


groupTitleShortFilters = "Short Filters"
trendingDown_filter = input.bool(false, "trendingDown short trend filter", group = groupTitleShortFilters)
twobardown_filter = input.bool(false, "2nd bar down filter", group = groupTitleShortFilters)
below_ts_htf1_filter = input.bool(false, "Use hft1 short trend filter", group = groupTitleShortFilters)
below_ts_htf2_filter = input.bool(false, "Use hft2 short trend filter", group = groupTitleShortFilters)
below_ts_htf3_filter = input.bool(false, "Use hft3 short trend filter", group = groupTitleShortFilters)




longsignal = (
   (Struc_trigger_long_Input and trendUp) or
   (ht_long_trigger and ht_buySignal) or
   //(exRev_long_trigger and exLongTrigger) or
   (NW_long_trigger and NW_long) or
   (LC_long_trigger and startLongTrade)
   ) and
   (trendingUp_filter ? trendingUp : true) and
   (above_ts_htf1_filter ? above_ts_htf1 : true) and
   (above_ts_htf2_filter ? above_ts_htf2 : true) and
   (above_ts_htf3_filter ? above_ts_htf3 : true) and
   (twobarup_filter ? twobarup : true)

longsignal_filters = (trendingUp_filter ? trendingUp : true) and
   (above_ts_htf1_filter ? above_ts_htf1 : true) and
   (above_ts_htf2_filter ? above_ts_htf2 : true) and
   (above_ts_htf3_filter ? above_ts_htf3 : true) and
   (twobarup_filter ? twobarup : true)
// Add this input to control the background color
show_longsignal_filter_bg = input.bool(false, "Show Long Signal Filter Background", group = groupTitleLongFilters)
// Modify this line to change the background color based on the new input
bgcolor(show_longsignal_filter_bg and longsignal_filters ? #00460062 : na)

shortsignal = (
   (Struc_trigger_short_Input and trendDown) or
   (ht_short_trigger and ht_sellSignal) or
   //(exRev_short_trigger and exShortTrigger) or
   (NW_short_trigger and NW_short) or
   (LC_short_trigger and startShortTrade)
   ) and
   (trendingDown_filter ? trendingDown : true) and
   (below_ts_htf1_filter ? below_ts_htf1 : true) and
   (below_ts_htf2_filter ? below_ts_htf2 : true) and
   (below_ts_htf3_filter ? below_ts_htf3 : true) and
   (twobardown_filter ? twobardown : true)

shortsignal_filters = (trendingDown_filter ? trendingDown : true) and
   (below_ts_htf1_filter ? below_ts_htf1 : true) and
   (below_ts_htf2_filter ? below_ts_htf2 : true) and
   (below_ts_htf3_filter ? below_ts_htf3 : true) and
   (twobardown_filter ? twobardown : true)
// Add this input to control the background color
show_shortsignal_filter_bg = input.bool(false, "Show Short Signal Filter Background", group = groupTitleShortFilters)
// Modify this line to change the background color based on the new input
bgcolor(show_shortsignal_filter_bg and shortsignal_filters ? #6b04047c : na)

// Calculate signals
signal := longsignal ? 1.0 : shortsignal ? -1.0 : na

// Signal plots
plot(signal, title="Signal", color=color.rgb(76, 175, 79, 100))
// plotshape(series=signal == 1.0, title='Long Signal', style=shape.triangleup, location=location.belowbar, color=bullish, size=size.tiny)
// plotshape(series=signal == -1.0, title='Short Signal', style=shape.triangledown, location=location.abovebar, color=bearish, size=size.tiny)
// END Signals




// SO Filters

var float SO_filter_longs_value = na
var float SO_filter_shorts_value = na

groupTitleSOFiltersLong = "SO Filters Long"
trendingUp_filter_SO = input.bool(false, "trendingUp long trend filter", group = groupTitleSOFiltersLong)
twobarup_filter_SO = input.bool(false, "2nd bar up filter", group = groupTitleSOFiltersLong)
above_ts_htf1_filter_SO = input.bool(false, "Use hft1 long trend filter", group = groupTitleSOFiltersLong)
above_ts_htf2_filter_SO = input.bool(false, "Use hft2 long trend filter", group = groupTitleSOFiltersLong)
above_ts_htf3_filter_SO = input.bool(false, "Use hft3 long trend filter", group = groupTitleSOFiltersLong)

groupTitleSOFiltersShort = "SO Filters Short"
trendingDown_filter_SO = input.bool(false, "trendingDown short trend filter", group = groupTitleSOFiltersShort)
twobardown_filter_SO = input.bool(false, "2nd bar down filter", group = groupTitleSOFiltersShort)
below_ts_htf1_filter_SO = input.bool(false, "Use hft1 short trend filter", group = groupTitleSOFiltersShort)
below_ts_htf2_filter_SO = input.bool(false, "Use hft2 short trend filter", group = groupTitleSOFiltersShort)
below_ts_htf3_filter_SO = input.bool(false, "Use hft3 short trend filter", group = groupTitleSOFiltersShort)

// SO Long Filter Logic
SO_filter_longs_cond = (trendingUp_filter_SO or trendingUp) and 
   (twobarup_filter_SO or twobarup) and
   (above_ts_htf1_filter_SO or above_ts_htf1) and
   (above_ts_htf2_filter_SO or above_ts_htf2) and
   (above_ts_htf3_filter_SO or above_ts_htf3)


// Short Filter Logic
SO_filter_shorts_cond = (trendingDown_filter_SO or trendingDown) and
                         (twobardown_filter_SO or twobardown) and
                         (below_ts_htf1_filter_SO or below_ts_htf1) and
                         (below_ts_htf2_filter_SO or below_ts_htf2) and
                         (below_ts_htf3_filter_SO or below_ts_htf3)




SO_filter_longs_value := SO_filter_longs_cond ? 1.0 : na
SO_filter_shorts_value := SO_filter_shorts_cond ? -1.0 : na

// Plot the values separately
plot(SO_filter_longs_value ? SO_filter_longs_value : SO_filter_shorts_value, title="SO Filter", color=SO_filter_longs_value ? color.rgb(76, 175, 79, 98) : color.rgb(255, 82, 82, 96))
// end SO filters


//SO Triggers
// groupTitleSOTriggersLong = "SO Triggers Long"
// trendUpSOTrigger_Long = input.bool(false, "trendUp SO Trigger Long", group = groupTitleSOTriggersLong)
// trendUp_htf1_SOTrigger_Long = input.bool(false, "trendUp htf1 SO Trigger Long", group = groupTitleSOTriggersLong)
// trendUp_htf2_SOTrigger_Long = input.bool(false, "trendUp htf2 SO Trigger Long", group = groupTitleSOTriggersLong)
// trendUp_htf3_SOTrigger_Long = input.bool(false, "trendUp htf3 SO Trigger Long", group = groupTitleSOTriggersLong)

// groupTitleSOTriggersShort = "SO Triggers Short"
// trendDownSOTrigger_Short = input.bool(false, "trendDown SO Trigger Short", group = groupTitleSOTriggersShort)
// trendDown_htf1_SOTrigger_Short = input.bool(false, "trendDown htf1 SO Trigger Short", group = groupTitleSOTriggersShort)
// trendDown_htf2_SOTrigger_Short = input.bool(false, "trendDown htf2 SO Trigger Short", group = groupTitleSOTriggersShort)
// trendDown_htf3_SOTrigger_Short = input.bool(false, "trendDown htf3 SO Trigger Short", group = groupTitleSOTriggersShort)

// SO_trigger_longs_cond = (trendUpSOTrigger_Long and trendUp) or
//    (trendUp_htf1_SOTrigger_Long and trendChangeUpHTF1) or
//    (trendUp_htf2_SOTrigger_Long and trendChangeUpHTF2) or
//    (trendUp_htf3_SOTrigger_Long and trendChangeUpHTF3)

// SO_trigger_shorts_cond = (trendDownSOTrigger_Short and trendDown) or   
//    (trendDown_htf1_SOTrigger_Short and trendChangeDownHTF1) or
//    (trendDown_htf2_SOTrigger_Short and trendChangeDownHTF2) or
//    (trendDown_htf3_SOTrigger_Short and trendChangeDownHTF3)

// var float SO_trigger_longs_value = na
// var float SO_trigger_shorts_value = na

// SO_trigger_longs_value := SO_trigger_longs_cond ? 1.0 : na
// SO_trigger_shorts_value := SO_trigger_shorts_cond ? -1.0 : na

// plotshape(SO_trigger_longs_value, title="SO Trigger Longs", color=bullish, style=shape.diamond, location = location.belowbar, size=size.large)
// plotshape(SO_trigger_shorts_value, title="SO Trigger Shorts", color=bearish, style=shape.diamond, location = location.abovebar, size=size.large)

// SO_triggers := SO_trigger_longs_value ? 1.0 : SO_trigger_shorts_value ? -1.0 : na
// plot(SO_triggers, title="SO Triggers", color=color.rgb(76, 175, 79, 94))
// end SO triggers

// HT plots
// plotshape(ht_showArrows and ht_buySignal ? ht_atrLow : na, title='HT Up', style=shape.triangleup, location=location.absolute, size=size.tiny, color=color.new(ht_buyColor, 0))
// plotshape(ht_showArrows and ht_sellSignal ? ht_atrHigh : na, title='HT Down', style=shape.triangledown, location=location.absolute, size=size.tiny, color=color.new(ht_sellColor, 0))
plotshape(ht_showArrows and ht_buySignal and signal == 1 ? ht_atrLow : na, title='HT Up', style=shape.triangleup, location=location.absolute, size=size.tiny, color=color.new(ht_buyColor, 0))
plotshape(ht_showArrows and ht_sellSignal and signal == -1 ? ht_atrHigh : na, title='HT Down', style=shape.triangledown, location=location.absolute, size=size.tiny, color=color.new(ht_sellColor, 0))
// end HT plots



// NW plots
plotchar(showNWSignals and ta.crossover(close, upperjeje) and signal == -1, title='NW Down', char = "💧", location = location.abovebar, offset = 4, size = size.tiny)
plotchar(showNWSignals and ta.crossunder(close, lowerjeje) and signal == 1, title='NW Up', char = "🚀", location = location.belowbar, offset = 5, size = size.tiny)
// Alerts for Color Changes estimator
// alertcondition(smoothColors ? isBearishCross : isBearishChange, title='Bearish Color Change', message='Nadaraya-Watson: {{ticker}} ({{interval}}) turned Bearish ▼')
// alertcondition(smoothColors ? isBullishCross : isBullishChange, title='Bullish Color Change', message='Nadaraya-Watson: {{ticker}} ({{interval}}) turned Bullish ▲')

// Alerts when price cross upper and lower band
// alertcondition(ta.crossover(close,upperjeje), title='Price close above upper band', message='Nadaraya-Watson: {{ticker}} ({{interval}}) Crossed above upper band 💧')
// alertcondition(ta.crossunder(close,lowerjeje), title='Price close under lower band', message='Nadaraya-Watson: {{ticker}} ({{interval}}) crossed under lower band 🚀')
// end NW plots


// Struc Plots
plot_ts    = plot(showTS ? ts : na, 'Trailing Stop', color = css2)
// plotshape(showTrendChange ? trendUp : na, style=shape.triangleup, location=location.belowbar, color=bullish, size=size.tiny, title="Up Trend Chart Trigger")
// plotshape(showTrendChange ? trendDown : na, style=shape.triangledown, location=location.abovebar, color=bearish, size=size.tiny, title="Down Trend Chart Trigger")

// Plot the trailing stops with individual checkboxes
plot_ts_htf1 = plot(show_ts_htf1 ? ts_htf1 : na, 'HTF1 Trailing Stop', color = css)
plot_ts_htf2 = plot(show_ts_htf2 ? ts_htf2 : na, 'HTF2 Trailing Stop', color = css)
plot_ts_htf3 = plot(show_ts_htf3 ? ts_htf3 : na, 'HTF3 Trailing Stop', color = css)



// Define invisible plots for high and low
// plot_high = plot(high, title="High", color=na, display=display.none)
// plot_low = plot(low, title="Low", color=na, display = display.none)
// Determine if the price is above or below the trailing stop
price_above_ts_htf1 = close > ts_htf1
price_below_ts_htf1 = close < ts_htf1
price_above_ts_htf2 = close > ts_htf2
price_below_ts_htf2 = close < ts_htf2
price_above_ts_htf3 = close > ts_htf3
price_below_ts_htf3 = close < ts_htf3

// // Calculate midpoints (for gradient)

// midpoint_candle = (high + low) / 2
// plot_midpoint_candle = plot(midpoint_candle, color=na, title="Midpoint Candle", display=display.none)

// // Define the colors for the gradients
// color bullishGradientTop = color.new(#000000, 100)
// color bullishGradientBottom = color.new(#03d5fe, 80) 
// color bearishGradientTop = color.new(#fe02fe, 80) 
// color bearishGradientBottom = color.new(#000000, 100) 
// fill(plot_ts_htf1, plot_midpoint_candle, price_above_ts_htf1 ? ts_htf2 : na, high, bullishGradientTop, bullishGradientBottom)
// fill(plot_ts_htf1, plot_midpoint_candle, price_below_ts_htf1 ? low : na, ts_htf2, bearishGradientTop, bearishGradientBottom)
// fill(plot_ts_htf2, plot_midpoint_candle, price_above_ts_htf2 ? ts_htf2 : na, high, bullishGradientTop, bullishGradientBottom)
// fill(plot_ts_htf2, plot_midpoint_candle, price_below_ts_htf2 ? low : na, ts_htf2, bearishGradientTop, bearishGradientBottom)
// fill(plot_ts_htf3, plot_midpoint_candle, price_above_ts_htf3 ? ts_htf3 : na, high, bullishGradientTop, bullishGradientBottom)
// fill(plot_ts_htf3, plot_midpoint_candle, price_below_ts_htf3 ? low : na, ts_htf3, bearishGradientTop, bearishGradientBottom)


chart_trend := trendingUp ? 1.0 : trendingDown ? -1.0 : na
// HTF1_trend := trendingUpHTF1 ? 1.0 : trendingDownHTF1 ? -1.0 : na
// HTF2_trend := trendingUpHTF2 ? 1.0 : trendingDownHTF2 ? -1.0 : na
// HTF3_trend := trendingUpHTF3 ? 1.0 : trendingDownHTF3 ? -1.0 : na
// plot(chart_trend, title="chart trend", color=color.rgb(76, 175, 79, 100))
// plot(HTF1_trend, title="HTF1 trend", color=color.rgb(76, 175, 79, 100))
// plot(HTF2_trend, title="HTF2 trend", color=color.rgb(76, 175, 79, 100))
// plot(HTF3_trend, title="HTF3 trend", color=color.rgb(76, 175, 79, 100))



// TD Plots
//plotshape(TD8buy, title="TD 8 Buy", style=shape.labelup, color=color.new (bullish3, 60), size=size.tiny, location=location.belowbar)
//plotshape(TD8sell, title="TD 8 Sell", style=shape.labeldown, color=color.new (bearish3, 60), size=size.tiny, location=location.abovebar)

plotshape(TD9buy, title="TD 9 Buy", style=shape.diamond, color=color.new(bullish2, 60), size=size.tiny, location=location.belowbar)
plotshape(TD9sell, title="TD 9 Sell", style=shape.diamond, color=color.new(bearish2, 60), size=size.tiny, location=location.abovebar)




var tbb = TTBTableBuilder.new(position.top_right,3,2)
if barstate.isconfirmed
	header = tbb.R(0).TextColor(color.rgb(18, 247, 255)).TextSize(size.small).Font(font.family_monospace)
	header.Text("HTF1","HTF2","HTF3")
    tbb.R(1).TextColor(color.white).TextSize(size.small).Text(str.tostring(trendstatusHTF1),str.tostring(trendstatusHTF2),str.tostring(trendstatusHTF3)).Bg(color.rgb(255, 255, 255, 74))
	// tbb.R(2).TextColor(color.white).TextSize(size.small).Text("A","B","C")
