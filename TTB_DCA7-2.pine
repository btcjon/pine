//@version=5
strategy('TTB DCA 7.2S', overlay=true, initial_capital=1000000, default_qty_type=strategy.cash, default_qty_value=100000, currency=currency.USD, pyramiding=999, calc_on_every_tick=false, max_bars_back=4900)



import thetradingbot/ttbcolors/1 as TTBColors

source_type = input.string('Close', 'Source', options=['Close', 'Open', 'High', 'Low', 'HL2', 'HLC3', 'OHLC4', 'Median Body', 'Weighted Close', 'Trend Biased', 'Trend Biased Extreme'])
direction = input.string(defval='Short', title='Trading Direction', options=['All', 'Long', 'Short'])


source_function(type) =>
    if type == 'Close'
        close
    else if type == 'Open'
        open
    else if type == 'High'
        high
    else if type == 'Low'
        low
    else if type == 'HL2'
        hl2
    else if type == 'HL3'
        hlc3
    else if type == 'OHLC4'
        ohlc4
    else if type == 'Median Body'
        (open + close) / 2
    else if type == 'Weighted Close'
        (high + low + 2 * close) / 4
    else if type == 'Trend Biased'
        close > open ? (high + close) / 2 : (low + close) / 2
    else if type == 'Trend Biased Extreme'
        close > open ? high : low

truncate(number, decimals) =>
    factor = math.pow(10, decimals)
    int(number * factor) / factor

var long = false
var short = true

if direction == 'All'
    long := true
    short := true
    short
else if direction == 'Long'
    long := true
    short := false
    short
else if direction == 'Short'
    long := false
    short := true
    short

// Strategy Inputs
ID = input(defval='6700960415957', title='ID')
version = input(defval='7-2', title='version')
test = input(defval='1', title='test')
safe_order_step_scale_Multiplier = input(1.3, title="Safe Order Step Scale Multiplier")
groupTitleLongInputs = "Long Inputs"
price_deviation = input.float(0.04, title='Price deviation to open safety orders (%)', step=0.1, minval=0.0) / 100
take_profit = input.float(0.1, title='Target Take Profit (%)', step=0.1, minval=0.0) / 100
// base_order = input.float(10000, "Base Order Size")
// safe_order = input.float(10000, "Safe Order Size")
base_order_lots = input.float(0.4, "Base Order Size (Lots)")
safe_order_lots = input.float(0.4, "Safe Order Size (Lots)")
safe_order_volume_scale = input.float(1, step=0.1, title='Safety order volume scale')
safe_order_step_scale = input.float(1.3, step=0.1, title='Safety order step scale')
max_safe_order = input(6, title='max no. of safe orders')
groupTitleShortInputs = "Short Inputs"
price_S_deviation = input.float(0.04, title='Price deviation to open short safety orders (%)', step=0.1, minval=0.0) / 100
take_S_profit = input.float(0.1, title='Short Target Take Profit (%)', step=0.1, minval=0.0) / 100
// base_S_order = input.float(10000, title='base sell order')
// safe_S_order = input.float(10000, title='safe sell order')
base_S_order_lots = input.float(0.4, title='base sell order (Lots)')
safe_S_order_lots = input.float(0.4, title='safe sell order (Lots)')
safe_S_order_volume_scale = input.float(1, step=0.1, title='Safety sell order volume scale')
safe_S_order_step_scale = input.float(1.3, step=0.1, title='Safety sell order step scale')
max_S_safe_order = input(6, title='max no. of sell safe orders')


//------------- DETERMINE CURRENCY CONVERSION RATE ------------- { //
// Import ZenLibrary
import ZenAndTheArtOfTrading/ZenLibrary/5 as zen
// Custom function for converting units into lot sizes
unitsToLots(units) =>
    float lots = units / 100000
    lots := math.round(lots, 2)
    _return = lots * 100000
// Check if our account currency is the same as the base or quote currency or neither (for risk $ conversion purposes)
accountSameAsCounterCurrency = strategy.account_currency == syminfo.currency
accountSameAsBaseCurrency = strategy.account_currency == syminfo.basecurrency
accountNeitherCurrency = not accountSameAsCounterCurrency and not accountSameAsBaseCurrency
// Get currency conversion rates if applicable
conversionCurrencyPair = accountSameAsCounterCurrency ? syminfo.tickerid : strategy.account_currency + syminfo.currency
conversionCurrencyRate = accountSameAsBaseCurrency or accountNeitherCurrency ? request.security(conversionCurrencyPair, "D", close, ignore_invalid_symbol=true) : 1.0
// Display the current conversion currency ticker (for debug purposes)
if barstate.islastconfirmedhistory
    table t = table.new(position.top_right, 1, 2, color.black)
    table.cell(t, 0, 0, "Conversion: " + conversionCurrencyPair + " (" + str.tostring(conversionCurrencyRate) + ")", text_color=color.white, text_size=size.small)
    table.cell(t, 0, 1, "Account: $" + str.tostring(zen.truncate(strategy.equity)), text_color=color.white, text_size=size.small)

//positionSize = Lots * 100000  // Convert lots to units
//lotSize = unitsToLots(positionSize)

base_order = base_order_lots * 100000
safe_order = safe_order_lots * 100000
base_S_order = base_S_order_lots * 100000
safe_S_order = safe_S_order_lots * 100000
//------------- END CURRENCY CONVERSION RATE CODE ------------- }//



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// rmi trend


// ** ---> Inputs ------------- {
showRMIplots = input.bool(false, "Show RMI Plots")
var bool rmi_positive               = false
var bool rmi_negative               = false
string rmi_RSI_group                = "RMI Settings"
string rmi_mom_group                = "Range Vales"
string rmi_visual                   = "Visuals" 
rmi_Length = 14
rmi_pmom = 66 //positive above
rmi_nmom = 30 //negative below
bool rmi_filleshow = true
color rmi_bull = color.new(color.rgb(0, 188, 212), 70) // 70% transparency
color rmi_bear = color.new(color.rgb(255, 82, 82), 70) // 70% transparency
float rmi_BarRange                  = high - low

rmi_up = ta.rma(math.max(ta.change(close), 0), rmi_Length)
rmi_down = ta.rma(-math.min(ta.change(close), 0), rmi_Length)
rmi_rsi = rmi_down == 0 ? 100 : rmi_up == 0 ? 0 : 100 - (100 / (1 + rmi_up / rmi_down))
rmi_mf = ta.mfi(hlc3, rmi_Length)
rmi_rsi_mfi = math.avg(rmi_rsi,rmi_mf)


//------------------- }

bool rmi_p_mom                          = rmi_rsi_mfi[1] < rmi_pmom and
      rmi_rsi_mfi > rmi_pmom and
      rmi_rsi_mfi > rmi_nmom and
       ta.change(ta.ema(close,5)) > 0

bool rmi_n_mom                          = rmi_rsi_mfi < rmi_nmom and
      ta.change(ta.ema(close,5)) < 0
// //  ---> Momentums ------------- {

if rmi_p_mom
    rmi_positive:= true
    rmi_negative:= false

if rmi_n_mom
    rmi_positive:= false
    rmi_negative:= true     


method rmi_Band(int len)=>
    math.min (ta.atr (len) * 0.3, close * (0.3/100)) [20] /2 * 8 


rmi_Band = rmi_Band(30) 


method rmi_rangeMA(float Range,Prd)=>
    weight = Range / math.sum(Range, Prd)
    sum = math.sum(close * weight, Prd)
    tw= math.sum(weight, Prd)
    sum / tw


// Calculate the RWMA
rmi_rwma = rmi_rangeMA(rmi_BarRange,20)

// Plotting the RWMA.
rmi_RWMA = rmi_positive ? rmi_rwma - rmi_Band : rmi_negative ? rmi_rwma + rmi_Band : na

rmi_max = rmi_RWMA + rmi_Band
rmi_min = rmi_RWMA - rmi_Band


rmi_buy = rmi_positive and not rmi_positive[1]
rmi_sell = rmi_negative and not rmi_negative[1]

rmi_buy_filter = rmi_positive
rmi_sell_filter = rmi_negative

// end rmi trend
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// supertrend
source = close
groupTitleST1 = "SuperTrend1"
atrPeriod = input.int(20,    "ATR Length", minval = 1, group = groupTitleST1)
factor =    input.float(20.0, "Factor",     minval = 0.01, step = 0.01, group = groupTitleST1)
showSTplot = input.bool(defval=false, title="Show Supertrend Plots", group = groupTitleST1)

[supertrend, ST_direction] = ta.supertrend(factor, atrPeriod)

supertrend := barstate.isfirst ? na : supertrend


upTrend =    plot(showSTplot and ST_direction < 0 ? supertrend : na, "Up Trend",   color = TTBColors.colorUp(), style = plot.style_linebr)
downTrend =  plot(showSTplot and ST_direction > 0 ? supertrend : na, "Down Trend", color = TTBColors.colorDown(),   style = plot.style_linebr)



STlongTrigger = ta.crossover(close, supertrend)
STshortTrigger = ta.crossunder(close, supertrend)
STlongFilter = ST_direction < 0
STshortFilter = ST_direction > 0

// supertrend2
source2 = close
groupTitleST2 = "SuperTrend2"
atrPeriod2 = input.int(20, "ATR Length for ST2", minval = 1, group = groupTitleST2)
factor2 = input.float(40.0, "Factor for ST2", minval = 0.01, step = 0.01, group = groupTitleST2)
showST2plot = input.bool(defval=false, title="Show Supertrend2 Plots", group = groupTitleST2)

[supertrend2, ST_direction2] = ta.supertrend(factor2, atrPeriod2)

supertrend2 := barstate.isfirst ? na : supertrend2

upTrend2 = plot(showST2plot and ST_direction2 < 0 ? supertrend2 : na, "Up Trend ST2", color = TTBColors.colorUp(), style = plot.style_linebr)
downTrend2 = plot(showST2plot and ST_direction2 > 0 ? supertrend2 : na, "Down Trend ST2", color = TTBColors.colorDown(), style = plot.style_linebr)
//bodyMiddle2 = plot(showST2plot and barstate.isfirst ? na : (open + close) / 2, "Body Middle ST2",display = display.none)



ST2longTrigger = ta.crossover(close, supertrend2)
ST2shortTrigger = ta.crossunder(close, supertrend2)
ST2longFilter = ST_direction2 < 0
ST2shortFilter = ST_direction2 > 0


// end supertrend
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// half trend
groupTitleHalfTrend = "Half Trend"
amplitude = input(title='Amplitude', defval=12, group = groupTitleHalfTrend)
channelDeviation = input(title='Channel Deviation', defval=4, group = groupTitleHalfTrend)
showArrows = input(title='Show Arrows', defval=false, group = groupTitleHalfTrend)
showChannels = input(title='Show Channels', defval=false, group = groupTitleHalfTrend)

var int trend = 0
var int nextTrend = 0
var float maxLowPrice = nz(low[1], low)
var float minHighPrice = nz(high[1], high)

var float up = 0.0
var float down = 0.0
float atrHigh = 0.0
float atrLow = 0.0
float arrowUp = na
float arrowDown = na

atr2 = ta.atr(100) / 2
dev = channelDeviation * atr2

highPrice = high[math.abs(ta.highestbars(amplitude))]
lowPrice = low[math.abs(ta.lowestbars(amplitude))]
highma = ta.sma(high, amplitude)
lowma = ta.sma(low, amplitude)

if nextTrend == 1
    maxLowPrice := math.max(lowPrice, maxLowPrice)

    if highma < maxLowPrice and close < nz(low[1], low)
        trend := 1
        nextTrend := 0
        minHighPrice := highPrice
        minHighPrice
else
    minHighPrice := math.min(highPrice, minHighPrice)

    if lowma > minHighPrice and close > nz(high[1], high)
        trend := 0
        nextTrend := 1
        maxLowPrice := lowPrice
        maxLowPrice

if trend == 0
    if not na(trend[1]) and trend[1] != 0
        up := na(down[1]) ? down : down[1]
        arrowUp := up - atr2
        arrowUp
    else
        up := na(up[1]) ? maxLowPrice : math.max(maxLowPrice, up[1])
        up
    atrHigh := up + dev
    atrLow := up - dev
    atrLow
else
    if not na(trend[1]) and trend[1] != 1
        down := na(up[1]) ? up : up[1]
        arrowDown := down + atr2
        arrowDown
    else
        down := na(down[1]) ? minHighPrice : math.min(minHighPrice, down[1])
        down
    atrHigh := down + dev
    atrLow := down - dev
    atrLow

ht = trend == 0 ? up : down

var color buyColor = TTBColors.colorUp()
var color sellColor = TTBColors.colorDown()

htColor = trend == 0 ? buyColor : sellColor


buySignal = not na(arrowUp) and trend == 0 and trend[1] == 1
sellSignal = not na(arrowDown) and trend == 1 and trend[1] == 0

plotshape(showArrows and buySignal ? atrLow : na, title='Arrow Up', style=shape.triangleup, location=location.absolute, size=size.tiny, color=color.new(buyColor, 0))
plotshape(showArrows and sellSignal ? atrHigh : na, title='Arrow Down', style=shape.triangledown, location=location.absolute, size=size.tiny, color=color.new(sellColor, 0))




// end half trend
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
//dominant macd

// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//
//======================
//Adapted FROM http://www.davenewberg.com/Trading/TS_Code/Ehlers_Indicators/Cycle_Period_Calculator.html
//======================


Price = hl2
//alpha1 = input.float(0.07, minval=0, maxval=1)
alpha1 = 0.07
Smooth = (Price + 2 * Price[1] + 2 * Price[2] + Price[3]) / 6
Cycle = 0.
InstPeriod = 0.
Q1 = 0.
DeltaPhase = 0.
I1 = 0.
DominantPeriod = 0.

Cycle := (1 - .5 * alpha1) * (1 - .5 * alpha1) * (Smooth - 2 * Smooth[1] + Smooth[2]) + 2 * (1 - alpha1) * nz(Cycle[1]) - (1 - alpha1) * (1 - alpha1) * nz(Cycle[2])
Q1 := (.0962 * Cycle + .5769 * Cycle[2] - .5769 * Cycle[4] - .0962 * Cycle[6]) * (.5 + .08 * nz(InstPeriod[1]))
I1 := Cycle[3]
DeltaPhase := Q1 != 0 and Q1[1] != 0 ? (I1 / Q1 - I1[1] / Q1[1]) / (1 + I1 * I1[1] / (Q1 * Q1[1])) : na
DeltaPhase := DeltaPhase < 0.1 ? 0.1 : DeltaPhase
DeltaPhase := DeltaPhase > 1.1 ? 1.1 : DeltaPhase
MedianDelta = ta.percentile_nearest_rank(DeltaPhase, 5, 50)
DC = MedianDelta == 0 ? 15 : 6.28318 / MedianDelta + 0.5
InstPeriod := .33 * DC + .67 * nz(InstPeriod[1])
DominantPeriod := .15 * InstPeriod + .85 * nz(DominantPeriod[1])


fastper = int(DominantPeriod)
slowper = int(2 * DominantPeriod + 1)


pine_ema(src, length) =>
    _alpha = 2 / (length + 1)
    sum = 0.0
    sum := na(sum[1]) ? ta.sma(src, length) : _alpha * src + (1 - _alpha) * nz(sum[1])
    sum


//src = input(hl2, 'macd source')
src = hl2
slow_ema = pine_ema(src, nz(slowper, 26))
fast_ema = pine_ema(src, nz(fastper, 12))

MACD = fast_ema - slow_ema
signal_MACD = ta.ema(MACD, 9)



hist = MACD - signal_MACD


DomMCADRisingBuyFilter = MACD > MACD[1]
DomMCADFallingSellFilter = MACD < MACD[1]
DomMCAD_OB_BuyFilter = signal_MACD > 0
DomMCAD_OS_SellFilter= signal_MACD < 0
DomMCAD_OS_BuyFilter = signal_MACD < 0
DomMCAD_OB_SellFilter= signal_MACD > 0

//  end  dominant macd
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// Stochastic Optimized Trend Tracker SOTT

SOTT_periodK = 500
SOTT_smoothK = 200
SOTT_src1 = close
SOTT_length = 2
SOTT_percent = 0.5
SOTT_showsupport = false
SOTT_showsignalsc = false
SOTT_Var_Func1(SOTT_src1, SOTT_length) =>
    SOTT_valpha1 = 2 / (SOTT_length + 1)
    SOTT_vud11 = SOTT_src1 > SOTT_src1[1] ? SOTT_src1 - SOTT_src1[1] : 0
    SOTT_vdd11 = SOTT_src1 < SOTT_src1[1] ? SOTT_src1[1] - SOTT_src1 : 0
    SOTT_vUD1 = math.sum(SOTT_vud11, 9)
    SOTT_vDD1 = math.sum(SOTT_vdd11, 9)
    SOTT_vCMO1 = nz((SOTT_vUD1 - SOTT_vDD1) / (SOTT_vUD1 + SOTT_vDD1))
    SOTT_VAR1 = 0.0
    SOTT_VAR1 := nz(SOTT_valpha1 * math.abs(SOTT_vCMO1) * SOTT_src1) + (1 - SOTT_valpha1 * math.abs(SOTT_vCMO1)) * nz(SOTT_VAR1[1])
    SOTT_VAR1
SOTT_VAR1 = SOTT_Var_Func1(SOTT_src1, SOTT_length)
SOTT_k = SOTT_Var_Func1(ta.stoch(close, high, low, SOTT_periodK), SOTT_smoothK)
SOTT_src = SOTT_k + 1000
SOTT_Var_Func(SOTT_src, SOTT_length) =>
    SOTT_valpha = 2 / (SOTT_length + 1)
    SOTT_vud1 = SOTT_src > SOTT_src[1] ? SOTT_src - SOTT_src[1] : 0
    SOTT_vdd1 = SOTT_src < SOTT_src[1] ? SOTT_src[1] - SOTT_src : 0
    SOTT_vUD = math.sum(SOTT_vud1, 9)
    SOTT_vDD = math.sum(SOTT_vdd1, 9)
    SOTT_vCMO = nz((SOTT_vUD - SOTT_vDD) / (SOTT_vUD + SOTT_vDD))
    SOTT_VAR = 0.0
    SOTT_VAR := nz(SOTT_valpha * math.abs(SOTT_vCMO) * SOTT_src) + (1 - SOTT_valpha * math.abs(SOTT_vCMO)) * nz(SOTT_VAR[1])
    SOTT_VAR
SOTT_VAR = SOTT_Var_Func(SOTT_src, SOTT_length)
SOTT_h0 = hline(1080, 'Upper Band', color=#606060)
SOTT_h1 = hline(1020, 'Lower Band', color=#606060)
//fill(SOTT_h0, SOTT_h1, color=color.new(#9915FF, 80), title='Background')
//plot(SOTT_k + 1000, title='%K', color=color.new(#0094FF, 0))
SOTT_MAvg = SOTT_Var_Func(SOTT_src, SOTT_length)
SOTT_fark = SOTT_MAvg * SOTT_percent * 0.01
SOTT_longStop = SOTT_MAvg - SOTT_fark
SOTT_longStopPrev = nz(SOTT_longStop[1], SOTT_longStop)
SOTT_longStop := SOTT_MAvg > SOTT_longStopPrev ? math.max(SOTT_longStop, SOTT_longStopPrev) : SOTT_longStop
SOTT_shortStop = SOTT_MAvg + SOTT_fark
SOTT_shortStopPrev = nz(SOTT_shortStop[1], SOTT_shortStop)
SOTT_shortStop := SOTT_MAvg < SOTT_shortStopPrev ? math.min(SOTT_shortStop, SOTT_shortStopPrev) : SOTT_shortStop
SOTT_dir = 1
SOTT_dir := nz(SOTT_dir[1], SOTT_dir)
SOTT_dir := SOTT_dir == -1 and SOTT_MAvg > SOTT_shortStopPrev ? 1 : SOTT_dir == 1 and SOTT_MAvg < SOTT_longStopPrev ? -1 : SOTT_dir
SOTT_MT = SOTT_dir == 1 ? SOTT_longStop : SOTT_shortStop
SOTT_OTT = SOTT_MAvg > SOTT_MT ? SOTT_MT * (200 + SOTT_percent) / 200 : SOTT_MT * (200 - SOTT_percent) / 200
//plot(SOTT_showsupport ? SOTT_MAvg : na, color=color.new(#0585E1, 0), linewidth=2, title='Support Line')
SOTT_OTTC = #B800D9
SOTT_pALL = plot(nz(SOTT_OTT[2]), color=color.new(SOTT_OTTC, 0), linewidth=2, title='OTT')
//alertcondition(ta.cross(SOTT_src, SOTT_OTT[2]), title='Price Cross Alert', message='OTT - Price Crossing!')
//alertcondition(ta.crossover(SOTT_src, SOTT_OTT[2]), title='Price Crossover Alarm', message='PRICE OVER OTT - BUY SIGNAL!')
//alertcondition(ta.crossunder(SOTT_src, SOTT_OTT[2]), title='Price Crossunder Alarm', message='PRICE UNDER OTT - SELL SIGNAL!')
SOTT_buySignalc = ta.crossover(SOTT_src, SOTT_OTT[2])
//plotshape(SOTT_buySignalc and SOTT_showsignalsc ? SOTT_OTT * 0.995 : na, title='Buy', text='Buy', location=location.absolute, style=shape.labelup, size=size.tiny, //color=color.new(color.green, 0), textcolor=color.new(color.white, 0))
SOTT_sellSignallc = ta.crossunder(SOTT_src, SOTT_OTT[2])
//plotshape(SOTT_sellSignallc and SOTT_showsignalsc ? SOTT_OTT * 1.005 : na, title='Sell', text='Sell', location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.new(color.red, 0), textcolor=color.new(color.white, 0))

SOTTbullish = SOTT_src > SOTT_OTT[2]
SOTTbearish = SOTT_src < SOTT_OTT[2]
  
// END STOCHASTIC OPTIMIZED TREND TRACKER SOTT
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// Nadaraya Watson
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
NW_h = input.float(12.,'Bandwidth', minval = 0 , group = 'NW bandwith')
NW_mult = input.float(2.8, minval = 0, group = 'NW multiplier')
NW_src = input(close, 'Source', group = 'NW source')
NW_showPlots = input(false, 'Show NW Plots', group = 'NW plots')

NW_repaint = false

//Style
// NW_upCss = input.color(color.teal, 'Colors', inline = 'inline1', group = 'Style')
// NW_dnCss = input.color(color.red, '', inline = 'inline1', group = 'Style')

NW_upCss = color.teal
NW_dnCss = color.red

//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
//Gaussian window
NW_gauss(x, h) => math.exp(-(math.pow(x, 2)/(h * h * 2)))

//-----------------------------------------------------------------------------}
//Append lines
//-----------------------------------------------------------------------------{
NW_n = bar_index

var NW_ln = array.new_line(0) 

if barstate.isfirst and NW_repaint
    for i = 0 to 499
        array.push(NW_ln,line.new(na,na,na,na))

//-----------------------------------------------------------------------------}
//End point method
//-----------------------------------------------------------------------------{
var NW_coefs = array.new_float(0)
var NW_den = 0.

if barstate.isfirst and not NW_repaint
    for i = 0 to 499
        w = NW_gauss(i, NW_h)
        NW_coefs.push(w)

    NW_den := NW_coefs.sum()

NW_out = 0.
if not NW_repaint
    for i = 0 to 499
        NW_out += NW_src[i] * NW_coefs.get(i)
NW_out /= NW_den
NW_mae = ta.sma(math.abs(NW_src - NW_out), 499) * NW_mult

NW_upper = NW_out + NW_mae
NW_lower = NW_out - NW_mae
 
//-----------------------------------------------------------------------------}
//Compute and display NWE
//-----------------------------------------------------------------------------{
float NW_y2 = na
float NW_y1 = na

NW_nwe = array.new<float>(0)
if barstate.islast and NW_repaint
    NW_sae = 0.
    //Compute and set NWE point 
    for i = 0 to math.min(499,NW_n - 1)
        sum = 0.
        sumw = 0.
        //Compute weighted mean 
        for j = 0 to math.min(499,NW_n - 1)
            w = NW_gauss(i - j, NW_h)
            sum += NW_src[j] * w
            sumw += w

        NW_y2 := sum / sumw
        NW_sae += math.abs(NW_src[i] - NW_y2)
        NW_nwe.push(NW_y2)
    
    NW_sae := NW_sae / math.min(499,NW_n - 1) * NW_mult
    for i = 0 to math.min(499,NW_n - 1)
        if i%2 == 0
            line.new(NW_n-i+1, NW_y1 + NW_sae, NW_n-i, NW_nwe.get(i) + NW_sae, color = NW_upCss)
            line.new(NW_n-i+1, NW_y1 - NW_sae, NW_n-i, NW_nwe.get(i) - NW_sae, color = NW_dnCss)
        
        if NW_src[i] > NW_nwe.get(i) + NW_sae and NW_src[i+1] < NW_nwe.get(i) + NW_sae
            label.new(NW_n-i, NW_src[i], '▼', color = color(na), style = label.style_label_down, textcolor = NW_dnCss, textalign = text.align_center)
        if NW_src[i] < NW_nwe.get(i) - NW_sae and NW_src[i+1] > NW_nwe.get(i) - NW_sae
            label.new(NW_n-i, NW_src[i], '▲', color = color(na), style = label.style_label_up, textcolor = NW_upCss, textalign = text.align_center)
        
        NW_y1 := NW_nwe.get(i)


//Crossing Arrows
plotshape(NW_showPlots and ta.crossunder(close, NW_out - NW_mae) ? low : na, "Crossunder", shape.labelup, location.absolute, color(na), 0 , text = '▲', textcolor = NW_upCss, size = size.tiny)
plotshape(NW_showPlots and ta.crossover(close, NW_out + NW_mae) ? high : na, "Crossover", shape.labeldown, location.absolute, color(na), 0 , text = '▼', textcolor = NW_dnCss, size = size.tiny)

NWbuy = ta.crossunder(close, NW_out - NW_mae)
NWsell = ta.crossover(close, NW_out + NW_mae)

//-----------------------------------------------------------------------------}

// end nadaraya watson
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}



//-----------------------------------------------------------------------------}
// Structure
groupTitleStructureSettings = "Structure Settings"
MSlength  = input(14, 'Pivot Lookback', group = groupTitleStructureSettings)
incr    = input.float(80, 'Increment Factor %', minval = 0, group = groupTitleStructureSettings)
StrucTF1 = input(title="StrucTF1", defval="60", group = groupTitleStructureSettings)
showMS  = input(false, "Show Structures", group = groupTitleStructureSettings)
showStrucPlots  = input(false, "Show Struc Plots", group = groupTitleStructureSettings)

resetOn = 'CHoCH'

//Style 
bullCss    = color.rgb(7, 232, 187, 34)
bearCss    = color.rgb(250, 36, 214, 37)
retCss     = #ffbb00
areaTransp = 90

//------------------------------------------------------------------------------
//Global variables
//-----------------------------------------------------------------------------{
var float ph_y = na , var int ph_x = na
var float pl_y = na , var int pl_x = na
var float top = na  , var float btm = na
var ph_cross = false, var pl_cross = false

var float max = na
var float min = na
var float ts = na

var os = 0
ms = 0

//------------------------------------------------------------------------------
//Detect pivots and get coordinates
//-----------------------------------------------------------------------------{
n = bar_index
ph = ta.pivothigh(MSlength, MSlength)
pl = ta.pivotlow(MSlength, MSlength)

if ph > 0
    ph_y := ph
    ph_x := n - MSlength
    ph_cross := false

if pl > 0
    pl_y := pl
    pl_x := n - MSlength
    pl_cross := false


//-----------------------------------------------------------------------------}
//Bullish structures
//-----------------------------------------------------------------------------{
if close > ph_y and not ph_cross
    if resetOn == 'CHoCH'
        ms := os == -1 ? 1 : 0
    else
        ms := 1

    ph_cross := true

    //Highilight bullish MS
    if showMS
        line.new(ph_x, ph_y, n, ph_y
          , color = bullCss
          , style = os == -1 ? line.style_dashed : line.style_dotted)

    os := 1

    //Search for local minima
    btm := low
    for i = 0 to (n - ph_x)-1
        btm := math.min(low[i], btm)

    osChange = os != os[1]

//-----------------------------------------------------------------------------}
//Bearish structures
//-----------------------------------------------------------------------------{
if close < pl_y and not pl_cross
    if resetOn == 'CHoCH'
        ms := os == 1 ? -1 : 0
    else
        ms := -1

    pl_cross := true

    //Highilight bearish MS
    if showMS
        line.new(pl_x, pl_y, n, pl_y
          , color = bearCss
          , style = os == 1 ? line.style_dashed : line.style_dotted)

    os := -1

    //Search for local maxima
    top := high
    for i = 0 to (n - pl_x)-1
        top := math.max(high[i], top)

    osChange = os != os[1]

//-----------------------------------------------------------------------------}
//Trailing stop
//-----------------------------------------------------------------------------{
//Trailing max/min
if ms == 1
    max := close
else if ms == -1
    min := close
else
    max := math.max(close, max)
    min := math.min(close, min)

//Trailing stop
ts := ms == 1 ? btm
  : ms == -1 ? top
  : os == 1 ? ts + (max - max[1]) * incr / 100
  : ts + (min - min[1]) * incr / 100

//-----------------------------------------------------------------------------}
//Plots
//-----------------------------------------------------------------------------{
css = (ms > 0) ? na 
  : os == 1 ? bullCss
  : bearCss

// plot_price = plot(close, editable = false, display = display.none)
// plot_ts    = plot(ts, 'Trailing Stop', color = css)

plot_price = plot(showStrucPlots ? close : na, editable = false, display = display.none)
plot_ts    = plot(showStrucPlots ? ts : na, 'Trailing Stop', color = css)

css_area = (close - ts) * os < 0 ? retCss
  : css

//fill(plot_price, plot_ts, color.new(css_area, areaTransp))
fill(plot_price, plot_ts, color.new(showStrucPlots ? css_area : na, areaTransp))

// trend change plots
osChange = os != os[1]

trendUp = os == 1 and osChange
trendDown = os == -1 and osChange

trendingUp = os == 1
trendingDown = os == -1


stf1 = request.security(syminfo.tickerid, StrucTF1, os, lookahead=barmerge.lookahead_off)
trendingUp1H = stf1 == 1
trendingDown1H = stf1 == -1
// end structure
//-----------------------------------------------------------------------------}


// Date Ranges
show_table = input(true, title='Show table')
text_size_switch = true
from_month = input.int(defval=5, title='From Month', minval=1, maxval=12)
from_day = input.int(defval=1, title='From Day', minval=1, maxval=31)
from_year = input(defval=2021, title='From Year')
to_month = input.int(defval=12, title='To Month', minval=1, maxval=12)
to_day = input.int(defval=1, title='To Day', minval=1, maxval=31)
to_year = input(defval=2024, title='To Year')
start = timestamp(from_year, from_month, from_day, 00, 00)  // backtest start window
finish = timestamp(to_year, to_month, to_day, 23, 59)  // backtest finish window
window = time >= start and time <= finish ? true : false  // create function "within window of time"


// Triggers
long_trigger = input(title='Long trigger value', defval=1)
short_trigger = input(title='Short trigger value', defval=-1)
trigger = input(defval=close, title="Enter trigger")

var current_so = 0
var current_S_so = 0
var initial_order = 0.0
var initial_S_order = 0.0
var original_ttp_value = 0.0
var quantity = 0.0
var entry_price = 0.0
var firstBarTime = 0.0
var maxDiffDays = 0.0
var soCount = 0
var SO1 = 0
var SO2 = 0
var SO3 = 0
var SO4 = 0
var SO5 = 0
var SO6 = 0
var SO7 = 0
var noSO = 0
var initial_price = 0.0
var initial_S_price = 0.0
var price_drop = 0.0
var price_pump = 0.0
var max_drop = 0.0
var max_pump = 0.0
var pump_date = 0
var pump_month = 0
var drop_date = 0
var drop_month = 0
var longest_trade_day = 0
var longest_trade_month = 0
var take_profit_level = 0.0
var take_S_profit_level = 0.0
var tp_plot = 0.0
var tp_S_plot = 0.0
var threshold = 0.0
var S_threshold = 0.0
timeDiff = time - firstBarTime
maxDev = 0.0
maxSDev = 0.0
closedTrades = 0
var tradeCount = 0
var i = 0
var avg_price = 0.0
var total_funds_in_trade = 0.0
var total_qty_in_trade = 0.0
var capital = 100.0

// Turn that time difference into days
diffDays = timeDiff / 86400000

// Calculate our TP levels
take_profit_level := avg_price * (1 + take_profit)
take_S_profit_level := avg_price * (1 - take_S_profit)


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
//Long and short entry
///Strategy Inputs
groupTitleLongEntry = "Long Entry"
trigger_long_Input = input.bool(false, "Trigger Long", group = groupTitleLongEntry)
Struc_trigger_long_Input = input.bool(false, "Struc Trigger Long", group = groupTitleLongEntry)
NWbuyTriggerInput = input.bool(false, "NW Buy Trigger", group = groupTitleLongEntry)
rmi_buyInput = input.bool(false, "RMI Buy", group = groupTitleLongEntry)
STlongTriggerInput = input.bool(false, "ST Long Trigger", group = groupTitleLongEntry)
ST2longTriggerInput = input.bool(false, "ST2 Long Trigger", group = groupTitleLongEntry)
HTbuyInput = input.bool(false, "HT Buy", group = groupTitleLongEntry)
rmi_buy_filterInput = input.bool(false, "RMI Buy Filter", group = groupTitleLongEntry)
STlongFilterInput = input.bool(false, "ST Long Filter", group = groupTitleLongEntry)
ST2longFilterInput = input.bool(false, "ST2 Long Filter", group = groupTitleLongEntry)
DomMCADRisisingBuyFilterInput = input.bool(false, "DomMCAD Rising Buy Filter", group = groupTitleLongEntry)
DomMCAD_OB_BuyFilterInput = input.bool(false, "DomMCAD OB Buy Filter", group = groupTitleLongEntry)
DomMCAD_OS_BuyFilterInput = input.bool(false, "DomMCAD OS Buy Filter", group = groupTitleLongEntry)
SOTTbullishFilterInput = input.bool(false, "SOTT bullish Filter", group = groupTitleLongEntry)
trendingUp1HFilterInput = input.bool(false, "1H Trending Up Filter", group = groupTitleLongEntry)



groupTitleShortEntry = "Short Entry"
trigger_short_Input = input.bool(false, "Trigger Short", group = groupTitleShortEntry)
Struc_trigger_short_Input = input.bool(false, "Struc Trigger Short", group = groupTitleShortEntry)
rmi_sellInput = input.bool(false, "RMI Sell", group = groupTitleShortEntry)
rmi_sell_filterInput = input.bool(false, "RMI Sell Filter", group = groupTitleShortEntry)
STshortTriggerInput = input.bool(false, "ST Short Trigger", group = groupTitleShortEntry)
STshortFilterInput = input.bool(false, "ST Short Filter", group = groupTitleShortEntry)
ST2shortTriggerInput = input.bool(false, "ST2 Short Trigger", group = groupTitleShortEntry)
ST2shortFilterInput = input.bool(false, "ST2 Short Filter", group = groupTitleShortEntry)
HTsellInput = input.bool(false, "HT Sell", group = groupTitleShortEntry)
DomMCADFallingSellFilterInput = input.bool(false, "DomMCAD Falling Sell Filter", group = groupTitleShortEntry)
DomMCAD_OS_SellFilterInput = input.bool(false, "DomMCAD OS Sell Filter", group = groupTitleShortEntry)
DomMCAD_OB_SellFilterInput = input.bool(false, "DomMCAD OB Sell Filter", group = groupTitleShortEntry)
SOTTbearishFilterInput = input.bool(false, "SOTT bearish Filter", group = groupTitleShortEntry)
NWsellTriggerInput = input.bool(false, "NW Sell Trigger", group = groupTitleShortEntry)
trendingDown1HFilterInput = input.bool(false, "1H Trending Down Filter", group = groupTitleShortEntry)

groupTitleSOsExit = "SOs and Exit"
use_rmi_filter_for_subsequent_sos = input.bool(true, "Use RMI Filter for subsequent SOs", group = groupTitleSOsExit)
use_ST2longFilter_for_SO3 = input.bool(false, "Use ST2longFilter for SO 3", group = groupTitleSOsExit)
use_ST2shortFilter_for_SO3 = input.bool(false, "Use ST2shortFilter for SO 3", group = groupTitleSOsExit)
use_ST2longTrigger_for_SO3 = input.bool(false, "Use ST2longTrigger for SO 3", group = groupTitleSOsExit)
use_ST2shortTrigger_for_SO3 = input.bool(false, "Use ST2shortTrigger for SO 3", group = groupTitleSOsExit)

// First Position
//for i = 0 to max_safe_order - 1 by 1
for j = 0 to max_safe_order - 1 by 1
    maxDev := int((maxDev + price_deviation * 100 * math.pow(safe_order_step_scale, i)) * 100) / 100
    maxDev
//for i = 0 to max_S_safe_order - 1 by 1
for j = 0 to max_S_safe_order - 1 by 1
    maxSDev := int((maxSDev + price_S_deviation * 100 * math.pow(safe_S_order_step_scale, i)) * 100) / 100
    maxSDev


if long and strategy.position_size == 0 and source_function(source_type) > 0 and window and not(hour(time) == 0 and minute(time) < 59) and (rmi_buyInput ? rmi_buy : true) and (STlongTriggerInput ? STlongTrigger : true) and (STlongFilterInput ? STlongFilter : true) and (ST2longTriggerInput ? ST2longTrigger : true) and (ST2longFilterInput ? ST2longFilter : true) and (trigger_long_Input ? trigger == long_trigger : true) and (HTbuyInput ? buySignal : true) and (DomMCADRisisingBuyFilterInput ? DomMCADRisingBuyFilter : true) and (DomMCAD_OB_BuyFilterInput ? DomMCAD_OB_BuyFilter : true) and (DomMCAD_OS_BuyFilterInput ? DomMCAD_OS_BuyFilter : true) and (rmi_buy_filterInput ? rmi_buy_filter : true) and (SOTTbullishFilterInput ? SOTTbullish : true) and (NWbuyTriggerInput ? NWbuy : true) and (trendingUp1HFilterInput ? trendingUp1H : true) and (Struc_trigger_long_Input ? trendUp : true)
    _string_long = 'type=order,order-type=long,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order_lots) + ',comment="' + version + '-' + test + '",entry=true'
    strategy.entry('Long @' + str.tostring(source_function(source_type)), strategy.long, qty=base_order_lots * 100000, alert_message=_string_long)
    initial_order := source_function(source_type)
    current_so := 1
    initial_price := close
    price_drop := close
    original_ttp_value := 0
    firstBarTime := time
    tradeCount += 1
    avg_price := close
    total_funds_in_trade := avg_price * base_order_lots * 100000
    total_qty_in_trade := base_order_lots * 100000


else if short and strategy.position_size == 0 and source_function(source_type) > 0 and window and not(hour(time) == 0 and minute(time) < 59) and (rmi_sellInput ? rmi_sell : true) and (STshortTriggerInput ? STshortTrigger : true) and (STshortFilterInput ? STshortFilter : true) and (ST2shortTriggerInput ? ST2shortTrigger : true) and (ST2shortFilterInput ? ST2shortFilter : true) and (trigger_short_Input ? trigger == short_trigger : true) and (HTsellInput ? sellSignal : true)  and (DomMCADFallingSellFilterInput ? DomMCADFallingSellFilter : true) and (DomMCAD_OS_SellFilterInput ? DomMCAD_OS_SellFilter : true) and (DomMCAD_OB_SellFilterInput ? DomMCAD_OB_SellFilter : true) and (rmi_sell_filterInput ? rmi_sell_filter : true) and (SOTTbearishFilterInput ? SOTTbearish : true) and (NWsellTriggerInput ? NWsell : true) and (trendingDown1HFilterInput ? trendingDown1H : true) and (Struc_trigger_short_Input ? trendDown : true)
    _string_short = 'type=order,order-type=short,symbol=' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_S_order_lots) + ',comment="' + version + '-' + test + '",entry=true'
    strategy.entry('Short @' + str.tostring(source_function(source_type)), strategy.short, qty=base_S_order_lots * 100000, alert_message=_string_short)
    initial_S_order := source_function(source_type)
    current_so := 1
    firstBarTime := time
    tradeCount += 1
    initial_S_price := close
    price_pump := close
    avg_price := close
    total_funds_in_trade := avg_price * base_S_order_lots * 100000
    total_qty_in_trade := base_S_order_lots * 100000


//makes the red and green line plot pretty at the position opening
if strategy.position_size == 0
    threshold := low[1]
    S_threshold := high[1]
    S_threshold


// Define last_so_price and percent_threshold
var float last_so_price = na
percent_threshold = input(0.01, "Percent Threshold")

// Modify the calculation of the threshold for long positions
if strategy.position_size > 0 and i == 0
    if safe_order_step_scale == 1.0
        threshold := na(last_so_price) or (close / last_so_price - 1) > percent_threshold ? initial_order - initial_order * price_deviation * safe_order_step_scale * safe_order_step_scale_Multiplier * current_so : na
    else
        threshold := na(last_so_price) or (close / last_so_price - 1) > percent_threshold ? initial_order - initial_order * (price_deviation * (math.pow(safe_order_step_scale * safe_order_step_scale_Multiplier, current_so) - 1) / (safe_order_step_scale - 1)) : na

// Modify the calculation of the threshold for short positions
if strategy.position_size < 0 and i == 0
    if safe_S_order_step_scale == 1.0
        S_threshold := na(last_so_price) or (close / last_so_price - 1) > percent_threshold ? initial_S_order * (1 + price_S_deviation * current_so) : na
    else
        S_threshold := na(last_so_price) or (close / last_so_price - 1) > percent_threshold ? initial_S_order * (1 + price_S_deviation * (math.pow(safe_S_order_step_scale * safe_order_step_scale_Multiplier, current_so) - 1) / (safe_S_order_step_scale - 1)) : na


// Long SO (Average Down)
if current_so > 0 and i == 0 and strategy.position_size > 0 and low <= threshold and current_so <= max_safe_order and not(hour(time) == 0 and minute(time) < 59) and (not use_rmi_filter_for_subsequent_sos or rmi_buy_filter) and (use_ST2longFilter_for_SO3 ? ST2longFilter : true) and (use_ST2longTrigger_for_SO3 ? ST2longTrigger : true)
    _string_long_so = 'type=order,order-type=long,symbol=' + str.replace(syminfo.ticker, " ", "") + '.PRO' + ',risk=' + str.tostring(base_order_lots * math.pow(safe_order_volume_scale, current_so - 1)) + ',comment="' + version + '-' + test + '",entry=false'
    strategy.entry('SO ' + str.tostring(current_so) + '@' + str.tostring(source_function(source_type)), strategy.long, qty=base_order * math.pow(safe_order_volume_scale, current_so - 1), alert_message=_string_long_so)
    total_funds_in_trade += threshold * base_order * math.pow(safe_order_volume_scale, current_so - 1)
    total_qty_in_trade += base_order * math.pow(safe_order_volume_scale, current_so - 1)
    avg_price := total_funds_in_trade / total_qty_in_trade
    current_so += 1
    tradeCount += 1
    if not na(threshold)
        last_so_price := close


// Short SO (Average Up)
if current_so > 0 and i == 0 and strategy.position_size < 0 and high >= S_threshold and current_so <= max_S_safe_order and not(hour(time) == 0 and minute(time) < 59) and (not use_rmi_filter_for_subsequent_sos or rmi_sell_filter) and (use_ST2shortFilter_for_SO3 ? ST2shortFilter : true) and (use_ST2shortTrigger_for_SO3 ? ST2shortTrigger : true)
    _string_short_so = 'type=order,order-type=short,symbol=' + str.replace(syminfo.ticker, " ", "") + '.PRO' + ',risk=' + str.tostring(base_S_order_lots * math.pow(safe_S_order_volume_scale, current_so - 1)) + ',comment="' + version + '-' + test + '",entry=false'
    strategy.entry('SSO ' + str.tostring(current_so) + '@' + str.tostring(source_function(source_type)), strategy.short, qty=base_S_order * math.pow(safe_S_order_volume_scale, current_so - 1), alert_message=_string_short_so)
    total_funds_in_trade += S_threshold * base_S_order * math.pow(safe_S_order_volume_scale, current_so - 1)
    total_qty_in_trade += base_S_order * math.pow(safe_S_order_volume_scale, current_so - 1)
    avg_price := total_funds_in_trade / total_qty_in_trade
    current_so += 1
    tradeCount += 1
    if not na(S_threshold)
        last_so_price := close



// Take Profit! 
if i == 1
    strategy.close_all() // Close all positions
    i := 0 // Reset the counter
    i

// If the take profit level is reached and the position is long, close the trade
if take_profit_level <= high and strategy.position_size > 0 and not(hour(time) == 0 and minute(time) < 59)
    _string_close_long = 'type=order,order-type=closelong,symbol=' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + '"' // Prepare the close long order string
    strategy.close_all(comment='Close @' + str.tostring(source_function(source_type)), alert_message=_string_close_long) // Close the long position
    soCount := current_so // Save the current scale-out count
    current_so := 0 // Reset the current scale-out count
    original_ttp_value := 0 // Reset the original take profit value
    price_drop := na // Reset the price drop value
    initial_price := na // Reset the initial price
    diffDays := time - firstBarTime // Calculate the difference in days
    if diffDays > maxDiffDays // If the difference in days is greater than the maximum difference in days
        maxDiffDays := diffDays // Update the maximum difference in days
        longest_trade_day := dayofmonth // Update the longest trade day
        longest_trade_month := month // Update the longest trade month
        longest_trade_month
    i := 1 // Reset the counter
    initial_order := 0.0 // Reset the initial order
    avg_price := na // Reset the average price
    capital *= (1 + total_qty_in_trade * take_profit / 100) // Update the capital


// Take Short Profit! 
// If the take short profit level is reached and the position is short, close the trade
if take_S_profit_level >= low and strategy.position_size < 0 and not(hour(time) == 0 and minute(time) < 59)
    _string_close_short = 'type=order,order-type=closeshort,symbol=' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + test + '"' // Prepare the close short order string
    strategy.close_all(comment='Close Short @' + str.tostring(source_function(source_type)), alert_message=_string_close_short) // Close the short position
    soCount := current_so // Save the current scale-out count
    current_so := 0 // Reset the current scale-out count
    price_pump := na // Reset the price pump value
    initial_S_price := na // Reset the initial short price
    diffDays := time - firstBarTime // Calculate the difference in days
    if diffDays > maxDiffDays // If the difference in days is greater than the maximum difference in days
        maxDiffDays := diffDays // Update the maximum difference in days
        maxDiffDays
    initial_S_order := 0.0 // Reset the initial short order
    avg_price := na // Reset the average price
    capital *= (1 + total_qty_in_trade * take_S_profit / 100) // Update the capital


//Table building and calculations
if strategy.position_size == 0
    if soCount == 1
        noSO += 1
        noSO
    else if soCount == 2
        SO1 += 1
        SO1
    else if soCount == 3
        SO2 += 1
        SO2
    else if soCount == 4
        SO3 += 1
        SO3
    else if soCount == 5
        SO4 += 1
        SO4
    else if soCount == 6
        SO5 += 1
        SO5
    else if soCount == 7
        SO6 += 1
        SO6
    else if soCount == 8
        SO7 += 1
        SO7
    soCount := 0
    soCount
closedTrades := noSO + SO1 * 2 + SO2 * 3 + SO3 * 4 + SO4 * 5 + SO5 * 6 + SO6 * 7 + SO7 * 8

if low < price_drop and window and strategy.position_size > 0
    price_drop := low
    if max_drop < int((1 - price_drop / initial_price) * 10000) / 100
        max_drop := int((1 - price_drop / initial_price) * 10000) / 100
        drop_date := dayofmonth(time)
        drop_month := month(time)
        drop_month
bgcolor(max_drop[1] < max_drop ? color.new(color.rgb(11, 90, 100), 50) : na)

if high > price_pump and window and strategy.position_size < 0
    price_pump := high
    if max_pump < int((price_pump / initial_S_price - 1) * 10000) / 100
        max_pump := int((price_pump / initial_S_price - 1) * 10000) / 100
        pump_date := dayofmonth(time)
        pump_month := month(time)
        pump_month
bgcolor(max_pump[1] < max_pump ? color.new(color.rgb(155, 39, 176), 70) : na)

if take_profit_level > 0 and strategy.position_size > 0
    tp_plot := take_profit_level
    tp_plot
else
    tp_plot := close
    tp_plot

if take_S_profit_level > 0 and strategy.position_size < 0
    tp_S_plot := take_S_profit_level
    tp_S_plot
else
    tp_S_plot := close
    tp_S_plot

//Plotting the levels
p1 = plot(tp_plot, color=strategy.position_size <= 0 ? na : TTBColors.colorUp()) // Up color
p2 = plot(avg_price, color=strategy.position_size == 0 ? na : TTBColors.colorNeutral()) // Neutral color
p3 = plot(threshold, color=strategy.position_size <= 0 ? na : TTBColors.colorDown()) // Down color
p4 = plot(tp_S_plot, color=strategy.position_size >= 0 ? na : TTBColors.colorUpPlus()) // UpPlus color
p5 = plot(S_threshold, color=strategy.position_size >= 0 ? na : TTBColors.colorDownPlus()) // DownPlus color
fill(p1, p2, color=strategy.position_size > 0 ? color.new(TTBColors.colorUp(), 90) : na) // Semi-transparent Up color
fill(p2, p3, strategy.position_size > 0 ? color.new(TTBColors.colorNeutral(), 90) : na) // Semi-transparent Neutral color
fill(p4, p2, color=strategy.position_size < 0 ? color.new(TTBColors.colorUpPlus(), 90) : na) // Semi-transparent UpPlus color
fill(p5, p2, color=strategy.position_size < 0 ? color.new(TTBColors.colorDownPlus(), 90) : na) // Semi-transparent DownPlus color
profit_color = strategy.openprofit < 0 ? TTBColors.colorDown() : TTBColors.colorUp() // Down color for loss, Up color for profit

text_size = text_size_switch ? size.small : size.normal


//Table formatting
if show_table
    var Table = table.new(position.bottom_right, columns=2, rows=20, border_width=1, bgcolor=color.new(#363a45, 0), border_color=color.gray)
    table.cell(table_id=Table, column=0, row=0, text_color=color.gray, text_size=text_size, text='Net Profit')
    table.cell(table_id=Table, column=1, row=0, text=str.tostring(int((capital - 100) * 100) / 100) + '%', text_size=text_size, text_color=TTBColors.colorUplight())
    table.cell(table_id=Table, column=0, row=1, text_color=color.gray, text_size=text_size, text='Max Deviation ')
    table.cell(table_id=Table, column=1, row=1, text=str.tostring(maxDev) + '%', text_size=text_size, text_color=TTBColors.colorDownlight())
    table.cell(table_id=Table, column=0, row=2, text_color=color.gray, text_size=text_size, text='Max Short Dev ')
    table.cell(table_id=Table, column=1, row=2, text=str.tostring(maxSDev) + '%', text_size=text_size, text_color=TTBColors.colorDownlight())
    table.cell(table_id=Table, column=0, row=3, text='No SO ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=3, text=str.tostring(noSO), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=4, text='SO 1 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=4, text=str.tostring(SO1), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=5, text='SO 2 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=5, text=str.tostring(SO2), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=6, text='SO 3 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=6, text=str.tostring(SO3), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=7, text='SO 4 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=7, text=str.tostring(SO4), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=8, text='SO 5 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=8, text=str.tostring(SO5), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=9, text='SO 6 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=9, text=str.tostring(SO6), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=10, text='SO 7 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=10, text=str.tostring(SO7), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=11, text='Closed/Open trades', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=11, text=str.tostring(strategy.closedtrades) + '/' + str.tostring(strategy.opentrades), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=12, text='Current Deal Time', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=12, text=strategy.position_size != 0 ? str.tostring(int((time - firstBarTime) / 8640000) / 10) + ' days' : '0', text_size=text_size, text_color=color.green)
    table.cell(table_id=Table, column=0, row=13, text='Unrealized position', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=13, text=str.tostring(int(strategy.openprofit / (strategy.initial_capital + strategy.netprofit) * 10000) / 100) + ' %', text_size=text_size, text_color=profit_color)
    table.cell(table_id=Table, column=0, row=14, text='Longest deal:', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=14, text=str.tostring(int(maxDiffDays / 8640000) / 10) + ' days, ' + str.tostring(longest_trade_day) + '/' + str.tostring(longest_trade_month), text_size=text_size, text_color=TTBColors.colorDownlight())
    table.cell(table_id=Table, column=0, row=15, text='Max price drop:', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=15, text=str.tostring(max_drop) + ' %, ' + str.tostring(drop_date) + '/' + str.tostring(drop_month), text_size=text_size, text_color=TTBColors.colorDownlight())
    table.cell(table_id=Table, column=0, row=16, text='Max price pump:', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=16, text=str.tostring(max_pump) + ' %, ' + str.tostring(pump_date) + '/' + str.tostring(pump_month), text_size=text_size, text_color=TTBColors.colorDownlight())



// 1. Define Safety Order Levels: We have a script that calculates safety order (SO) levels for both long and short positions. These levels are calculated based on the initial order price and a certain percentage deviation.

// 2. Add Indicator-Based Conditions: We want to optionally add indicator-based conditions to the safety orders. These conditions include (not use_rmi_filter_for_subsequent_sos or rmi_buy_filter) and (use_ST2longFilter_for_SO3 ? ST2longFilter : true) and (use_ST2longTrigger_for_SO3 ? ST2longTrigger : true).

// 3. Modify SO Levels Based on Conditions: If these indicator-based conditions are met, we want to modify the safety order levels to be a percentage change from the last safety order price. This percentage is defined by percent_threshold.

// 4. Update Last SO Price: Every time a safety order is placed, we want to update last_so_price to the current close price.

// 5. Check Conditions for Placing SO: Before placing a safety order, we want to check if last_so_price is na (which it will be before the first safety order is placed) or if the percentage change from last_so_price to the current close price is greater than percent_threshold. If these conditions are met, a safety order is placed.

// In summary, we're trying to create a more dynamic system for placing safety orders based on both hard levels and indicator-based conditions. This system will allow us to place safety orders at more optimal levels based on the current market conditions.