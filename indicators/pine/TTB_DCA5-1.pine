//This is a TradingView "stategy" script that allows backtesting and automating trading alerts for running an automated trading system.

// ## long_trigger and short_trigger are the (entry signal) generated from indicator logic indcluded

// ## Safety Orders (SOs)
// code for this in these commented sections "Average Down - SOs for Longs" and  "Short Average Up - SOs for Shorts"

// Safe Orders (SOs): Activated when price goes against the initial entry to protect against adverse movements.

// Where should the 1st SO happen if price goes against entry?  Based on either a set percentage against entry OR signals from another indicator.

// Max no. of sate orders: This defines the max number of SOs allowed.

// Where should 1st SO order happen? = "Price Deviation To Open Safety Trades (%)" (the percent deviation against original entry)

// Price deviation to open safety orders (%): Open SO orders every N% of price movement. The price and size are calculated according to settings (step scale, volume scale)

// Size of 1st SO? =  Safe order (lots)

// Size of Subsequent SOs = What is the size/volume of the next SO? "Safety Order Volume Scale" * "Safety order volume scale"

// Location of Additional SOs: What % from previous SO should the next SO be? "Safety order step scale" * "Price Deviation To Open Safety Trades (%)" 

// ## Deal End
// Take Profit: End deal when the "Target Take Profit (%)"

// Main logic of strategy is from  section commented "// Strat logic" to "Take Short Profit!"



// notes...
// Added:
// 1) an internal average price and profit calculating, instead of TV`s native one, which is subject to severe slippage.
// 2) I`ve built a graphic interface, so levels are clearly visible and backtest analyzing made easier.
// 3) now both Long & Short direction of the strategy exist.
// 4) trailing TP which was featured in the initial script has been removed because TV`s execution model makes 
//    it impossible to know how the real world trailing would have unfolded.
// 5) the table is self explanatory, and it is there to help you discover what happened and where. 
// 6) vertical colored lines appear when the new maximum deviation from the original price has
//    been reached
//    All the trading happens with total account capital, and all order sizes inputs are in percents
//
//   Known issues:
//
// When deviation is small, and the same candle triggers safety AND the close order, the initial orders are closed, but a 
// new one opens on the next candle. This is "resolved" by closing the unwanted trade forcefully on the next candle, affecting 
// profit calculating minimally and guaranteeing that what should be closed has been closed.
//
// The code could be improved through use of arrays, making the table flexible so the number of rows should be dynamic depending
// on the number of SOs.
//
//  !!!!! IMPORTANT!!!!!
//
// This strategy script is made to receieve a signal from an exterior study script, which should plot +1 for long or -1 for short 
// entry (that is by default - values can be changed in the strategy settings menu). That plot should be found in "Enter Trigger" input 
// dropdown menu at the bottom of strategy settings menu. Removing the "and trigger == long/short_trigger" condition from strategy entry 
// conditions makes the strategy open trades ASAP.

//@version=5

//strategy('TTB DCA Bot5', overlay=true, pyramiding=999, calc_on_every_tick=false, default_qty_type=strategy.percent_of_equity, default_qty_value=1, initial_capital=100000, commission_value=0.00, slippage=0)
strategy('TTB DCA Bot5.1', overlay=true, pyramiding=999, calc_on_every_tick=false, default_qty_type=strategy.cash, default_qty_value=1, initial_capital=100000, commission_value=0.00, slippage=0)

import DarkWaveAlgo/DarkWaveColorThemes/1 as ColorThemes

// Strat Date Ranges
show_table = input(true, title='Show table')
text_size_switch = input(true, title='Small text in the table')
ID = input(defval='6700960415957', title='ID')
//direction = input.string(defval='All', title='Trading Direction', options=['All', 'Long', 'Short'])
//longDirection = input.bool(defval=true, title='Long Direction')
//shortDirection = input.bool(defval=false, title='Short Direction')
source_type = input.string('Close', 'Source', options=['Close', 'Open', 'High', 'Low', 'HL2', 'HLC3', 'OHLC4', 'Median Body', 'Weighted Close', 'Trend Biased', 'Trend Biased Extreme'])


// Strat Source
source_function(type) =>
    if type == 'Close'
        close
    else if type == 'Open'
        open
    else if type == 'High'
        high
    else if type == 'Low'
        low
    else if type == 'HL2'
        hl2
    else if type == 'HL3'
        hlc3
    else if type == 'OHLC4'
        ohlc4
    else if type == 'Median Body'
        (open + close) / 2
    else if type == 'Weighted Close'
        (high + low + 2 * close) / 4
    else if type == 'Trend Biased'
        close > open ? (high + close) / 2 : (low + close) / 2
    else if type == 'Trend Biased Extreme'
        close > open ? high : low

truncate(number, decimals) =>
    factor = math.pow(10, decimals)
    int(number * factor) / factor

// var long = false
// var short = true

// if direction == 'All'
//     long := true
//     short := true
//     short
// else if direction == 'Long'
//     long := true
//     short := false
//     short
// else if direction == 'Short'
//     long := false
//     short := true
//     short

var bool longCheck = input.bool(defval=true, title='Long Direction')
var bool shortCheck = input.bool(defval=true, title='Short Direction')

var bool long = longCheck
var bool short = shortCheck

// Long Strategy Inputs
group_long_inputs_inputs_title = "Long Inputs"
price_deviation_input = input.float(0.06, title='Price deviation to open safety orders (%)', step=0.1, minval=0.0, group=group_long_inputs_inputs_title)
price_deviation = price_deviation_input / 100
take_profit_input = input.float(0.11, title='Target Take Profit (%)', step=0.1, minval=0.0, group=group_long_inputs_inputs_title)
take_profit = take_profit_input / 100
base_order_lots = input.float(0.1, title='base order (lots)', group=group_long_inputs_inputs_title)
safe_order_lots = input.float(0.1, title='safe order (lots)', group=group_long_inputs_inputs_title)
safe_order_volume_scale = input.float(1.3, step=0.1, title='Safety order volume scale', group=group_long_inputs_inputs_title)
safety_order_volume_scale_factor = input.float(1.2, step=0.1, title='Safety order volume scale factor', group=group_long_inputs_inputs_title)
safe_order_step_scale = input.float(1.3, step=0.1, title='Safety order step scale', group=group_long_inputs_inputs_title)
safe_order_step_scale_factor = input.float(1.4, step=0.1, title='Safety order step scale factor',group=group_long_inputs_inputs_title)
max_safe_order = input(7, title='max no. of safe orders', group=group_long_inputs_inputs_title)

// Convert lots to units
base_order_units = base_order_lots * 100000
safe_order_units = safe_order_lots * 100000

// Short Strategy Inputs
group_short_inputs_inputs_title = "Short Inputs"
price_S_deviation_input = input.float(0.06, title='Price deviation to open short safety orders (%)', step=0.1, minval=0.0, group=group_short_inputs_inputs_title)
price_S_deviation = price_S_deviation_input / 100
take_S_profit_input = input.float(0.11, title='Short Target Take Profit (%)', step=0.1, minval=0.0, group=group_short_inputs_inputs_title)
take_S_profit = take_S_profit_input / 100
base_S_order_lots = input.float(0.1, title='base sell order (lots)', group=group_short_inputs_inputs_title)
safe_S_order_lots = input.float(0.1, title='safe sell order (lots)', group=group_short_inputs_inputs_title)
safe_S_order_volume_scale = input.float(1.3, step=0.1, title='Safety sell order volume scale', group=group_short_inputs_inputs_title)
safe_S_order_volume_scale_factor = input.float(1.2, step=0.1, title='Safety sell order volume scale factor', group=group_short_inputs_inputs_title)
safe_S_order_step_scale = input.float(1.3, step=0.1, title='Safety sell order step scale', group=group_short_inputs_inputs_title)
safe_S_order_step_scale_factor = input.float(1.4, step=0.1, title='Safety sell order step scale factor', group=group_short_inputs_inputs_title)
max_S_safe_order = input(7, title='max no. of sell safe orders', group=group_short_inputs_inputs_title)

// Convert lots to units
base_S_order_units = base_S_order_lots * 100000
safe_S_order_units = safe_S_order_lots * 100000

// Strat Triggers
//long_trigger = input(title='Long trigger value', defval=1)
//short_trigger = input(title='Short trigger value', defval=-1)
useTrigger = input(defval=false, title="Use Trigger Condition")
trigger = input(title='Enter trigger', defval=close)




// VSLRT indicator
// vslrt inputs
group_vslrt_inputs_inputs_title = "VSLRT Inputs"
vslrt_src = input(defval=close, title='Source', group=group_vslrt_inputs_inputs_title)
len1 = input.int(defval=150, title='Short Term Length', minval=5, group=group_vslrt_inputs_inputs_title)
len2 = input.int(defval=300, title='Long Term Length', minval=5, group=group_vslrt_inputs_inputs_title)
showVSLRTShortTermPlot = input(defval=false, title="Show VSLRT Short Term Plot", group=group_vslrt_inputs_inputs_title)
showVSLRTLongTermPlot = input(defval=false, title="Show VSLRT Long Term Plot", group=group_vslrt_inputs_inputs_title)
// ccol11 = input.color(defval=#00FF00ff, title='Column Colors', inline='gr1')
// ccol12 = input.color(defval=#00BC00, title='', inline='gr1')
// ccol13 = input.color(defval=#00FF006f, title='', inline='gr1')
// ccol21 = input.color(defval=#FF0000ff, title='', inline='gr1')
// ccol22 = input.color(defval=#BF0000, title='', inline='gr1')
// ccol23 = input.color(defval=#FF00006f, title='', inline='gr1')
// col11 = input.color(defval=#008EFF, title='Line Colors', inline='gr2')
// col12 = input.color(defval=#006ec5, title='', inline='gr2')
// col13 = input.color(defval=#024478, title='', inline='gr2')
// col21 = input.color(defval=#fd9701, title='', inline='gr2')
// col22 = input.color(defval=#CE7A00, title='', inline='gr2')
// col23 = input.color(defval=#663d00, title='', inline='gr2')
ccol11 = color.new(color.green, 100)
ccol12 = color.new(color.green, 80)
ccol13 = color.new(color.green, 50)
ccol21 = color.new(color.red, 100)
ccol22 = color.new(color.red, 80)
ccol23 = color.new(color.red, 50)
col11 = color.new(color.blue, 100)
col12 = color.new(color.blue, 80)
col13 = color.new(color.blue, 50)
col21 = color.new(color.orange, 100)
col22 = color.new(color.orange, 80)
col23 = color.new(color.orange, 50)

// get short/long-term regression slope
slope_price = ta.linreg(vslrt_src, len1, 0) - ta.linreg(vslrt_src, len1, 1)
slope_price_lt = ta.linreg(vslrt_src, len2, 0) - ta.linreg(vslrt_src, len2, 1)

// get the size of top/bottom/body of the candle
tw = high - math.max(open, close)
bw = math.min(open, close) - low
body = math.abs(close - open)

//Calculate Buy/Sell Volume
_rate(cond) =>
    ret = 0.5 * (tw + bw + (cond ? 2 * body : 0)) / (tw + bw + body)
    ret := na(ret) ? 0.5 : ret
    ret

// Calculate Regression Slope for Buy/Sell Volumes
_get_trend(len) =>
    deltaup = volume * _rate(open <= close)
    deltadown = volume * _rate(open > close)

    slope_volume_up = ta.linreg(deltaup, len, 0) - ta.linreg(deltaup, len, 1)
    slope_volume_down = ta.linreg(deltadown, len, 0) - ta.linreg(deltadown, len, 1)
    [slope_volume_up, slope_volume_down]

// get buy/sell volume regression slopes for short term period
[slope_volume_up, slope_volume_down] = _get_trend(len1)

// coloring columns
column_col = slope_price > 0 ? slope_volume_up > 0 ? slope_volume_up > slope_volume_down ? ccol11 : ccol12 : ccol13 : slope_price < 0 ? slope_volume_down > 0 ? slope_volume_up < slope_volume_down ? ccol21 : ccol22 : ccol23 : color.gray

// short term trend
plot(showVSLRTShortTermPlot ? slope_price * len1 : na, color = column_col, style = plot.style_columns)

// get buy/sell volume regression slopes for long term period
[slope_volume_up_lt, slope_volume_down_lt] = _get_trend(len2)

// coloring columns
column_col := slope_price_lt > 0 ? slope_volume_up_lt > 0 ? slope_volume_up_lt > slope_volume_down_lt ? col11 : col12 : col13 : 
       slope_price_lt < 0 ? slope_volume_down_lt > 0 ? slope_volume_up_lt < slope_volume_down_lt ? col21 : col22 : col23 :
       color.gray

// Long term trend
plot(showVSLRTLongTermPlot ? slope_price_lt * len2 : na, color = column_col, linewidth = 3)
// End VSLRT



// half trend
//half trend inputs
group_half_trend_inputs_title = "Half Trend Inputs"
amplitude = input(title='Amplitude', defval=18, group=group_half_trend_inputs_title)
channelDeviation = input(title='Channel Deviation', defval=18, group=group_half_trend_inputs_title)
showArrows = input(title='Show Arrows', defval=true, group=group_half_trend_inputs_title)
showChannels = input(title='Show Channels', defval=true, group=group_half_trend_inputs_title)

var int trend = 0
var int nextTrend = 0
var float maxLowPrice = nz(low[1], low)
var float minHighPrice = nz(high[1], high)

var float up = 0.0
var float down = 0.0
float atrHigh = 0.0
float atrLow = 0.0
float arrowUp = na
float arrowDown = na

atr2 = ta.atr(100) / 2
dev = channelDeviation * atr2

highPrice = high[math.abs(ta.highestbars(amplitude))]
lowPrice = low[math.abs(ta.lowestbars(amplitude))]
highma = ta.sma(high, amplitude)
lowma = ta.sma(low, amplitude)

if nextTrend == 1
    maxLowPrice := math.max(lowPrice, maxLowPrice)

    if highma < maxLowPrice and close < nz(low[1], low)
        trend := 1
        nextTrend := 0
        minHighPrice := highPrice
        minHighPrice
else
    minHighPrice := math.min(highPrice, minHighPrice)

    if lowma > minHighPrice and close > nz(high[1], high)
        trend := 0
        nextTrend := 1
        maxLowPrice := lowPrice
        maxLowPrice

if trend == 0
    if not na(trend[1]) and trend[1] != 0
        up := na(down[1]) ? down : down[1]
        arrowUp := up - atr2
        arrowUp
    else
        up := na(up[1]) ? maxLowPrice : math.max(maxLowPrice, up[1])
        up
    atrHigh := up + dev
    atrLow := up - dev
    atrLow
else
    if not na(trend[1]) and trend[1] != 1
        down := na(up[1]) ? up : up[1]
        arrowDown := down + atr2
        arrowDown
    else
        down := na(down[1]) ? minHighPrice : math.min(minHighPrice, down[1])
        down
    atrHigh := down + dev
    atrLow := down - dev
    atrLow

ht = trend == 0 ? up : down

var color buyColor = color.blue
var color sellColor = color.red

htColor = trend == 0 ? buyColor : sellColor
htPlot = plot(ht, title='HalfTrend', linewidth=2, color=htColor)

atrHighPlot = plot(showChannels ? atrHigh : na, title='ATR High', style=plot.style_circles, color=color.new(sellColor, 0))
atrLowPlot = plot(showChannels ? atrLow : na, title='ATR Low', style=plot.style_circles, color=color.new(buyColor, 0))

fill(htPlot, atrHighPlot, title='ATR High Ribbon', color=color.new(sellColor, 90))
fill(htPlot, atrLowPlot, title='ATR Low Ribbon', color=color.new(buyColor, 90))

buySignal = not na(arrowUp) and trend == 0 and trend[1] == 1
sellSignal = not na(arrowDown) and trend == 1 and trend[1] == 0

plotshape(showArrows and buySignal ? atrLow : na, title='Arrow Up', style=shape.triangleup, location=location.absolute, size=size.tiny, color=color.new(buyColor, 0))
plotshape(showArrows and sellSignal ? atrHigh : na, title='Arrow Down', style=shape.triangledown, location=location.absolute, size=size.tiny, color=color.new(sellColor, 0))

//End half trend


// MTF supertrend
getSize(string sizeString) =>
    t = sizeString == "Auto" ? size.auto : sizeString == "Huge" ? size.huge : sizeString == "Large" ? size.large : sizeString == "Normal" ? size.normal : sizeString == "Small" ? size.small : sizeString == "Tiny" ? size.tiny : na  

_tfString(tf) =>
    str = "Chart"
    if (str.contains(tf, "H") or  (str.contains(tf, "S")) or (str.contains(tf, "D")) or (str.contains(tf, "W")) or (str.contains(tf, "M")))
        str := tf
    else if (not na(str.tonumber(tf)))
        str := tf == '180' ? "3h" : tf == '240' ? "4h" : tf == '480' ? "8h" : tf == '120' ? "2h" : tf == '60' ? "1h" : tf + "m"

tfString(tf) =>
    str = "Chart"
    if (str.contains(tf, "H") or  (str.contains(tf, "S")) or (str.contains(tf, "D")) or (str.contains(tf, "W")) or (str.contains(tf, "M")))
        str := tf
    else if (not na(str.tonumber(tf)))
        str := tf == '180' ? "3h" : tf == '240' ? "4h" : tf == '480' ? "8h" : tf == '120' ? "2h" : tf == '60' ? "1h" : tf + "m"
    else 
        str := _tfString(timeframe.period)





//enableColorTheme = input.bool(true, "✅ Use a Color Theme", group="🌊 Global Input Settings 🌊")
//selectedColorTheme = input.string("DarkWave Crypto", "  🎨 Color Theme", options=['DarkWave', 'Synthwave', 'DarkWave Crypto', 'Crystal Pool', 'Aquafarer', 'Mystic Armor', 'Futurist', 'Electric Zest', 'Stealth Ride', 'Long Trader', 'Short Trader', 'Emerald Glow', 'Gold Heist', 'Floral', 'Cobalt Twilight', 'Sunrise'], group="🌊 Global Input Settings 🌊")
//fill_SuperTrends = input.bool(true, "✅ Fill SuperTrend Areas", group = "🌊 Global Input Settings 🌊")
//hideLowerTimeframes = input.bool(true, "✅ Hide SuperTrends on Timeframes Lower Than the Chart", group="🌊 Global Input Settings 🌊")
enableColorTheme = true
selectedColorTheme = "DarkWave Crypto"
fill_SuperTrends = true
hideLowerTimeframes = true



color bullishColor = #00d5bfff
color bearishColor = #c2185bff
if (enableColorTheme)
    bullishColor := ColorThemes.getThemeColor(selectedColorTheme, 'Bullish')
    bearishColor := ColorThemes.getThemeColor(selectedColorTheme, 'Bearish')

mid = (open + close) / 2
bodyMiddle = plot(mid, display=display.none, editable=false)

// mtf supertrend inputs
group_mtf_supertrend_inputs_title = "MTF SuperTrend Inputs"
SuperTrend1_Enabled = input.bool(true, "✅ Enable", group=group_mtf_supertrend_inputs_title)
SuperTrend1_Timeframe = input.timeframe("60", "  🥽 Timeframe", group=group_mtf_supertrend_inputs_title)
SuperTrend1_Period = input.int(50, "  🔎 Period", group=group_mtf_supertrend_inputs_title)
SuperTrend1_Factor = input.float(3.0, "  ⚙️ Factor", group=group_mtf_supertrend_inputs_title)

//SuperTrend1_BullishColor = input.color(color.rgb(54, 255, 58), "    🖌️ Bullish Color", group="🌊 TimeFrame #1 🌊", inline="Colors")
//SuperTrend1_BearishColor = input.color(color.rgb(255, 61, 61), "    🖌️ Bearish Color", group="🌊 TimeFrame #1 🌊", inline="Colors")
//SuperTrend1_LabelEnabled = input.bool(true, "✅ Enable Label", group="🌊 TimeFrame #1 🌊")
//SuperTrend1_LabelSize = input.string("Normal", "  📐 Size", options=["Auto", "Tiny", "Small", "Normal", "Large", "Huge"], group="🌊 TimeFrame #1 🌊")
//SuperTrend1_LabelOffsetInBars = input.int(35, "  📏 Label Offset (in Bars)", group="🌊 TimeFrame #1 🌊")
//SuperTrend1_ShowLabelLine = input.bool(true, "✅ Show Label Line", group="🌊 TimeFrame #1 🌊")
SuperTrend1_BullishColor = color.rgb(54, 255, 58)
SuperTrend1_BearishColor = color.rgb(255, 61, 61)
SuperTrend1_LabelEnabled = true
SuperTrend1_LabelSize = "Normal"
SuperTrend1_LabelOffsetInBars = 35
SuperTrend1_ShowLabelLine = true

SuperTrend1_Hidden = hideLowerTimeframes and (timeframe.in_seconds() > timeframe.in_seconds(SuperTrend1_Timeframe))
_SuperTrend1_BearishColor = enableColorTheme ? bearishColor : SuperTrend1_BearishColor
_SuperTrend1_BullishColor = enableColorTheme ? bullishColor : SuperTrend1_BullishColor
[_SuperTrend1_Value, _SuperTrend1_Direction] =  request.security(syminfo.ticker, SuperTrend1_Timeframe, ta.supertrend(SuperTrend1_Factor, SuperTrend1_Period), barmerge.gaps_off, barmerge.lookahead_off)
SuperTrend1_Value = SuperTrend1_Enabled and not SuperTrend1_Hidden ? _SuperTrend1_Value : na
SuperTrend1_Direction = SuperTrend1_Enabled and not SuperTrend1_Hidden ? _SuperTrend1_Direction : na
SuperTrend1_Color = SuperTrend1_Direction > 0 ? _SuperTrend1_BullishColor : _SuperTrend1_BearishColor
_SuperTrend1_Color = SuperTrend1_Color
ST1_Long = plot(SuperTrend1_Enabled and SuperTrend1_Direction > 0 ? SuperTrend1_Value : na, color=_SuperTrend1_Color, linewidth=1, style = plot.style_linebr, title="🌊 TimeFrame #1 🌊 Long SuperTrend", join = true)
ST1_Short = plot(SuperTrend1_Enabled and SuperTrend1_Direction < 0 ? SuperTrend1_Value : na, color=_SuperTrend1_Color, linewidth=1, style = plot.style_linebr, title="🌊 TimeFrame #1 🌊 Short SuperTrend", join = true)
fill(ST1_Long, bodyMiddle, color = color.new(_SuperTrend1_Color, 90), fillgaps = false, display = fill_SuperTrends ? display.all : display.none)
fill(ST1_Short, bodyMiddle, color = color.new(_SuperTrend1_Color, 90), fillgaps = false, display = fill_SuperTrends ? display.all : display.none)

// Labels
// var SuperTrend1_Label = label(na)
// var SuperTrend1_Label_Line = line(na)

// if (barstate.islast)
//     if (SuperTrend1_LabelEnabled and SuperTrend1_Enabled)
//         if (not na(SuperTrend1_Label))
//             label.delete(SuperTrend1_Label)
//             line.delete(SuperTrend1_Label_Line)
//         if (SuperTrend1_ShowLabelLine)
//             SuperTrend1_Label_Line := line.new(bar_index, SuperTrend1_Value, bar_index + SuperTrend1_LabelOffsetInBars, SuperTrend1_Value,
//               xloc=xloc.bar_index, extend=extend.none, color=_SuperTrend1_Color, width=1, style=line.style_dashed)
//         SuperTrend1_Label := label.new(bar_index + SuperTrend1_LabelOffsetInBars, SuperTrend1_Value, color=color.new(color.rgb(0,0,0),100), style=label.style_label_left, text="〽️ " + tfString(SuperTrend1_Timeframe) + " " + str.tostring(SuperTrend1_Period) + "/" + str.tostring(SuperTrend1_Factor) + " SuperTrend ➜ " + str.tostring(math.round_to_mintick(SuperTrend1_Value)), 
//           textcolor=_SuperTrend1_Color, size=getSize(SuperTrend1_LabelSize))


// group_mtf_supertrend2_inputs_title = "MTF SuperTrend2 Inputs"
// SuperTrend2_Enabled = input.bool(true, "✅ Enable", group=group_mtf_supertrend2_inputs_title)
// SuperTrend2_Timeframe = input.timeframe("240", "  🥽 Timeframe", group=group_mtf_supertrend2_inputs_title)
// SuperTrend2_Period = input.int(50, "  🔎 Period", group=group_mtf_supertrend2_inputs_title)
// SuperTrend2_Factor = input.float(3.0, "  ⚙️ Factor", group=group_mtf_supertrend2_inputs_title)

// SuperTrend2_BullishColor = color.rgb(54, 255, 58)
// SuperTrend2_BearishColor = color.rgb(255, 61, 61)
// SuperTrend2_LabelEnabled = true
// SuperTrend2_LabelSize = "Normal"
// SuperTrend2_LabelOffsetInBars = 35
// SuperTrend2_ShowLabelLine = true

// SuperTrend2_Hidden = hideLowerTimeframes and (timeframe.in_seconds() > timeframe.in_seconds(SuperTrend2_Timeframe))
// _SuperTrend2_BearishColor = enableColorTheme ? bearishColor : SuperTrend2_BearishColor
// _SuperTrend2_BullishColor = enableColorTheme ? bullishColor : SuperTrend2_BullishColor
// [_SuperTrend2_Value, _SuperTrend2_Direction] =  request.security(syminfo.ticker, SuperTrend2_Timeframe, ta.supertrend(SuperTrend2_Factor, SuperTrend2_Period), barmerge.gaps_off, barmerge.lookahead_off)
// SuperTrend2_Value = SuperTrend2_Enabled and not SuperTrend2_Hidden ? _SuperTrend2_Value : na
// SuperTrend2_Direction = SuperTrend2_Enabled and not SuperTrend2_Hidden ? _SuperTrend2_Direction : na
// SuperTrend2_Color = SuperTrend2_Direction > 0 ? _SuperTrend2_BullishColor : _SuperTrend2_BearishColor
// _SuperTrend2_Color = SuperTrend2_Color
// ST2_Long = plot(SuperTrend2_Enabled and SuperTrend2_Direction > 0 ? SuperTrend2_Value : na, color=_SuperTrend2_Color, linewidth=1, style = plot.style_linebr, title="🌊 TimeFrame #2 🌊 Long SuperTrend", join = true)
// ST2_Short = plot(SuperTrend2_Enabled and SuperTrend2_Direction < 0 ? SuperTrend2_Value : na, color=_SuperTrend2_Color, linewidth=1, style = plot.style_linebr, title="🌊 TimeFrame #2 🌊 Short SuperTrend", join = true)
// fill(ST2_Long, bodyMiddle, color = color.new(_SuperTrend2_Color, 90), fillgaps = false, display = fill_SuperTrends ? display.all : display.none)
// fill(ST2_Short, bodyMiddle, color = color.new(_SuperTrend2_Color, 90), fillgaps = false, display = fill_SuperTrends ? display.all : display.none)

// // Labels
// var SuperTrend2_Label = label(na)
// var SuperTrend2_Label_Line = line(na)

// if (barstate.islast)
//     if (SuperTrend2_LabelEnabled and SuperTrend2_Enabled)
//         if (not na(SuperTrend2_Label))
//             label.delete(SuperTrend2_Label)
//             line.delete(SuperTrend2_Label_Line)
//         if (SuperTrend2_ShowLabelLine)
//             SuperTrend2_Label_Line := line.new(bar_index, SuperTrend2_Value, bar_index + SuperTrend2_LabelOffsetInBars, SuperTrend2_Value,
//               xloc=xloc.bar_index, extend=extend.none, color=_SuperTrend2_Color, width=1, style=line.style_dashed)
//         SuperTrend2_Label := label.new(bar_index + SuperTrend2_LabelOffsetInBars, SuperTrend2_Value, color=color.new(color.rgb(0,0,0),100), style=label.style_label_left, text="〽️ " + tfString(SuperTrend2_Timeframe) + " " + str.tostring(SuperTrend2_Period) + "/" + str.tostring(SuperTrend2_Factor) + " SuperTrend ➜ " + str.tostring(math.round_to_mintick(SuperTrend2_Value)), 
//           textcolor=_SuperTrend2_Color, size=getSize(SuperTrend2_LabelSize))

// END MTF supertrend

// long conditions
group_longconditions_inputs_title = "Long Conditions"
useHalfTrendBuy = input(defval=true, title="Use Half Trend Buy Condition", group=group_longconditions_inputs_title)
useVSLRTBuy = input(defval=true, title="Use VSLRT Buy Condition", group=group_longconditions_inputs_title)
useSuperTrendBuy = input(defval=true, title="Use SuperTrend Buy Condition", group=group_longconditions_inputs_title)
//useSuperTrend2Buy = input(defval=true, title="Use SuperTrend2 Buy Condition", group=group_longconditions_inputs_title)

// Define your conditions
halfTrendBuyCondition = buySignal
VSLRTBuyCondition = (slope_price_lt > 0 and slope_volume_up_lt > 0 and slope_volume_up_lt > slope_volume_down_lt)
SuperTrendBuyCondition = close > SuperTrend1_Value
//SuperTrend2BuyCondition = close > SuperTrend2_Value

// Combine the conditions based on the checkboxes
long_trigger = (useHalfTrendBuy ? halfTrendBuyCondition : false) and (useVSLRTBuy ? VSLRTBuyCondition : false) and (useSuperTrendBuy ? SuperTrendBuyCondition : false)

// short conditions
group_shortconditions_inputs_title = "Short Conditions"
useHalfTrendSell = input(defval=true, title="Use Half Trend Sell Condition", group=group_shortconditions_inputs_title)
useVSLRTSell = input(defval=true, title="Use VSLRT Sell Condition", group=group_shortconditions_inputs_title)
useSuperTrendSell = input(defval=true, title="Use SuperTrend Sell Condition", group=group_shortconditions_inputs_title)
//useSuperTrend2Sell = input(defval=true, title="Use SuperTrend2 Sell Condition", group=group_shortconditions_inputs_title)

halfTrendSellCondition = sellSignal
VSLRTSellCondition = (slope_price_lt <= 0 or slope_volume_up_lt <= 0 or slope_volume_up_lt <= slope_volume_down_lt)
SuperTrendSellCondition = close < SuperTrend1_Value
//SuperTrend2SellCondition = close < SuperTrend2_Value

// Do the same for sell conditions
short_trigger = (useHalfTrendSell ? halfTrendSellCondition : false) and (useVSLRTSell ? VSLRTSellCondition : false) and (useSuperTrendSell ? SuperTrendSellCondition : false)

showLongTrigger = input(defval=false, title="Show Long Trigger")
showShortTrigger = input(defval=false, title="Show Short Trigger")

plotshape(series=showLongTrigger ? long_trigger : na, title="Long Trigger", location=location.belowbar, color=showLongTrigger ? color.orange : na, style=shape.triangleup, size=size.small)
plotshape(series=showShortTrigger ? short_trigger : na, title="Short Trigger", location=location.abovebar, color=showShortTrigger ? color.orange : na, style=shape.triangledown, size=size.small)


// stat time frame inputs
group_stat_time_frame_inputs_title = "Stat Time Frame Inputs"
from_month = input.int(defval=5, title='From Month', minval=1, maxval=12, group=group_stat_time_frame_inputs_title)
from_day = input.int(defval=1, title='From Day', minval=1, maxval=31, group=group_stat_time_frame_inputs_title)
from_year = input(defval=2021, title='From Year', group=group_stat_time_frame_inputs_title)
to_month = input.int(defval=12, title='To Month', minval=1, maxval=12, group=group_stat_time_frame_inputs_title)
to_day = input.int(defval=1, title='To Day', minval=1, maxval=31, group=group_stat_time_frame_inputs_title)
to_year = input(defval=2024, title='To Year', group=group_stat_time_frame_inputs_title)
start = timestamp(from_year, from_month, from_day, 00, 00)  // backtest start window
finish = timestamp(to_year, to_month, to_day, 23, 59)  // backtest finish window
window = time >= start and time <= finish ? true : false  // create function "within window of time"

// Strat logic
var current_so = 0
var current_S_so = 0
var initial_order = 0.0
var initial_S_order = 0.0
var original_ttp_value = 0.0
var quantity = 0.0
var entry_price = 0.0
var firstBarTime = 0.0
var maxDiffDays = 0.0
var soCount = 0
var SO1 = 0
var SO2 = 0
var SO3 = 0
var SO4 = 0
var SO5 = 0
var SO6 = 0
var SO7 = 0
var noSO = 0
var initial_price = 0.0
var initial_S_price = 0.0
var price_drop = 0.0
var price_pump = 0.0
var max_drop = 0.0
var max_pump = 0.0
var pump_date = 0
var pump_month = 0
var drop_date = 0
var drop_month = 0
var longest_trade_day = 0
var longest_trade_month = 0
var take_profit_level = 0.0
var take_S_profit_level = 0.0
var tp_plot = 0.0
var tp_S_plot = 0.0
var threshold = 0.0
var S_threshold = 0.0
timeDiff = time - firstBarTime
maxDev = 0.0
maxSDev = 0.0
closedTrades = 0
var tradeCount = 0
var i = 0
var avg_price = 0.0
var total_funds_in_trade = 0.0
var total_qty_in_trade = 0.0
var capital = 100.0

// Turn that time difference into days
diffDays = timeDiff / 86400000

// Calculate our TP levels
take_profit_level := avg_price * (1 + take_profit)
take_S_profit_level := avg_price * (1 - take_S_profit)


// First Position
for i = 0 to max_safe_order - 1 by 1
    maxDev := int((maxDev + price_deviation * 100 * math.pow(safe_order_step_scale, i)) * 100) / 100
    maxDev
for i = 0 to max_S_safe_order - 1 by 1
    maxSDev := int((maxSDev + price_S_deviation * 100 * math.pow(safe_S_order_step_scale, i)) * 100) / 100
    maxSDev

if math.abs(strategy.position_size) != 0 and current_so[1] == 0 and not(hour(time) == 0 and minute(time) < 59)
    strategy.close_all()


// Base Long entry
//if long and strategy.position_size == 0 and source_function(source_type) > 0 and window and trigger == long_trigger and not(hour(time) == 0 and minute(time) < 59)
if long and strategy.position_size == 0 and source_function(source_type) > 0 and window and trigger == long_trigger and not(hour(time) == 0 and minute(time) < 59)
    _string_long = ID + ',long,' + syminfo.ticker + '.PRO,risk=' + str.tostring(base_order_lots) + ',comment="entry"'
    strategy.entry('Long @' + str.tostring(source_function(source_type)), strategy.long, qty=base_order_units, alert_message=_string_long)

    initial_order := source_function(source_type)
    current_so := 1
    initial_price := close
    price_drop := close
    original_ttp_value := 0
    firstBarTime := time
    tradeCount += 1
    avg_price := close
    //total_funds_in_trade := avg_price * base_order
    //total_qty_in_trade := base_order
    total_funds_in_trade := avg_price * base_order_units
    total_qty_in_trade := base_order_units
    total_qty_in_trade

// Base Short Entry
//else if short and strategy.position_size == 0 and source_function(source_type) > 0 and window and trigger == short_trigger and not(hour(time) == 0 and minute(time) < 59)
else if short and strategy.position_size == 0 and source_function(source_type) > 0 and window and short_trigger and not(hour(time) == 0 and minute(time) < 59)
    // Alert message
    _string_short = ID + ',short,' + syminfo.ticker + '.PRO,risk=' + str.tostring(base_S_order_lots) + ',comment="entry"'
    strategy.entry('Short @' + str.tostring(source_function(source_type)), strategy.short, qty=base_order_units, alert_message=_string_short)


    initial_S_order := source_function(source_type)
    current_so := 1
    firstBarTime := time
    tradeCount += 1
    initial_S_price := close
    price_pump := close
    avg_price := close
    //total_funds_in_trade := avg_price * base_S_order
    //total_qty_in_trade := base_S_order
    total_funds_in_trade := avg_price * base_S_order_units
    total_qty_in_trade := base_S_order_units
    total_qty_in_trade

//makes the red and green line plot pretty at the position opening
if strategy.position_size == 0
    threshold := low[1]
    S_threshold := high[1]
    S_threshold

//Safety order levels

//Long
if strategy.position_size > 0 and i == 0
    if safe_order_step_scale == 1.0
        threshold := initial_order - initial_order * price_deviation * safe_order_step_scale * current_so
        threshold
    else
        //threshold := initial_order - initial_order * (price_deviation * (math.pow(safe_order_step_scale, current_so) - 1) / (safe_order_step_scale - 1))
        threshold := initial_order - initial_order * (price_deviation * (math.pow(safe_order_step_scale * safe_order_step_scale_factor, current_so) - 1) / (safe_order_step_scale * safe_order_step_scale_factor - 1))
        threshold
//Short
else if strategy.position_size < 0 and i == 0
    if safe_S_order_step_scale == 1.0
        S_threshold := initial_S_order * (1 + price_S_deviation * current_so)
        S_threshold
    else
        S_threshold := initial_S_order * (1 + price_S_deviation * (math.pow(safe_S_order_step_scale, current_so) - 1) / (safe_S_order_step_scale - 1))
        S_threshold

// Average Down - SOs for Longs
if current_so > 0 and i == 0 and strategy.position_size > 0 and low <= threshold and current_so <= max_safe_order and not(hour(time) == 0 and minute(time) < 59)
    //order_qty = safe_order_units * math.pow(safe_order_volume_scale, current_so - 1)
    //order_qty_lots = safe_order_units * math.pow(safe_order_volume_scale, current_so - 1) / 100000
    order_qty = safe_order_units * math.pow(safe_order_volume_scale * safety_order_volume_scale_factor, current_so - 1)
    order_qty_lots = safe_order_units * math.pow(safe_order_volume_scale * safety_order_volume_scale_factor, current_so - 1) / 100000
    _string_long_so = ID + ',long,' + syminfo.ticker + '.PRO,risk=' + str.tostring(order_qty_lots) + ',comment="entry"'
    strategy.entry('SO ' + str.tostring(current_so) + '@' + str.tostring(source_function(source_type)), strategy.long, qty=order_qty, alert_message=_string_long_so)

    //total_funds_in_trade += threshold * safe_order_units * math.pow(safe_order_volume_scale, current_so - 1)
    //total_qty_in_trade += safe_order_units * math.pow(safe_order_volume_scale, current_so - 1)
    total_funds_in_trade += threshold * safe_order_units * math.pow(safe_order_volume_scale * safety_order_volume_scale_factor, current_so - 1)
    total_qty_in_trade += safe_order_units * math.pow(safe_order_volume_scale * safety_order_volume_scale_factor, current_so - 1)
    avg_price := total_funds_in_trade / total_qty_in_trade
    current_so += 1
    tradeCount += 1
    tradeCount

// Short Average Up - SOs for Shorts
if current_so > 0 and i == 0 and strategy.position_size < 0 and high >= S_threshold and current_so <= max_S_safe_order and not(hour(time) == 0 and minute(time) < 59)
    //order_qty = safe_S_order_units * math.pow(safe_S_order_volume_scale, current_so - 1)
    order_qty = safe_S_order_units * math.pow(safe_S_order_volume_scale * safe_S_order_volume_scale_factor, current_so - 1)
    //order_qty_lots = safe_S_order_units * math.pow(safe_S_order_volume_scale, current_so - 1) / 100000
    order_qty_lots = safe_S_order_units * math.pow(safe_S_order_volume_scale * safe_S_order_volume_scale_factor, current_so - 1) / 100000
    _string_short_so = ID + ',short,' + syminfo.ticker + '.PRO,risk=' + str.tostring(order_qty_lots) + ',comment="entry"'
    strategy.entry('SSO ' + str.tostring(current_so) + '@' + str.tostring(source_function(source_type)), strategy.short, qty=order_qty, alert_message=_string_short_so)


    //total_funds_in_trade += S_threshold * safe_S_order_units * math.pow(safe_S_order_volume_scale, current_so - 1)
    //total_qty_in_trade += safe_S_order_units * math.pow(safe_S_order_volume_scale, current_so - 1)
    total_funds_in_trade += S_threshold * order_qty
    total_qty_in_trade += order_qty
    avg_price := total_funds_in_trade / total_qty_in_trade
    current_so += 1
    tradeCount += 1
    tradeCount


exit_id = 'Exit Order'

// Take Profit! 
if i == 1 and not(hour(time) == 0 and minute(time) < 59)
    _string_close = ID + ',closelong,' + syminfo.ticker + '.PRO,comment="entry"'
    strategy.close(exit_id, comment=_string_close)
    i := 0
    i

if take_profit_level <= high and strategy.position_size > 0
    _string_close_long = ID + ',closelong,' + syminfo.ticker + '.PRO,comment="entry"'
    strategy.close(exit_id, comment=_string_close_long)
    soCount := current_so
    current_so := 0
    original_ttp_value := 0
    price_drop := na
    initial_price := na
    diffDays := time - firstBarTime
    if diffDays > maxDiffDays
        maxDiffDays := diffDays
        longest_trade_day := dayofmonth
        longest_trade_month := month
        longest_trade_month
    i := 1
    initial_order := 0.0
    avg_price := na
    capital *= (1 + total_qty_in_trade * take_profit / 100)
    capital

// Take Short Profit! 
if take_S_profit_level >= low and strategy.position_size < 0 and not(hour(time) == 0 and minute(time) < 59)
    _string_close_short = ID + ',close,short,' + syminfo.ticker + '.PRO,comment="entry"'
    strategy.close_all(comment='Close Short @' + str.tostring(source_function(source_type)), alert_message=_string_close_short)
    soCount := current_so
    current_so := 0
    price_pump := na
    initial_S_price := na
    diffDays := time - firstBarTime
    if diffDays > maxDiffDays
        maxDiffDays := diffDays
        maxDiffDays
    initial_S_order := 0.0
    avg_price := na
    capital *= (1 + total_qty_in_trade * take_S_profit / 100)
    capital

//Table building and calculations
if strategy.position_size == 0
    if soCount == 1
        noSO += 1
        noSO
    else if soCount == 2
        SO1 += 1
        SO1
    else if soCount == 3
        SO2 += 1
        SO2
    else if soCount == 4
        SO3 += 1
        SO3
    else if soCount == 5
        SO4 += 1
        SO4
    else if soCount == 6
        SO5 += 1
        SO5
    else if soCount == 7
        SO6 += 1
        SO6
    else if soCount == 8
        SO7 += 1
        SO7
    soCount := 0
    soCount
closedTrades := noSO + SO1 * 2 + SO2 * 3 + SO3 * 4 + SO4 * 5 + SO5 * 6 + SO6 * 7 + SO7 * 8

if low < price_drop and window and strategy.position_size > 0
    price_drop := low
    if max_drop < int((1 - price_drop / initial_price) * 10000) / 100
        max_drop := int((1 - price_drop / initial_price) * 10000) / 100
        drop_date := dayofmonth(time)
        drop_month := month(time)
        drop_month
bgcolor(max_drop[1] < max_drop ? color.aqua : na, transp=50)

if high > price_pump and window and strategy.position_size < 0
    price_pump := high
    if max_pump < int((price_pump / initial_S_price - 1) * 10000) / 100
        max_pump := int((price_pump / initial_S_price - 1) * 10000) / 100
        pump_date := dayofmonth(time)
        pump_month := month(time)
        pump_month
bgcolor(max_pump[1] < max_pump ? color.purple : na, transp=70)

if take_profit_level > 0 and strategy.position_size > 0
    tp_plot := take_profit_level
    tp_plot
else
    tp_plot := close
    tp_plot

if take_S_profit_level > 0 and strategy.position_size < 0
    tp_S_plot := take_S_profit_level
    tp_S_plot
else
    tp_S_plot := close
    tp_S_plot

//Plotting the levels
p1 = plot(tp_plot, color=strategy.position_size <= 0 ? na : #00ff008a)
p2 = plot(avg_price, color=strategy.position_size == 0 ? na : color.rgb(255, 255, 255, 47))
p3 = plot(threshold, color=strategy.position_size <= 0 ? na : color.rgb(194, 24, 92, 41))
p4 = plot(tp_S_plot, color=strategy.position_size >= 0 ? na : color.rgb(0, 213, 192, 46))
p5 = plot(S_threshold, color=strategy.position_size >= 0 ? na : color.rgb(194, 24, 92, 45))
fill(p1, p2, color=strategy.position_size > 0 ? color.rgb(0, 213, 192, 85) : na)
fill(p2, p3, strategy.position_size > 0 ? color.rgb(194, 24, 92, 89) : na)
fill(p4, p2, color=strategy.position_size < 0 ? color.rgb(0, 213, 192, 83) : na)
fill(p5, p2, color=strategy.position_size < 0 ? color.rgb(194, 24, 92, 86) : na)
profit_color = strategy.openprofit < 0 ? color.rgb(255, 82, 82, 83) : color.rgb(76, 175, 79, 71)

text_size = text_size_switch ? size.small : size.normal

// plot(strategy.opentrades)
// plot(current_so, color = color.yellow)
// plot(abs(strategy.position_size), color = color.red)
// plot(quantity, color=color.purple)

//Table formatting
if show_table
    var Table = table.new(position.bottom_right, columns=2, rows=20, border_width=1, bgcolor=color.black, border_color=color.gray)
    table.cell(table_id=Table, column=0, row=0, text_color=color.gray, text_size=text_size, text='Net Profit')
    table.cell(table_id=Table, column=1, row=0, text=str.tostring(int((capital - 100) * 100) / 100) + '%', text_size=text_size, text_color=color.lime)
    table.cell(table_id=Table, column=0, row=1, text_color=color.gray, text_size=text_size, text='Max Deviation ')
    table.cell(table_id=Table, column=1, row=1, text=str.tostring(maxDev) + '%', text_size=text_size, text_color=color.orange)
    table.cell(table_id=Table, column=0, row=2, text_color=color.gray, text_size=text_size, text='Max Short Dev ')
    table.cell(table_id=Table, column=1, row=2, text=str.tostring(maxSDev) + '%', text_size=text_size, text_color=color.orange)
    table.cell(table_id=Table, column=0, row=3, text='No SO ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=3, text=str.tostring(noSO), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=4, text='SO 1 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=4, text=str.tostring(SO1), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=5, text='SO 2 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=5, text=str.tostring(SO2), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=6, text='SO 3 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=6, text=str.tostring(SO3), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=7, text='SO 4 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=7, text=str.tostring(SO4), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=8, text='SO 5 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=8, text=str.tostring(SO5), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=9, text='SO 6 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=9, text=str.tostring(SO6), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=10, text='SO 7 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=10, text=str.tostring(SO7), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=11, text='Closed/Open trades', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=11, text=str.tostring(strategy.closedtrades) + '/' + str.tostring(strategy.opentrades), text_size=text_size, text_color=color.olive)
    table.cell(table_id=Table, column=0, row=12, text='Current Deal Time', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=12, text=strategy.position_size != 0 ? str.tostring(int((time - firstBarTime) / 8640000) / 10) + ' days' : '0', text_size=text_size, text_color=color.green)
    table.cell(table_id=Table, column=0, row=13, text='Unrealized position', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=13, text=str.tostring(int(strategy.openprofit / (strategy.initial_capital + strategy.netprofit) * 10000) / 100) + ' %', text_size=text_size, text_color=profit_color)
    table.cell(table_id=Table, column=0, row=14, text='Longest deal:', text_size=text_size, text_color=color.orange)
    table.cell(table_id=Table, column=1, row=14, text=str.tostring(int(maxDiffDays / 8640000) / 10) + ' days, ' + str.tostring(longest_trade_day) + '/' + str.tostring(longest_trade_month), text_size=text_size, text_color=color.red)
    table.cell(table_id=Table, column=0, row=15, text='Max price drop:', text_size=text_size, text_color=color.orange)
    table.cell(table_id=Table, column=1, row=15, text=str.tostring(max_drop) + ' %, ' + str.tostring(drop_date) + '/' + str.tostring(drop_month), text_size=text_size, text_color=color.red)
    table.cell(table_id=Table, column=0, row=16, text='Max price pump:', text_size=text_size, text_color=color.orange)
    table.cell(table_id=Table, column=1, row=16, text=str.tostring(max_pump) + ' %, ' + str.tostring(pump_date) + '/' + str.tostring(pump_month), text_size=text_size, text_color=color.red)



