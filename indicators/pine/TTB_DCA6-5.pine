//@version=5

strategy('TTB DCA 6.5L', overlay=true, pyramiding=999, calc_on_every_tick=false, default_qty_type=strategy.cash, default_qty_value=1, initial_capital=100000, commission_value=0.00, slippage=0, max_bars_back = 5000)

import thetradingbot/ttbcolors/1 as TTBColors

source_type = input.string('Close', 'Source', options=['Close', 'Open', 'High', 'Low', 'HL2', 'HLC3', 'OHLC4', 'Median Body', 'Weighted Close', 'Trend Biased', 'Trend Biased Extreme'])
direction = input.string(defval='Long', title='Trading Direction', options=['All', 'Long', 'Short'])


source_function(type) =>
    if type == 'Close'
        close
    else if type == 'Open'
        open
    else if type == 'High'
        high
    else if type == 'Low'
        low
    else if type == 'HL2'
        hl2
    else if type == 'HL3'
        hlc3
    else if type == 'OHLC4'
        ohlc4
    else if type == 'Median Body'
        (open + close) / 2
    else if type == 'Weighted Close'
        (high + low + 2 * close) / 4
    else if type == 'Trend Biased'
        close > open ? (high + close) / 2 : (low + close) / 2
    else if type == 'Trend Biased Extreme'
        close > open ? high : low

truncate(number, decimals) =>
    factor = math.pow(10, decimals)
    int(number * factor) / factor

var long = false
var short = true

if direction == 'All'
    long := true
    short := true
    short
else if direction == 'Long'
    long := true
    short := false
    short
else if direction == 'Short'
    long := false
    short := true
    short

// Strategy Inputs
ID = input(defval='6700960415957', title='ID')
version = input(defval='6-5', title='version')
tf = input(defval='1', title='tf')
groupTitleLongInputs = "Long Inputs"
price_deviation = input.float(0.05, title='Price deviation to open safety orders (%)', step=0.1, minval=0.0) / 100
take_profit = input.float(0.07, title='Target Take Profit (%)', step=0.1, minval=0.0) / 100
base_order = input.float(3000, "Base Order Size")
safe_order = input.float(3000, "Safe Order Size")
safe_order_volume_scale = input.float(1, step=0.1, title='Safety order volume scale')
safe_order_step_scale = input.float(2.5, step=0.1, title='Safety order step scale')
max_safe_order = input(4, title='max no. of safe orders')
groupTitleShortInputs = "Short Inputs"
price_S_deviation = input.float(0.05, title='Price deviation to open short safety orders (%)', step=0.1, minval=0.0) / 100
take_S_profit = input.float(0.07, title='Short Target Take Profit (%)', step=0.1, minval=0.0) / 100
base_S_order = input.float(3000, title='base sell order')
safe_S_order = input.float(3000, title='safe sell order')
safe_S_order_volume_scale = input.float(1, step=0.1, title='Safety sell order volume scale')
safe_S_order_step_scale = input.float(2.4, step=0.1, title='Safety sell order step scale')
max_S_safe_order = input(4, title='max no. of sell safe orders')





//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// jma

// Inputs //
// src1 = input(close, title="Source 1", inline="1")
// Length1 = input.int(title="Length 1", defval=200)
// Phase1 = input.int(title="Phase 1", defval=50)
// showJMA1 = input.bool(defval=false, title="Show JMA 1")

// // Inputs for second plot
// src2 = input(close, title="Source 2", inline="1")
// Length2 = input.int(title="Length 2", defval=1000)
// Phase2 = input.int(title="Phase 2", defval=50)
// showJMA2 = input.bool(defval=false, title="Show JMA 2")

// //code from library
// jmapow(src, len) =>
//     upperBand = src
//     lowerBand = src
    
//     // Volatility
//     del1 = src - nz(upperBand[1], src)
//     del2 = src - nz(lowerBand[1], src)
//     volty = math.abs(del1) == math.abs(del2) ? 0 : math.max(math.abs(del1), math.abs(del2))
    
//     // Incremental sum of Volty
//     vSum = 0.0
//     vSum := nz(vSum[1]) + 0.1 * (volty - nz(volty[10], volty))

//     // Jurik used 65
//     avgLen = 65
//     avgVolty = ta.sma(vSum, avgLen)
    
//     // Relative price volatility
//     alen = (len - 1) / 2
//     len1 = math.max(math.log(math.sqrt(alen)) / math.log(2) + 2, 0)
//     pow1 = math.max(len1 - 2, 0.5)
    
//     rVolty = avgVolty != 0 ? volty / avgVolty : 0
//     if (rVolty > math.pow(len1, 1 / pow1))
//         rVolty := math.pow(len1, 1 / pow1)
//     if rVolty < 1
//         rVolty := 1
    
//     // Jurik Bands
//     pow2 = math.pow(rVolty, pow1)
//     len2 = math.sqrt(alen) * len1
//     bet  = len2/(len2 + 1)
//     kv   = math.pow(bet, math.sqrt(pow2))
    
//     upperBand := del1 > 0 ? src : src - kv * del1
//     lowerBand := del2 < 0 ? src : src - kv * del2

//     pow2

// // @function Jurik MA
// // @param src Series to use
// // @param len Filtering length
// // @param phase JMA Phase
// // @returns Filtered series
// jma(float src, int len, int phase = 50) =>
//     jma = 0.0
//     phaseRatio = phase < -100 ? 0.5 : phase > 100 ? 2.5 : phase / 100 + 1.5
//     beta = 0.45 * (len - 1) / (0.45 * (len - 1) + 2)
//     power = jmapow(src, len)
//     alpha = math.pow(beta, power)
    
//     // 1st stage - preliminary smoothing by adaptive EMA
//     ma1 = 0.0
//     ma1 := (1 - alpha) * src + alpha * nz(ma1[1])
    
//     // 2nd stage - preliminary smoothing by Kalman filter
//     det0 = 0.0
//     det0 := (1 - beta) * (src - ma1) + beta * nz(det0[1])
//     ma2 = ma1 + phaseRatio * det0
    
//     // 3rd stage - final smoothing by Jurik adaptive filter
//     det1 = 0.0
//     det1 := math.pow(1 - alpha, 2) * (ma2 - nz(jma[1])) + math.pow(alpha, 2) * nz(det1[1])

//     jma := nz(jma[1]) + det1
//     jma

// float out1 = jma(src1, Length1, Phase1)
// float out2 = jma(src2, Length2, Phase2)

// plotColor1 = out1 > out1[1] ? TTBColors.colorUp() : TTBColors.colorDown()
// plotColor2 = out2 > out2[1] ? TTBColors.colorUp() : TTBColors.colorDown()

// plot(showJMA1 ? out1 : na, "JMA1", color=plotColor1, linewidth=2)
// plot(showJMA2 ? out2 : na, "JMA2", color=plotColor2, linewidth=2)

// JMA1LongTrigger = ta.crossover(out1, out1[1])
// JMA1LongFilter = out1 > out1[1]
// JMA1ShortTrigger = ta.crossunder(out1, out1[1])
// JMA1ShortFilter = out1 < out1[1]

// JMA2LongTrigger = ta.crossover(out2, out2[1])
// JMA2LongFilter = out2 > out2[1]
// JMA2ShortTrigger = ta.crossunder(out2, out2[1])
// JMA2ShortFilter = out2 < out2[1]

// end jma
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// rmi trend


// ** ---> Inputs ------------- {
showRMIplots = input.bool(false, "Show RMI Plots")
var bool rmi_positive               = false
var bool rmi_negative               = false
string rmi_RSI_group                = "RMI Settings"
string rmi_mom_group                = "Range Vales"
string rmi_visual                   = "Visuals" 
int rmi_Length                      = input(14,"RMI Length ",inline = "RMI",group = rmi_RSI_group)
int rmi_pmom                        = input(66," Positive above",inline = "rsi1",group = rmi_RSI_group )
int rmi_nmom                        = input(30,"Negative below",inline = "rsi1",group = rmi_RSI_group )
bool rmi_filleshow = true
color rmi_bull = color.new(color.rgb(0, 188, 212), 70) // 70% transparency
color rmi_bear = color.new(color.rgb(255, 82, 82), 70) // 70% transparency
float rmi_BarRange                  = high - low

rmi_up = ta.rma(math.max(ta.change(close), 0), rmi_Length)
rmi_down = ta.rma(-math.min(ta.change(close), 0), rmi_Length)
rmi_rsi = rmi_down == 0 ? 100 : rmi_up == 0 ? 0 : 100 - (100 / (1 + rmi_up / rmi_down))
rmi_mf = ta.mfi(hlc3, rmi_Length)
rmi_rsi_mfi = math.avg(rmi_rsi,rmi_mf)



//------------------- }

bool rmi_p_mom                          = rmi_rsi_mfi[1] < rmi_pmom and
      rmi_rsi_mfi > rmi_pmom and
      rmi_rsi_mfi > rmi_nmom and
       ta.change(ta.ema(close,5)) > 0

bool rmi_n_mom                          = rmi_rsi_mfi < rmi_nmom and
      ta.change(ta.ema(close,5)) < 0
// //  ---> Momentums ------------- {

if rmi_p_mom
    rmi_positive:= true
    rmi_negative:= false

if rmi_n_mom
    rmi_positive:= false
    rmi_negative:= true     



//
method rmi_Band(int len)=>
    math.min (ta.atr (len) * 0.3, close * (0.3/100)) [20] /2 * 8 


rmi_Band = rmi_Band(30) 


method rmi_rangeMA(float Range,Prd)=>
    weight = Range / math.sum(Range, Prd)
    sum = math.sum(close * weight, Prd)
    tw= math.sum(weight, Prd)
    sum / tw


// Calculate the RWMA
rmi_rwma = rmi_rangeMA(rmi_BarRange,20)

// Plotting the RWMA.
colour = rmi_positive ? TTBColors.colorUp() : TTBColors.colorDown()
rmi_RWMA = rmi_positive ? rmi_rwma - rmi_Band : rmi_negative ? rmi_rwma + rmi_Band : na
alpha = color.new(color.black, 100)
rmi_max = rmi_RWMA + rmi_Band
rmi_min = rmi_RWMA - rmi_Band
Barcol = rmi_positive ? TTBColors.colorUp() : TTBColors.colorDown()

//center = plot(showRMIplots and rmi_filleshow ? rmi_RWMA : na, "RRTH", colour, editable = true)
//top = plot(showRMIplots and rmi_filleshow ? rmi_max: na, "RRTH", alpha)
//bottom = plot(showRMIplots and rmi_filleshow ? rmi_min: na, "RRTH", alpha)

//enter = plot(showRMIplots and rmi_filleshow ? rmi_RWMA : na, "RRTH", rmi_positive ? TTBColors.colorUp() : TTBColors.colorDown(), editable = true)
//plot(showRMIplots and rmi_filleshow ? rmi_RWMA : na, "RRTH", color.new(rmi_positive ? TTBColors.colorUp() : TTBColors.colorDown(), 70), 2, editable = true)
//plot(showRMIplots and rmi_filleshow ? rmi_RWMA : na, "RRTH", color.new(rmi_positive ? TTBColors.colorUp() : TTBColors.colorDown(), 80), 3, editable = true)
//plot(showRMIplots and rmi_filleshow ? rmi_RWMA : na, "RRTH", color.new(rmi_positive ? TTBColors.colorUp() : TTBColors.colorDown(), 90), 4, editable = true)
//fill(top, center, color = showRMIplots and rmi_filleshow ? color.new(rmi_positive ? TTBColors.colorUp() : TTBColors.colorDown(), 75) : na)
//fill(center, bottom, color = showRMIplots and rmi_filleshow ? color.new(rmi_positive ? TTBColors.colorUp() : TTBColors.colorDown(), 75) : na)

if showRMIplots
    if rmi_negative and not rmi_negative[1]
        label.new(bar_index,rmi_max+(rmi_Band/2),"",color = TTBColors.colorDown(),size=size.small)
    if rmi_positive and not rmi_positive[1]
        label.new(bar_index,rmi_min-(rmi_Band/2),"",color = TTBColors.colorUp(),size=size.small,style= label.style_label_up)

plotcandle(open, high, low, close,color = Barcol,wickcolor = Barcol,bordercolor  = Barcol)
barcolor(color = Barcol)


// SPOT Trading Alerts
//alertcondition(positive and not positive[1],"BUY")
//alertcondition(negative and not negative[1],"SELL")

rmi_buy = rmi_positive and not rmi_positive[1]
rmi_sell = rmi_negative and not rmi_negative[1]

rmi_buy_filter = rmi_positive
rmi_sell_filter = rmi_negative

// end rmi trend
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// supertrend
source = input(close, title="Source")
atrPeriod = input.int(20,    "ATR Length", minval = 1)
factor =    input.float(40.0, "Factor",     minval = 0.01, step = 0.01)
showSTplot = input.bool(defval=false, title="Show Supertrend Plots")

[supertrend, ST_direction] = ta.supertrend(factor, atrPeriod)

supertrend := barstate.isfirst ? na : supertrend


//upTrend =    plot(showSTplot and ST_direction < 0 ? supertrend : na, "Up Trend",   color = colorUp, style = plot.style_linebr)
//downTrend =  plot(showSTplot and ST_direction < 0 ? na : supertrend, "Down Trend", color = colorDown,   style = plot.style_linebr)
upTrend =    plot(showSTplot and ST_direction < 0 ? supertrend : na, "Up Trend",   color = TTBColors.colorUp(), style = plot.style_linebr)
downTrend =  plot(showSTplot and ST_direction > 0 ? supertrend : na, "Down Trend", color = TTBColors.colorDown(),   style = plot.style_linebr)
bodyMiddle = plot(showSTplot and barstate.isfirst ? na : (open + close) / 2, "Body Middle",display = display.none)

fill(bodyMiddle, upTrend, showSTplot ? color.new(TTBColors.colorUp(), 75) : na, fillgaps = false)
fill(bodyMiddle, downTrend, showSTplot ? color.new(TTBColors.colorDown(), 75) : na, fillgaps = false)

STlongTrigger = ta.crossover(close, supertrend)
STshortTrigger = ta.crossunder(close, supertrend)
STlongFilter = ST_direction < 0
STshortFilter = ST_direction > 0

// supertrend2
source2 = input(close, title="Source for ST2")
atrPeriod2 = input.int(30, "ATR Length for ST2", minval = 1)
factor2 = input.float(60.0, "Factor for ST2", minval = 0.01, step = 0.01)
showST2plot = input.bool(defval=true, title="Show Supertrend2 Plots")

[supertrend2, ST_direction2] = ta.supertrend(factor2, atrPeriod2)

supertrend2 := barstate.isfirst ? na : supertrend2

upTrend2 = plot(showST2plot and ST_direction2 < 0 ? supertrend2 : na, "Up Trend ST2", color = TTBColors.colorUp(), style = plot.style_linebr)
downTrend2 = plot(showST2plot and ST_direction2 > 0 ? supertrend2 : na, "Down Trend ST2", color = TTBColors.colorDown(), style = plot.style_linebr)
bodyMiddle2 = plot(showST2plot and barstate.isfirst ? na : (open + close) / 2, "Body Middle ST2",display = display.none)

fill(bodyMiddle2, upTrend2, showST2plot ? color.new(TTBColors.colorUp(), 75) : na, fillgaps = false)
fill(bodyMiddle2, downTrend2, showST2plot ? color.new(TTBColors.colorDown(), 75) : na, fillgaps = false)

ST2longTrigger = ta.crossover(close, supertrend2)
ST2shortTrigger = ta.crossunder(close, supertrend2)
ST2longFilter = ST_direction2 < 0
ST2shortFilter = ST_direction2 > 0


// end supertrend
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// half trend
amplitude = input(title='Amplitude', defval=20)
channelDeviation = input(title='Channel Deviation', defval=20)
showArrows = input(title='Show Arrows', defval=false)
showChannels = input(title='Show Channels', defval=false)

var int trend = 0
var int nextTrend = 0
var float maxLowPrice = nz(low[1], low)
var float minHighPrice = nz(high[1], high)

var float up = 0.0
var float down = 0.0
float atrHigh = 0.0
float atrLow = 0.0
float arrowUp = na
float arrowDown = na

atr2 = ta.atr(100) / 2
dev = channelDeviation * atr2

highPrice = high[math.abs(ta.highestbars(amplitude))]
lowPrice = low[math.abs(ta.lowestbars(amplitude))]
highma = ta.sma(high, amplitude)
lowma = ta.sma(low, amplitude)

if nextTrend == 1
    maxLowPrice := math.max(lowPrice, maxLowPrice)

    if highma < maxLowPrice and close < nz(low[1], low)
        trend := 1
        nextTrend := 0
        minHighPrice := highPrice
        minHighPrice
else
    minHighPrice := math.min(highPrice, minHighPrice)

    if lowma > minHighPrice and close > nz(high[1], high)
        trend := 0
        nextTrend := 1
        maxLowPrice := lowPrice
        maxLowPrice

if trend == 0
    if not na(trend[1]) and trend[1] != 0
        up := na(down[1]) ? down : down[1]
        arrowUp := up - atr2
        arrowUp
    else
        up := na(up[1]) ? maxLowPrice : math.max(maxLowPrice, up[1])
        up
    atrHigh := up + dev
    atrLow := up - dev
    atrLow
else
    if not na(trend[1]) and trend[1] != 1
        down := na(up[1]) ? up : up[1]
        arrowDown := down + atr2
        arrowDown
    else
        down := na(down[1]) ? minHighPrice : math.min(minHighPrice, down[1])
        down
    atrHigh := down + dev
    atrLow := down - dev
    atrLow

ht = trend == 0 ? up : down

var color buyColor = TTBColors.colorUp()
var color sellColor = TTBColors.colorDown()

htColor = trend == 0 ? buyColor : sellColor
//htPlot = plot(ht, title='HalfTrend', linewidth=2, color=htColor)

//atrHighPlot = plot(showChannels ? atrHigh : na, title='ATR High', style=plot.style_circles, color=color.new(sellColor, 0))
//atrLowPlot = plot(showChannels ? atrLow : na, title='ATR Low', style=plot.style_circles, color=color.new(buyColor, 0))

//fill(htPlot, atrHighPlot, title='ATR High Ribbon', color=color.new(sellColor, 90))
//fill(htPlot, atrLowPlot, title='ATR Low Ribbon', color=color.new(buyColor, 90))

buySignal = not na(arrowUp) and trend == 0 and trend[1] == 1
sellSignal = not na(arrowDown) and trend == 1 and trend[1] == 0

plotshape(showArrows and buySignal ? atrLow : na, title='Arrow Up', style=shape.triangleup, location=location.absolute, size=size.tiny, color=color.new(buyColor, 0))
plotshape(showArrows and sellSignal ? atrHigh : na, title='Arrow Down', style=shape.triangledown, location=location.absolute, size=size.tiny, color=color.new(sellColor, 0))

//alertcondition(buySignal, title='Alert: HalfTrend Buy', message='HalfTrend Buy')
//alertcondition(sellSignal, title='Alert: HalfTrend Sell', message='HalfTrend Sell')

// end half trend
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}



//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
//dominant macd

// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
//
//======================
//Adapted FROM http://www.davenewberg.com/Trading/TS_Code/Ehlers_Indicators/Cycle_Period_Calculator.html
//======================


Price = hl2
alpha1 = input.float(0.07, minval=0, maxval=1)
Smooth = (Price + 2 * Price[1] + 2 * Price[2] + Price[3]) / 6
Cycle = 0.
InstPeriod = 0.
Q1 = 0.
DeltaPhase = 0.
I1 = 0.
DominantPeriod = 0.

Cycle := (1 - .5 * alpha1) * (1 - .5 * alpha1) * (Smooth - 2 * Smooth[1] + Smooth[2]) + 2 * (1 - alpha1) * nz(Cycle[1]) - (1 - alpha1) * (1 - alpha1) * nz(Cycle[2])
Q1 := (.0962 * Cycle + .5769 * Cycle[2] - .5769 * Cycle[4] - .0962 * Cycle[6]) * (.5 + .08 * nz(InstPeriod[1]))
I1 := Cycle[3]
DeltaPhase := Q1 != 0 and Q1[1] != 0 ? (I1 / Q1 - I1[1] / Q1[1]) / (1 + I1 * I1[1] / (Q1 * Q1[1])) : na
DeltaPhase := DeltaPhase < 0.1 ? 0.1 : DeltaPhase
DeltaPhase := DeltaPhase > 1.1 ? 1.1 : DeltaPhase
MedianDelta = ta.percentile_nearest_rank(DeltaPhase, 5, 50)
DC = MedianDelta == 0 ? 15 : 6.28318 / MedianDelta + 0.5
InstPeriod := .33 * DC + .67 * nz(InstPeriod[1])
DominantPeriod := .15 * InstPeriod + .85 * nz(DominantPeriod[1])


fastper = int(DominantPeriod)
slowper = int(2 * DominantPeriod + 1)


pine_ema(src, length) =>
    _alpha = 2 / (length + 1)
    sum = 0.0
    sum := na(sum[1]) ? ta.sma(src, length) : _alpha * src + (1 - _alpha) * nz(sum[1])
    sum


src = input(hl2, 'macd source')
slow_ema = pine_ema(src, nz(slowper, 26))
fast_ema = pine_ema(src, nz(fastper, 12))

MACD = fast_ema - slow_ema
signal_MACD = ta.ema(MACD, 9)

// Plot colors
//col_grow_above = TTBColors.colorUp()
//col_grow_below = TTBColors.colorDown()
//col_fall_above = TTBColors.colorUplight()
//col_fall_below = TTBColors.colorDownlight()
//col_macd = TTBColors.colorUpPlus()
//col_signal = TTBColors.colorDownPlus()

hist = MACD - signal_MACD

//plot(MACD, color=TTBColors.colorUp(), title="MACD")
//plot(signal_MACD, color=TTBColors.colorDown(), title="Signal MACD")
//plot(hist, title='Histogram', style=plot.style_columns, color=hist >= 0 ? hist[1] < hist ? col_grow_above : col_fall_above : hist[1] < hist ? //col_grow_below : col_fall_below, transp=0)

//show_adaptive_cycle_periods = input(false)
//plot(show_adaptive_cycle_periods ? fastper : na, color=TTBColors.colorUpPlustrans(), title="Fast Period")
//plot(show_adaptive_cycle_periods ? slowper : na, color=TTBColors.colorDownPlustrans(), title="Slow Period")

//show_moving_average_independently = input(false)
//plot(show_moving_average_independently ? slow_ema : na, color=TTBColors.colorUptrans(), title="Slow EMA")
//plot(show_moving_average_independently ? fast_ema : na, color=TTBColors.colorDowntrans(), title="Fast EMA")

DomMCADRisingBuyFilter = MACD > MACD[1]
DomMCADFallingSellFilter = MACD < MACD[1]
DomMCAD_OB_BuyFilter = signal_MACD > 0
DomMCAD_OS_SellFilter= signal_MACD < 0
DomMCAD_OS_BuyFilter = signal_MACD < 0
DomMCAD_OB_SellFilter= signal_MACD > 0

//  end  dominant macd
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}




//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
//  lorentzian

import jdehorty/MLExtensions/2 as ml
import jdehorty/KernelFunctions/2 as kernels

type Settings
    float source
    int neighborsCount
    int maxBarsBack
    int featureCount
    int colorCompression
    bool showExits
    bool useDynamicExits

type Label
    int long
    int short
    int neutral

type FeatureArrays
    array<float> f1
    array<float> f2
    array<float> f3
    array<float> f4
    array<float> f5

type FeatureSeries
    float f1
    float f2
    float f3
    float f4
    float f5

type MLModel
    int firstBarIndex
    array<int> trainingLabels
    int loopSize
    float lastDistance
    array<float> distancesArray
    array<int> predictionsArray
    int prediction

type FilterSettings 
    bool useVolatilityFilter
    bool useRegimeFilter
    bool useAdxFilter
    float regimeThreshold
    int adxThreshold

type Filter
    bool volatility
    bool regime
    bool adx 

// ==========================
// ==== Helper Functions ====
// ==========================

series_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, f_paramA, f_paramB)
        "WT" => ml.n_wt(_hlc3, f_paramA, f_paramB)
        "CCI" => ml.n_cci(_close, f_paramA, f_paramB)
        "ADX" => ml.n_adx(_high, _low, _close, f_paramA)

get_lorentzian_distance(int i, int featureCount, FeatureSeries featureSeries, FeatureArrays featureArrays) =>
    switch featureCount
        5 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) + 
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) + 
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) + 
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i))) + 
             math.log(1+math.abs(featureSeries.f5 - array.get(featureArrays.f5, i)))
        4 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i))) +
             math.log(1+math.abs(featureSeries.f4 - array.get(featureArrays.f4, i)))
        3 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i))) +
             math.log(1+math.abs(featureSeries.f3 - array.get(featureArrays.f3, i)))
        2 => math.log(1+math.abs(featureSeries.f1 - array.get(featureArrays.f1, i))) +
             math.log(1+math.abs(featureSeries.f2 - array.get(featureArrays.f2, i)))

// ================  
// ==== Inputs ==== 
// ================ 

// Settings Object: General User-Defined Inputs
Settings settings = 
 Settings.new(
   input.source(title='Source', defval=close, group="General Settings", tooltip="Source of the input data"),
   input.int(title='Neighbors Count', defval=8, group="General Settings", minval=1, maxval=100, step=1, tooltip="Number of neighbors to consider"),
   input.int(title="Max Bars Back", defval=4900, group="General Settings"),
   input.int(title="Feature Count", defval=5, group="Feature Engineering", minval=2, maxval=5, tooltip="Number of features to use for ML predictions."),
   input.int(title="Color Compression", defval=1, group="General Settings", minval=1, maxval=10, tooltip="Compression factor for adjusting the intensity of the color scale."),
   input.bool(title="Show Default Exits", defval=false, group="General Settings", tooltip="Default exits occur exactly 4 bars after an entry signal. This corresponds to the predefined length of a trade during the model's training process.", inline="exits"),
   input.bool(title="Use Dynamic Exits", defval=true, group="General Settings", tooltip="Dynamic exits attempt to let profits ride by dynamically adjusting the exit threshold based on kernel regression logic.", inline="exits")
 )
   
// Trade Stats Settings
// Note: The trade stats section is NOT intended to be used as a replacement for proper backtesting. It is intended to be used for calibration purposes only.
//showTradeStats = input.bool(false, 'Show Trade Stats', tooltip='Displays the trade stats for a given configuration. Useful for optimizing the settings in the Feature Engineering section. This should NOT replace backtesting and should be used for calibration purposes only. Early Signal Flips represent instances where the model changes signals before 4 bars elapses; high values can indicate choppy (ranging) market conditions.', group="General Settings")
useWorstCase = input.bool(false, "Use Worst Case Estimates", tooltip="Whether to use the worst case scenario for backtesting. This option can be useful for creating a conservative estimate that is based on close prices only, thus avoiding the effects of intrabar repainting. This option assumes that the user does not enter when the signal first appears and instead waits for the bar to close as confirmation. On larger timeframes, this can mean entering after a large move has already occurred. Leaving this option disabled is generally better for those that use this indicator as a source of confluence and prefer estimates that demonstrate discretionary mid-bar entries. Leaving this option enabled may be more consistent with traditional backtesting results.", group="General Settings")

// Settings object for user-defined settings
FilterSettings filterSettings =
 FilterSettings.new(
   input.bool(title="Use Volatility Filter", defval=true, tooltip="Whether to use the volatility filter.", group="Filters"),
   input.bool(title="Use Regime Filter", defval=true, group="Filters", inline="regime"),
   input.bool(title="Use ADX Filter", defval=false, group="Filters", inline="adx"),
   input.float(title="Threshold", defval=2, minval=-10, maxval=10, step=0.1, tooltip="Whether to use the trend detection filter. Threshold for detecting Trending/Ranging markets.", group="Filters", inline="regime"),
   input.int(title="Threshold", defval=20, minval=0, maxval=100, step=1, tooltip="Whether to use the ADX filter. Threshold for detecting Trending/Ranging markets.", group="Filters", inline="adx")
 )

// Filter object for filtering the ML predictions
Filter filter =
 Filter.new(
   ml.filter_volatility(1, 10, filterSettings.useVolatilityFilter), 
   ml.regime_filter(ohlc4, filterSettings.regimeThreshold, filterSettings.useRegimeFilter),
   ml.filter_adx(settings.source, 14, filterSettings.adxThreshold, filterSettings.useAdxFilter)
  )

// Feature Variables: User-Defined Inputs for calculating Feature Series. 
f1_string = input.string(title="Feature 1", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "01", tooltip="The first feature to use for ML predictions.", group="Feature Engineering")
f1_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 1.", defval=14, inline = "02", group="Feature Engineering")
f1_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=1, inline = "02", group="Feature Engineering")
f2_string = input.string(title="Feature 2", options=["RSI", "WT", "CCI", "ADX"], defval="WT", inline = "03", tooltip="The second feature to use for ML predictions.", group="Feature Engineering")
f2_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 2.", defval=10, inline = "04", group="Feature Engineering")
f2_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 2 (if applicable).", defval=11, inline = "04", group="Feature Engineering")
f3_string = input.string(title="Feature 3", options=["RSI", "WT", "CCI", "ADX"], defval="CCI", inline = "05", tooltip="The third feature to use for ML predictions.", group="Feature Engineering")
f3_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 3.", defval=20, inline = "06", group="Feature Engineering")
f3_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 3 (if applicable).", defval=1, inline = "06", group="Feature Engineering")
f4_string = input.string(title="Feature 4", options=["RSI", "WT", "CCI", "ADX"], defval="ADX", inline = "07", tooltip="The fourth feature to use for ML predictions.", group="Feature Engineering")
f4_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 4.", defval=20, inline = "08", group="Feature Engineering")
f4_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 4 (if applicable).", defval=2, inline = "08", group="Feature Engineering")
f5_string = input.string(title="Feature 5", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline = "09", tooltip="The fifth feature to use for ML predictions.", group="Feature Engineering")
f5_paramA = input.int(title="Parameter A", tooltip="The primary parameter of feature 5.", defval=9, inline = "10", group="Feature Engineering")
f5_paramB = input.int(title="Parameter B", tooltip="The secondary parameter of feature 5 (if applicable).", defval=1, inline = "10", group="Feature Engineering")

// FeatureSeries Object: Calculated Feature Series based on Feature Variables
featureSeries = 
 FeatureSeries.new(
   series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB), // f1
   series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB), // f2 
   series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB), // f3
   series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB), // f4
   series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)  // f5
 )

// FeatureArrays Variables: Storage of Feature Series as Feature Arrays Optimized for ML
// Note: These arrays cannot be dynamically created within the FeatureArrays Object Initialization and thus must be set-up in advance.
var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()
array.push(f1Array, featureSeries.f1)
array.push(f2Array, featureSeries.f2)
array.push(f3Array, featureSeries.f3)
array.push(f4Array, featureSeries.f4)
array.push(f5Array, featureSeries.f5)

// FeatureArrays Object: Storage of the calculated FeatureArrays into a single object
featureArrays = 
 FeatureArrays.new(
  f1Array, // f1
  f2Array, // f2
  f3Array, // f3
  f4Array, // f4
  f5Array  // f5
 )

// Label Object: Used for classifying historical data as training data for the ML Model
Label AIdirection = 
 Label.new(
   long=1, 
   short=-1, 
   neutral=0
  )

// Derived from General Settings
maxBarsBackIndex = last_bar_index >= settings.maxBarsBack ? last_bar_index - settings.maxBarsBack : 0

// EMA Settings 
useEmaFilter = input.bool(title="Use EMA Filter", defval=false, group="Filters", inline="ema")
emaPeriod = input.int(title="Period", defval=2000, minval=1, step=1, group="Filters", inline="ema", tooltip="The period of the EMA used for the EMA Filter.")
isEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true
isEmaDowntrend = useEmaFilter ? close < ta.ema(close, emaPeriod) : true
useSmaFilter = input.bool(title="Use SMA Filter", defval=false, group="Filters", inline="sma")
smaPeriod = input.int(title="Period", defval=2000, minval=1, step=1, group="Filters", inline="sma", tooltip="The period of the SMA used for the SMA Filter.")
isSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true
isSmaDowntrend = useSmaFilter ? close < ta.sma(close, smaPeriod) : true

// Nadaraya-Watson Kernel Regression Settings
useKernelFilter = input.bool(true, "Trade with Kernel", group="Kernel Settings", inline="kernel")
showKernelEstimate = input.bool(false, "Show Kernel Estimate", group="Kernel Settings", inline="kernel")
useKernelSmoothing = input.bool(false, "Enhance Kernel Smoothing", tooltip="Uses a crossover based mechanism to smoothen kernel color changes. This often results in less color transitions overall and may result in more ML entry signals being generated.", inline='1', group='Kernel Settings')
h = input.int(8, 'Lookback Window', minval=3, tooltip='The number of bars used for the estimation. This is a sliding value that represents the most recent historical bars. Recommended range: 3-50', group="Kernel Settings", inline="kernel")
r = input.float(8., 'Relative Weighting', step=0.25, tooltip='Relative weighting of time frames. As this value approaches zero, the longer time frames will exert more influence on the estimation. As this value approaches infinity, the behavior of the Rational Quadratic Kernel will become identical to the Gaussian kernel. Recommended range: 0.25-25', group="Kernel Settings", inline="kernel")
x = input.int(25, "Regression Level", tooltip='Bar index on which to start regression. Controls how tightly fit the kernel estimate is to the data. Smaller values are a tighter fit. Larger values are a looser fit. Recommended range: 2-25', group="Kernel Settings", inline="kernel")
lag = input.int(2, "Lag", tooltip="Lag for crossover detection. Lower values result in earlier crossovers. Recommended range: 1-2", inline='1', group='Kernel Settings')

// Display Settings
showBarColors = input.bool(true, "Show Bar Colors", tooltip="Whether to show the bar colors.", group="Display Settings")
showBarPredictions = input.bool(defval = false, title = "Show Bar Prediction Values", tooltip = "Will show the ML model's evaluation of each bar as an integer.", group="Display Settings")
useAtrOffset = input.bool(defval = false, title = "Use ATR Offset", tooltip = "Will use the ATR offset instead of the bar prediction offset.", group="Display Settings")
barPredictionsOffset = input.float(0, "Bar Prediction Offset", minval=0, tooltip="The offset of the bar predictions as a percentage from the bar high or close.", group="Display Settings")

// =================================
// ==== Next Bar Classification ====
// =================================

// This model specializes specifically in predicting the direction of price action over the course of the next 4 bars. 
// To avoid complications with the ML model, this value is hardcoded to 4 bars but support for other training lengths may be added in the future.
AIsrc = settings.source
y_train_series = AIsrc[4] < AIsrc[0] ? AIdirection.short : AIsrc[4] > AIsrc[0] ? AIdirection.long : AIdirection.neutral
var y_train_array = array.new_int(0)

// Variables used for ML Logic
var predictions = array.new_float(0)
var prediction = 0.
var signal = AIdirection.neutral
var distances = array.new_float(0)

array.push(y_train_array, y_train_series)

// =========================
// ====  Core ML Logic  ====
// =========================

lastDistance = -1.0
size = math.min(settings.maxBarsBack-1, array.size(y_train_array)-1)
sizeLoop = math.min(settings.maxBarsBack-1, size)

if bar_index >= maxBarsBackIndex //{
    for i = 0 to sizeLoop //{
        d = get_lorentzian_distance(i, settings.featureCount, featureSeries, featureArrays) 
        if d >= lastDistance and i%4 //{
            lastDistance := d            
            array.push(distances, d)
            array.push(predictions, math.round(array.get(y_train_array, i)))
            if array.size(predictions) > settings.neighborsCount //{
                lastDistance := array.get(distances, math.round(settings.neighborsCount*3/4))
                array.shift(distances)
                array.shift(predictions)
            //}
        //}
    //}
    prediction := array.sum(predictions)
//}

// ============================
// ==== Prediction Filters ====
// ============================

// User Defined Filters: Used for adjusting the frequency of the ML Model's predictions
filter_all = filter.volatility and filter.regime and filter.adx

// Filtered Signal: The model's prediction of future price movement direction with user-defined filters applied
signal := prediction > 0 and filter_all ? AIdirection.long : prediction < 0 and filter_all ? AIdirection.short : nz(signal[1])

// Bar-Count Filters: Represents strict filters based on a pre-defined holding period of 4 bars
var int barsHeld = 0
barsHeld := ta.change(signal) ? 0 : barsHeld + 1
isHeldFourBars = barsHeld == 4
isHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4

// Fractal Filters: Derived from relative appearances of signals in a given time series fractal/segment with a default length of 4 bars
isDifferentSignalType = ta.change(signal)
isEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal[2]) or ta.change(signal[3]))
isBuySignal = signal == AIdirection.long and isEmaUptrend and isSmaUptrend
isSellSignal = signal == AIdirection.short and isEmaDowntrend and isSmaDowntrend
isLastSignalBuy = signal[4] == AIdirection.long and isEmaUptrend[4] and isSmaUptrend[4]
isLastSignalSell = signal[4] == AIdirection.short and isEmaDowntrend[4] and isSmaDowntrend[4]
isNewBuySignal = isBuySignal and isDifferentSignalType
isNewSellSignal = isSellSignal and isDifferentSignalType

// Kernel Regression Filters: Filters based on Nadaraya-Watson Kernel Regression using the Rational Quadratic Kernel
// For more information on this technique refer to my other open source indicator located here: 
// https://www.tradingview.com/script/AWNvbPRM-Nadaraya-Watson-Rational-Quadratic-Kernel-Non-Repainting/
c_green = TTBColors.colorUp()
c_red = TTBColors.colorDown()
transparent = color.new(#000000, 100)
yhat1 = kernels.rationalQuadratic(settings.source, h, r, x)
yhat2 = kernels.gaussian(settings.source, h-lag, x)
kernelEstimate = yhat1
// Kernel Rates of Change
bool wasBearishRate = yhat1[2] > yhat1[1]
bool wasBullishRate = yhat1[2] < yhat1[1]
bool isBearishRate = yhat1[1] > yhat1
bool isBullishRate = yhat1[1] < yhat1
isBearishChange = isBearishRate and wasBullishRate
isBullishChange = isBullishRate and wasBearishRate
// Kernel Crossovers
bool isBullishCrossAlert = ta.crossover(yhat2, yhat1)
bool isBearishCrossAlert = ta.crossunder(yhat2, yhat1) 
bool isBullishSmooth = yhat2 >= yhat1
bool isBearishSmooth = yhat2 <= yhat1
// Kernel Colors
color colorByCross = isBullishSmooth ? c_green : c_red
color colorByRate = isBullishRate ? c_green : c_red
color plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent
//checkbox to hide/show kernel
//showKernel = input(defval=false, title="Show Kernel")
//plot(showKernel ? kernelEstimate : na, color=plotColor, linewidth=2, title="Kernel Regression Estimate")
// Alert Variables
bool alertBullish = useKernelSmoothing ? isBullishCrossAlert : isBullishChange
bool alertBearish = useKernelSmoothing ? isBearishCrossAlert : isBearishChange
// Bullish and Bearish Filters based on Kernel
isBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true
isBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true

// ===========================
// ==== Entries and Exits ====
// ===========================

// Entry Conditions: Booleans for ML Model Position Entries
startLongTrade = isNewBuySignal and isBullish and isEmaUptrend and isSmaUptrend
startShortTrade = isNewSellSignal and isBearish and isEmaDowntrend and isSmaDowntrend

// Dynamic Exit Conditions: Booleans for ML Model Position Exits based on Fractal Filters and Kernel Regression Filters
lastSignalWasBullish = ta.barssince(startLongTrade) < ta.barssince(startShortTrade)
lastSignalWasBearish = ta.barssince(startShortTrade) < ta.barssince(startLongTrade)
barsSinceRedEntry = ta.barssince(startShortTrade)
barsSinceRedExit = ta.barssince(alertBullish)
barsSinceGreenEntry = ta.barssince(startLongTrade)
barsSinceGreenExit = ta.barssince(alertBearish)
isValidShortExit = barsSinceRedExit > barsSinceRedEntry
isValidLongExit = barsSinceGreenExit > barsSinceGreenEntry
endLongTradeDynamic = (isBearishChange and isValidLongExit[1])
endShortTradeDynamic = (isBullishChange and isValidShortExit[1])

// Fixed Exit Conditions: Booleans for ML Model Position Exits based on a Bar-Count Filters
endLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars and isNewSellSignal and isLastSignalBuy)) and startLongTrade[4]
endShortTradeStrict = ((isHeldFourBars and isLastSignalSell) or (isHeldLessThanFourBars and isNewBuySignal and isLastSignalSell)) and startShortTrade[4]
isDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing
endLongTrade = settings.useDynamicExits and isDynamicExitValid ? endLongTradeDynamic : endLongTradeStrict 
endShortTrade = settings.useDynamicExits and isDynamicExitValid ? endShortTradeDynamic : endShortTradeStrict

// =========================
// ==== Plotting Labels ====
// =========================

// Note: These will not repaint once the most recent bar has fully closed. By default, signals appear over the last closed bar; to override this behavior set offset=0.
//plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=ml.color_green(prediction), size=size.small, offset=0)
//plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, ml.color_red(-prediction), size=size.small, offset=0)
plotshape(startLongTrade ? low : na, 'Buy', shape.labelup, location.belowbar, color=TTBColors.colorUp(), size=size.small, offset=0)
plotshape(startShortTrade ? high : na, 'Sell', shape.labeldown, location.abovebar, color=TTBColors.colorDown(), size=size.small, offset=0)
//plotshape(endLongTrade and settings.showExits ? high : na, 'StopBuy', shape.xcross, location.absolute, color=#3AFF17, size=size.tiny, offset=0)
//plotshape(endShortTrade and settings.showExits ? low : na, 'StopSell', shape.xcross, location.absolute, color=#FD1707, size=size.tiny, offset=0)

// ================
// ==== Alerts ====
// ================ 

// Separate Alerts for Entries and Exits
//alertcondition(startLongTrade, title='Open Long ▲', message='LDC Open Long ▲ | {{ticker}}@{{close}} | ({{interval}})')
//alertcondition(endLongTrade, title='Close Long ▲', message='LDC Close Long ▲ | {{ticker}}@{{close}} | ({{interval}})')
//alertcondition(startShortTrade, title='Open Short ▼', message='LDC Open Short  | {{ticker}}@{{close}} | ({{interval}})')
//alertcondition(endShortTrade, title='Close Short ▼', message='LDC Close Short ▼ | {{ticker}}@{{close}} | ({{interval}})')

// Combined Alerts for Entries and Exits
//alertcondition(startShortTrade or startLongTrade, title='Open Position ▲▼', message='LDC Open Position ▲▼ | {{ticker}}@{{close}} | ({{interval}})')
//alertcondition(endShortTrade or endLongTrade, title='Close Position ▲▼', message='LDC Close Position  ▲▼ | {{ticker}}@[{{close}}] | ({{interval}})')

// Kernel Estimate Alerts
//alertcondition(condition=alertBullish, title='Kernel Bullish Color Change', message='LDC Kernel Bullish ▲ | {{ticker}}@{{close}} | ({{interval}})')
//alertcondition(condition=alertBearish, title='Kernel Bearish Color Change', message='LDC Kernel Bearish ▼ | {{ticker}}@{{close}} | ({{interval}})')

// =========================
// ==== Display Signals ==== 
// =========================

//atrSpaced = useAtrOffset ? ta.atr(1) : na
//compressionFactor = settings.neighborsCount / settings.colorCompression
//c_pred = prediction > 0 ? color.from_gradient(prediction, 0, compressionFactor, #787b86, #009988) : prediction <= 0 ? color.from_gradient//(prediction, -compressionFactor, 0, #CC3311, #787b86) : na
//c_label = showBarPredictions ? c_pred : na
//c_bars = showBarColors ? color.new(c_pred, 50) : na
//x_val = bar_index
//y_val = useAtrOffset ? prediction > 0 ? high + atrSpaced: low - atrSpaced : prediction > 0 ? high + hl2*barPredictionsOffset/20 : low - //hl2*barPredictionsOffset/30
//label.new(x_val, y_val, str.tostring(prediction), xloc.bar_index, yloc.price, color.new(color.white, 100), label.style_label_up, c_label, size.normal, text.align_left)
//barcolor(showBarColors ? color.new(c_pred, 50) : na)

// ===================== 
// ==== Backtesting ====
// =====================

// The following can be used to stream signals to a backtest adapter
backTestStream = switch 
    startLongTrade => 1
    endLongTrade => 2
    startShortTrade => -1
    endShortTrade => -2
//plot(backTestStream, "Backtest Stream", display=display.none)

// The following can be used to display real-time trade stats. This can be a useful mechanism for obtaining real-time feedback during Feature Engineering. This does NOT replace the need to properly backtest.
// Note: In this context, a "Stop-Loss" is defined instances where the ML Signal prematurely flips directions before an exit signal can be generated.
// [totalWins, totalLosses, totalEarlySignalFlips, totalTrades, tradeStatsHeader, winLossRatio, winRate] = ml.backtest(high, low, open, startLongTrade, endLongTrade, startShortTrade, endShortTrade, isEarlySignalFlip, maxBarsBackIndex, bar_index, settings.source, useWorstCase)

// init_table() =>
//     c_transparent = color.new(color.black, 100)
//     table.new(position.top_right, columns=2, rows=7, frame_color=color.new(color.black, 100), frame_width=1, border_width=1, border_color=c_transparent)

// update_table(tbl, tradeStatsHeader, totalTrades, totalWins, totalLosses, winLossRatio, winRate, stopLosses) => 
//     c_transparent = color.new(color.black, 100)
//     table.cell(tbl, 0, 0, tradeStatsHeader, text_halign=text.align_center, text_color=color.gray, text_size=size.normal)
//     table.cell(tbl, 0, 1, 'Winrate', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
//     table.cell(tbl, 1, 1, str.tostring(totalWins / totalTrades, '#.#%'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
//     table.cell(tbl, 0, 2, 'Trades', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
//     table.cell(tbl, 1, 2, str.tostring(totalTrades, '#') + ' (' + str.tostring(totalWins, '#') + '|' + str.tostring(totalLosses, '#') + ')', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
//     table.cell(tbl, 0, 5, 'WL Ratio', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
//     table.cell(tbl, 1, 5, str.tostring(totalWins / totalLosses, '0.00'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
//     table.cell(tbl, 0, 6, 'Early Signal Flips', text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)
//     table.cell(tbl, 1, 6, str.tostring(totalEarlySignalFlips, '#'), text_halign=text.align_center, bgcolor=c_transparent, text_color=color.gray, text_size=size.normal)

// if showTradeStats
//     var tbl = ml.init_table()
//     if barstate.islast
//         update_table(tbl, tradeStatsHeader, totalTrades, totalWins, totalLosses, winLossRatio, winRate, totalEarlySignalFlips)

// added plots
plotshape(startLongTrade, color=TTBColors.colorUp(), style=shape.triangleup, size=size.tiny, title="Long Entry", location=location.belowbar)
plotshape(startShortTrade, color=TTBColors.colorDown(), style=shape.triangledown, size=size.tiny, title="Short Entry", location=location.abovebar)

plot(startLongTrade ? 1 : startShortTrade ? -1 : na, title="Signal", display=display.none)

AIbuy = startLongTrade
AIsell = startShortTrade
//  end lorentzian
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}




//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// Begin SnD
// Inputs
ExtendLines1 = true
ext_active = true
ShowLabel = true
label_loc = 'Right'
label_offset = 15
show_HL = true
show_close = true
LineStyleHLInput = 'Solid'
LineWidthHLInput = 1
LineStyleCloseInput = 'Solid'
LineWidthCloseInput = 1

var string LineStyleHL = na

LineStyleHL := if LineStyleHLInput == 'Solid'
    line.style_solid
else if LineStyleHLInput == 'Dotted'
    line.style_dotted
else if LineStyleHLInput == 'Dashed'
    line.style_dashed

var string LineStyleClose = na

LineStyleClose := if LineStyleCloseInput == 'Solid'
    line.style_solid
else if LineStyleCloseInput == 'Dotted'
    line.style_dotted
else if LineStyleCloseInput == 'Dashed'
    line.style_dashed

// Time Frame 1 = TF1
TF1_Menu = input.string(title='Display Lines Only, With Zones, or Disable     ', defval='S/R Zones', options=['S/R', 'S/R Zones', 'Disable'], group='*** Time Frame 1 ***')
TF1_input = input.string(title='Time Frame 1', defval='4h', options=['Chart', '1m', '3m', '5m', '15m', '30m', '45m', '1h', '2h', '3h', '4h', '6h', '8h', '12h', 'D', '3D', 'W', '2W', '1M', '12M'], group='*** Time Frame 1 ***')
TF1_VolMA1Input = input.int(title='Volume MA - Threshold', defval=6, group='*** Time Frame 1 ***')
TF1_NumZones = input.int(title='Number of Zones Back', defval=30, minval=1, maxval=100, group='*** Time Frame 1 ***',
 tooltip='Change how many zones back you would like on the chart for time frame 1 (this number applies to both # of support zones and # of resistance zones back). Be mindful of setting too high with other zones, as the maximum total lines allowed on the chart is 500.')
TF1_extRight = input.bool(title='Extend S/R Zones to Right', defval=false, group='*** Time Frame 1 ***')
TF1_ResLinesColor = input.color(color.new(color.red, 20), 'Resistance Lines Color', inline='1', group='*** Time Frame 1 ***')
TF1_ResZoneColor = input.color(color.new(color.red, 90), 'Resistance Zone Color', inline='2', group='*** Time Frame 1 ***')
TF1_SupLinesColor = input.color(color.new(color.lime, 20), '        Support Lines Color', inline='1', group='*** Time Frame 1 ***')
TF1_SupZoneColor = input.color(color.new(color.lime, 90), '         Support Zone Color', inline='2', group='*** Time Frame 1 ***')

// Time Frame 2 = TF2
TF2_Menu = input.string(title='Display Lines Only, With Zones, or Disable     ', defval='S/R Zones', options=['S/R', 'S/R Zones', 'Disable'], group='*** Time Frame 2 ***')
TF2_input = input.string(title='Time Frame 2', defval='D', options=['1m', '3m', '5m', '15m', '30m', '45m', '1h', '2h', '3h', '4h', '6h', '8h', '12h', 'D', '3D', 'W', '2W', '1M', '12M'], group='*** Time Frame 2 ***')
TF2_VolMA1Input = input.int(title='Volume MA - Threshold', defval=6, group='*** Time Frame 2 ***')
TF2_NumZones = input.int(title='Number of Zones Back', defval=30, minval=1, maxval=100, group='*** Time Frame 2 ***',
 tooltip='Change how many zones back you would like on the chart for time frame 2 (this number applies to both # of support zones and # of resistance zones back). Be mindful of setting too high with other zones, as the maximum total lines allowed on the chart is 500.')
TF2_extRight = input.bool(title='Extend S/R Zones to Right', defval=false, group='*** Time Frame 2 ***')
TF2_ResLinesColor = input.color(color.new(color.fuchsia, 20), 'Resistance Lines Color', inline='1', group='*** Time Frame 2 ***')
TF2_ResZoneColor = input.color(color.new(color.fuchsia, 90), 'Resistance Zone Color', inline='2', group='*** Time Frame 2 ***')
TF2_SupLinesColor = input.color(color.new(color.green, 20), '        Support Lines Color', inline='1', group='*** Time Frame 2 ***')
TF2_SupZoneColor = input.color(color.new(color.green, 90), '         Support Zone Color', inline='2', group='*** Time Frame 2 ***')


f_TFx(_TF_input) =>
    if _TF_input == 'Chart'
        timeframe.period
    else if _TF_input == '1m'
        '1'
    else if _TF_input == '3m'
        '3'
    else if _TF_input == '5m'
        '5'
    else if _TF_input == '15m'
        '15'
    else if _TF_input == '30m'
        '30'
    else if _TF_input == '45m'
        '45'
    else if _TF_input == '1h'
        '60'
    else if _TF_input == '2h'
        '120'
    else if _TF_input == '3h'
        '180'
    else if _TF_input == '4h'
        '240'
    else if _TF_input == '6h'
        '360'
    else if _TF_input == '8h'
        '480'
    else if _TF_input == '12h'
        '720'
    else if _TF_input == 'D'
        'D'
    else if _TF_input == '3D'
        '3D'
    else if _TF_input == 'W'
        'W'
    else if _TF_input == '2W'
        '2W'
    else if _TF_input == '1M'
        '1M'
    else if _TF_input == '12M'
        '12M'  

TF1 = f_TFx(TF1_input)
TF2 = f_TFx(TF2_input)

vol_check = na(volume) or volume[1]==0
var table vol_check_table = na
if barstate.islast and vol_check
    table.delete(vol_check_table)
    vol_check_table := table.new(position=position.middle_right, columns=1, rows=1, frame_color=color.red, frame_width=1)
    table.cell(vol_check_table, column=0, row=0, text='There is no volume data for this symbol' + ' (' + syminfo.tickerid + ')' + '\n Please use a different symbol with volume data', text_color=color.red)

// // --------- This ensures that no plots from lower time frames will be plotted on higher time frames.
// ————— Converts current chart resolution into a float minutes value.
f_resInMinutes() =>
    _resInMinutes = timeframe.multiplier * (timeframe.isseconds ? 1. / 60 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : na)
    _resInMinutes
// ————— Returns the float minutes value of the string _res.
f_tfResInMinutes(_res) =>
    // _res: resolution of any TF (in "timeframe.period" string format).
    // Dependency: f_resInMinutes().
    request.security(syminfo.tickerid, _res, f_resInMinutes())

// —————————— Determine if current timeframe is smaller that higher timeframe selected in Inputs.
// Get higher timeframe in minutes.
TF1InMinutes = f_tfResInMinutes(TF1)
TF2InMinutes = f_tfResInMinutes(TF2)

// Get current timeframe in minutes.
currentTFInMinutes = f_resInMinutes()
// Compare current TF to higher TF to make sure it is smaller, otherwise our plots don't make sense.
chartOnLowerTF1 = currentTFInMinutes <= TF1InMinutes
chartOnLowerTF2 = currentTFInMinutes <= TF2InMinutes

chartEqualTF2 = currentTFInMinutes == TF2InMinutes and TF2_Menu != 'Disable'

TF1_inH = str.tostring(TF1InMinutes / 60)
TF1_text = TF1InMinutes >= 60 and TF1InMinutes < 1440 ? TF1_inH + 'h' : TF1InMinutes < 60 ? TF1 + 'm' : TF1

//--- In order to get the left side of SR zone on higher time frames to line up directly on the bar with the fractal high or fractal low, we need to perform
//--- a series of calculations to find the pivot high/low. Since the FractalUp or FractalDown condition is found after 2 confirming bars, the SR zone would begin
//--- at the opening of the 3rd bar following the pivot high/low). For example, if there is a 4hr Fractal confirmed while on the 1hr chart, it would take 3 4hr bars to confirm. 
//--- That means the high/low point could've occured anywhere between 8-12 1hr bars ago.
// // --------- To get the correct bar_index for higher time frame SR zones placed on lower time frame candles, first the range of candles to scan needs to be established.
// // --------- Then find the highest/lowest bar within that range of bars for bar_index on the x1 (left) coordinates of lines (next steps below)
bool TF1_newbar = ta.change(time(TF1)) != 0, bool TF2_newbar = ta.change(time(TF2)) != 0
TF1_bi1 = ta.valuewhen(TF1_newbar, bar_index, 1), TF2_bi1 = ta.valuewhen(TF2_newbar, bar_index, 1)
TF1_bi5 = ta.valuewhen(TF1_newbar, bar_index, 5), TF2_bi5 = ta.valuewhen(TF2_newbar, bar_index, 5)
TF1_bb1 = bar_index-TF1_bi1, TF2_bb1 = bar_index-TF2_bi1
TF1_bb5 = bar_index-TF1_bi5, TF2_bb5 = bar_index-TF2_bi5
TF1_br = TF1_bb5 - TF1_bb1, TF2_br = TF2_bb5 - TF2_bb1

// Get offset value for the highest high or lowest low found within the specified range , using [] to establish the starting point back to begin scanning past bars for highest high or lowest low. 
// Moving the starting point back ensures it scans within the range in which the high/low was found by FractalUp/FractalDown condition.
// Output by default is negative, make positive with absolute value for bar_index.
// Adding the TFx_bar_index back in accounts for the number of bars skipped back in [].
// First check if the number of bars back to scan for pivot high/low is going to be over the max bars back, and if so set the bar_index to the max bars back, 
// otherwise get exact bar index value for pivot high/low.

var int TF1_Hi_Bi = na
var int TF1_Lo_Bi = na
var int TF2_Hi_Bi = na
var int TF2_Lo_Bi = na
var int TF3_Hi_Bi = na
var int TF3_Lo_Bi = na
var int TF4_Hi_Bi = na
var int TF4_Lo_Bi = na

if TF1_bb1 > 4999 or (TF1_bb1 + TF1_br) > 4999
    TF1_Hi_Bi := 4999
    TF1_Lo_Bi := 4999
else
    TF1_Hi_Bi := math.abs(ta.highestbars(high, nz(TF1_br, 1)))[TF1_bb1] + TF1_bb1
    TF1_Lo_Bi := math.abs(ta.lowestbars(low, nz(TF1_br, 1)))[TF1_bb1] + TF1_bb1

if TF2_bb1 > 4999 or (TF2_bb1 + TF2_br) > 4999
    TF2_Hi_Bi := 4999
    TF2_Lo_Bi := 4999
else
    TF2_Hi_Bi := math.abs(ta.highestbars(high, nz(TF2_br, 1)))[TF2_bb1] + TF2_bb1
    TF2_Lo_Bi := math.abs(ta.lowestbars(low, nz(TF2_br, 1)))[TF2_bb1] + TF2_bb1



// TFUp and TFDown Calculations
f_tfUp(_TF_High, _TF_Vol, _TF_VolMA) =>
    _TF_High[3] > _TF_High[4] and _TF_High[4] > _TF_High[5] and _TF_High[2] < _TF_High[3] and _TF_High[1] < _TF_High[2] and _TF_Vol[3] > _TF_VolMA[3]
f_tfDown(_TF_Low, _TF_Vol, _TF_VolMA) =>
    _TF_Low[3] < _TF_Low[4] and _TF_Low[4] < _TF_Low[5] and _TF_Low[2] > _TF_Low[3] and _TF_Low[1] > _TF_Low[2] and _TF_Vol[3] > _TF_VolMA[3]

// Function for each time frame's various sources used in FractalUp and FractalDown calculations.
f_tfSources(_res, _source) =>
    request.security(syminfo.tickerid, _res, _source)

// Line and label arrays
var TF1_UpperSupportLine_array = array.new_line(TF1_NumZones), var TF2_UpperSupportLine_array = array.new_line(TF2_NumZones)
var TF1_LowerSupportLine_array = array.new_line(TF1_NumZones), var TF2_LowerSupportLine_array = array.new_line(TF2_NumZones)
var TF1SupLabel_array = array.new_label(1), var TF2SupLabel_array = array.new_label(1)

var TF1_UpperResLine_array = array.new_line(TF1_NumZones), var TF2_UpperResLine_array = array.new_line(TF2_NumZones)
var TF1_LowerResLine_array = array.new_line(TF1_NumZones), var TF2_LowerResLine_array = array.new_line(TF2_NumZones)
var TF1ResLabel_array = array.new_label(1), var TF2ResLabel_array = array.new_label(1)

// Resistance Line Functions
TF_ResistanceLineA(TF_input,TF_FractalUp,TF_ResLineColor,TF_UpperResLine_array,TF_NumZones,TF_ResZone, TF_LowerResLine_array,TF_text,TF_ResLabel_array,bi_hi,bi_3,bi,bi_2,ext_right) =>
    if show_HL
        UpperResistanceLine = line.new(x1=TF_input != 'Chart' ? bi_hi : bi_3, y1=TF_FractalUp, x2=bi, y2=TF_FractalUp, color=TF_ResLineColor, style=LineStyleHL, width=LineWidthHLInput, extend=extend.right)
        line.set_extend(id=array.get(TF_UpperResLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_UpperResLine_array, TF_NumZones-1), x=TF_input != 'Chart' ? bi_hi : bi_3)
        array.push(TF_UpperResLine_array, UpperResistanceLine)
        line.delete(array.shift(TF_UpperResLine_array))
    if show_close
        LowerResistanceLine = line.new(x1=TF_input != 'Chart' ? bi_hi : bi_3, y1=TF_ResZone, x2=bi, y2=TF_ResZone, color=TF_ResLineColor, style=LineStyleClose, width=LineWidthCloseInput, extend=extend.right)
        line.set_extend(id=array.get(TF_LowerResLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_LowerResLine_array, TF_NumZones-1), x=TF_input != 'Chart' ? bi_hi : bi_3)
        array.push(TF_LowerResLine_array, LowerResistanceLine)
        line.delete(array.shift(TF_LowerResLine_array))
    if ShowLabel == true and label_loc == 'Left'
        TFResLabel = label.new(TF_input != 'Chart' ? bi_hi : bi_2, TF_FractalUp, text=TF_text + "(R)", color=color.new(color.white, 100), size=size.normal, style=label.style_label_right, textcolor=TF_ResLineColor)
        array.push(TF_ResLabel_array, TFResLabel)
        label.delete(array.shift(TF_ResLabel_array))

TF_ResistanceLineB(TF_FractalUp,TF_ResLineColor,TF_UpperResLine_array,TF_NumZones,TF_ResZone,TF_LowerResLine_array,TF_text,TF_ResLabel_array,bi3,bi,ext_right) =>
    if show_HL
        UpperResistanceLine = line.new(x1=bi3, y1=TF_FractalUp, x2=bi, y2=TF_FractalUp, color=TF_ResLineColor, style=LineStyleHL, width=LineWidthHLInput, extend=extend.right)
        line.set_extend(id=array.get(TF_UpperResLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_UpperResLine_array, TF_NumZones-1), x=bi3)
        array.push(TF_UpperResLine_array, UpperResistanceLine)
        line.delete(array.shift(TF_UpperResLine_array))
    if show_close
        LowerResistanceLine = line.new(x1=bi3, y1=TF_ResZone, x2=bi, y2=TF_ResZone, color=TF_ResLineColor, style=LineStyleClose, width=LineWidthCloseInput, extend=extend.right)
        line.set_extend(id=array.get(TF_LowerResLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_LowerResLine_array, TF_NumZones-1), x=bi3)
        array.push(TF_LowerResLine_array, LowerResistanceLine)
        line.delete(array.shift(TF_LowerResLine_array))
    if ShowLabel == true and label_loc == 'Left'
        TFResLabel = label.new(bi3, TF_FractalUp, text=TF_text + "(R)", color=color.new(color.white, 100), size=size.normal, style=label.style_label_right, textcolor=TF_ResLineColor)
        array.push(TF_ResLabel_array, TFResLabel)
        label.delete(array.shift(TF_ResLabel_array))

// Support Line Functions
TF_SupportLineA(TF_input, TF_FractalDown,TF_SupLinesColor,TF_UpperSupportLine_array,TF_NumZones,TF_SupportZone, TF_LowerSupportLine_array,TF_text,TF_SupLabel_array,bi_lo,bi_3,bi,bi_2,ext_right) =>
    if show_close
        UpperSupportLine = line.new(x1=TF_input != 'Chart' ? bi_lo : bi_3, y1=TF_SupportZone, x2=bi, y2=TF_SupportZone, color=TF_SupLinesColor, style=LineStyleClose, width=LineWidthCloseInput, extend=extend.right)
        line.set_extend(id=array.get(TF_UpperSupportLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_UpperSupportLine_array, TF_NumZones-1), x=TF_input != 'Chart' ? bi_lo : bi_3)
        array.push(TF_UpperSupportLine_array, UpperSupportLine)
        line.delete(array.shift(TF_UpperSupportLine_array))
    if show_HL
        LowerSupportLine = line.new(x1=TF_input != 'Chart' ? bi_lo : bi_3, y1=TF_FractalDown, x2=bi, y2=TF_FractalDown, color=TF_SupLinesColor, style=LineStyleHL, width=LineWidthHLInput, extend=extend.right)
        line.set_extend(id=array.get(TF_LowerSupportLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_LowerSupportLine_array, TF_NumZones-1), x=TF_input != 'Chart' ? bi_lo : bi_3)
        array.push(TF_LowerSupportLine_array, LowerSupportLine)
        line.delete(array.shift(TF_LowerSupportLine_array))
    if ShowLabel == true and label_loc == 'Left'
        SupLabel = label.new(TF_input != 'Chart' ? bi_lo : bi_2, TF_FractalDown, text=TF_text + "(S)", color=color.new(color.white, 100), size=size.normal, style=label.style_label_right, textcolor=TF_SupLinesColor)
        array.push(TF_SupLabel_array, SupLabel)
        label.delete(array.shift(TF_SupLabel_array))

TF_SupportLineB(TF_FractalDown,TF_SupLinesColor,TF_UpperSupportLine_array,TF_NumZones,TF_SupportZone,TF_LowerSupportLine_array,TF_text,TF_SupLabel_array,bi3,bi,ext_right) =>
    if show_close
        UpperSupportLine = line.new(x1=bi3, y1=TF_SupportZone, x2=bi, y2=TF_SupportZone, color=TF_SupLinesColor, style=LineStyleClose, width=LineWidthCloseInput, extend=extend.right)
        line.set_extend(id=array.get(TF_UpperSupportLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_UpperSupportLine_array, TF_NumZones-1), x=bi3)
        array.push(TF_UpperSupportLine_array, UpperSupportLine)
        line.delete(array.shift(TF_UpperSupportLine_array))
    if show_HL
        LowerSupportLine = line.new(x1=bi3, y1=TF_FractalDown, x2=bi, y2=TF_FractalDown, color=TF_SupLinesColor, style=LineStyleHL, width=LineWidthHLInput, extend=extend.right)
        line.set_extend(id=array.get(TF_LowerSupportLine_array, TF_NumZones-1), extend=ext_right ? extend.right : extend.none)
        if ExtendLines1 == true
            line.set_x2(id=array.get(TF_LowerSupportLine_array, TF_NumZones-1), x=bi3)
        array.push(TF_LowerSupportLine_array, LowerSupportLine)
        line.delete(array.shift(TF_LowerSupportLine_array))
    if ShowLabel == true and label_loc == 'Left'
        SupLabel = label.new(bi3, TF_FractalDown, text=TF_text + "(S)", color=color.new(color.white, 100), size=size.normal, style=label.style_label_right, textcolor=TF_SupLinesColor)
        array.push(TF_SupLabel_array, SupLabel)
        label.delete(array.shift(TF_SupLabel_array))

// Label Function
TFLabel(bi, TF_Fractal, txt, txtcolor, TFLabel_array) =>
    Label = label.new(bi, TF_Fractal, text=txt, size=size.normal, style=label.style_none, textcolor=txtcolor)
    array.push(TFLabel_array, Label)
    label.delete(array.shift(TFLabel_array))

// S/R  = Time Frame 1 = TF1
TF1_Vol = f_tfSources(TF1, volume)
TF1_VolMA = ta.sma(TF1_Vol, TF1_VolMA1Input)
TF1_High = f_tfSources(TF1, high)
TF1_Low = f_tfSources(TF1, low)
TF1_Open = f_tfSources(TF1, open)
TF1_Close = f_tfSources(TF1, close)

TF1_Up = f_tfUp(TF1_High, TF1_Vol, TF1_VolMA)
TF1_Down = f_tfDown(TF1_Low, TF1_Vol, TF1_VolMA)

TF1_CalcFractalUp() =>
    TF1_FractalUp = 0.0
    TF1_FractalUp := TF1_Up ? TF1_High[3] : TF1_FractalUp[1]
    TF1_FractalUp

TF1_CalcFractalDown() =>
    TF1_FractalDown = 0.0
    TF1_FractalDown := TF1_Down ? TF1_Low[3] : TF1_FractalDown[1]
    TF1_FractalDown

TF1_FractalUp = request.security(syminfo.tickerid, TF1, TF1_CalcFractalUp())
TF1_FractalDown = request.security(syminfo.tickerid, TF1, TF1_CalcFractalDown())

// Zones - Current Time Frame = Time Frame 1 = TF1
// Fractal Up Zones
TF1_CalcFractalUpZone() =>
    TF1_FractalUpZone = 0.0
    TF1_FractalUpZone := TF1_Up and TF1_Close[3] >= TF1_Open[3] ? TF1_Close[3] : TF1_Up and TF1_Close[3] < TF1_Open[3] ? TF1_Open[3] : TF1_FractalUpZone[1]
    TF1_FractalUpZone

TF1_FractalUpZone = request.security(syminfo.tickerid, TF1, TF1_CalcFractalUpZone())
TF1_ResZone = TF1_FractalUpZone

// Fractal Down Zones
TF1_CalcFractalDownZone() =>
    TF1_FractalDownZone = 0.0
    TF1_FractalDownZone := TF1_Down and TF1_Close[3] >= TF1_Open[3] ? TF1_Open[3] : TF1_Down and TF1_Close[3] < TF1_Open[3] ? TF1_Close[3] : TF1_FractalDownZone[1]
    TF1_FractalDownZone

TF1_FractalDownZone = request.security(syminfo.tickerid, TF1, TF1_CalcFractalDownZone())
TF1_SupportZone = TF1_FractalDownZone

// Time Frame 1 = TF1 Resistance
if (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and TF1_FractalUp != TF1_FractalUp[1] and chartOnLowerTF1 and not chartEqualTF2
    TF_ResistanceLineA(TF1_input,TF1_FractalUp,TF1_ResLinesColor,TF1_UpperResLine_array,TF1_NumZones,TF1_ResZone, TF1_LowerResLine_array,TF1_text,TF1ResLabel_array,bar_index[TF1_Hi_Bi], bar_index[3], bar_index,bar_index[2], TF1_extRight)
else if (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and na(TF1_FractalUp != TF1_FractalUp[1]) and chartOnLowerTF1 and na(ta.barssince(TF1_FractalUp != TF1_FractalUp[1])) and not chartEqualTF2
    TF_ResistanceLineB(TF1_FractalUp,TF1_ResLinesColor,TF1_UpperResLine_array,TF1_NumZones,TF1_ResZone,TF1_LowerResLine_array,TF1_text,TF1ResLabel_array,bar_index[3],bar_index, TF1_extRight)

if (TF1_Menu == 'S/R Zones')
    linefill.new(array.get(TF1_UpperResLine_array, TF1_NumZones-1), array.get(TF1_LowerResLine_array, TF1_NumZones-1), TF1_ResZoneColor)

if ShowLabel == true and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and not chartEqualTF2 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF1_FractalUp, TF1_text+"(R)", TF1_ResLinesColor, TF1ResLabel_array)


// Time Frame 1 = TF1 Support
if (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and TF1_FractalDown != TF1_FractalDown[1] and chartOnLowerTF1 and not chartEqualTF2
    TF_SupportLineA(TF1_input,TF1_FractalDown,TF1_SupLinesColor,TF1_UpperSupportLine_array,TF1_NumZones,TF1_SupportZone, TF1_LowerSupportLine_array,TF1_text,TF1SupLabel_array,bar_index[TF1_Lo_Bi], bar_index[3], bar_index,bar_index[2], TF1_extRight)
else if (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and na(TF1_FractalDown != TF1_FractalDown[1]) and chartOnLowerTF1 and na(ta.barssince(TF1_FractalDown != TF1_FractalDown[1])) and not chartEqualTF2
    TF_SupportLineB(TF1_FractalDown,TF1_SupLinesColor,TF1_UpperSupportLine_array,TF1_NumZones,TF1_SupportZone,TF1_LowerSupportLine_array,TF1_text,TF1SupLabel_array,bar_index[3],bar_index, TF1_extRight)

if (TF1_Menu == 'S/R Zones')
    linefill.new(array.get(TF1_UpperSupportLine_array, TF1_NumZones-1), array.get(TF1_LowerSupportLine_array, TF1_NumZones-1), TF1_SupZoneColor)

if ShowLabel == true and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and not chartEqualTF2 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF1_FractalDown, TF1_text+"(S)", TF1_SupLinesColor, TF1SupLabel_array)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF1_UpperResLine_array, TF1_NumZones-1), extend.none)
    line.set_x2(array.get(TF1_UpperResLine_array, TF1_NumZones-1), bar_index)
    line.set_extend(array.get(TF1_LowerResLine_array, TF1_NumZones-1), extend.none)
    line.set_x2(array.get(TF1_LowerResLine_array, TF1_NumZones-1), bar_index)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF1_UpperSupportLine_array, TF1_NumZones-1), extend.none)
    line.set_x2(array.get(TF1_UpperSupportLine_array, TF1_NumZones-1), bar_index)
    line.set_extend(array.get(TF1_LowerSupportLine_array, TF1_NumZones-1), extend.none)
    line.set_x2(array.get(TF1_LowerSupportLine_array, TF1_NumZones-1), bar_index)

// S/R  = Time Frame 2 = TF2
TF2_Vol = f_tfSources(TF2, volume)
TF2_VolMA = ta.sma(TF2_Vol, TF2_VolMA1Input)
TF2_High = f_tfSources(TF2, high)
TF2_Low = f_tfSources(TF2, low)
TF2_Open = f_tfSources(TF2, open)
TF2_Close = f_tfSources(TF2, close)

TF2_Up = f_tfUp(TF2_High, TF2_Vol, TF2_VolMA)
TF2_Down = f_tfDown(TF2_Low, TF2_Vol, TF2_VolMA)

TF2_CalcFractalUp() =>
    TF2_FractalUp = 0.0
    TF2_FractalUp := TF2_Up ? TF2_High[3] : TF2_FractalUp[1]
    TF2_FractalUp

TF2_CalcFractalDown() =>
    TF2_FractalDown = 0.0
    TF2_FractalDown := TF2_Down ? TF2_Low[3] : TF2_FractalDown[1]
    TF2_FractalDown

TF2_FractalUp = request.security(syminfo.tickerid, TF2, TF2_CalcFractalUp())
TF2_FractalDown = request.security(syminfo.tickerid, TF2, TF2_CalcFractalDown())

// Zones - Current Time Frame = Time Frame 2 = TF2
// Fractal Up Zones
TF2_CalcFractalUpZone() =>
    TF2_FractalUpZone = 0.0
    TF2_FractalUpZone := TF2_Up and TF2_Close[3] >= TF2_Open[3] ? TF2_Close[3] : TF2_Up and TF2_Close[3] < TF2_Open[3] ? TF2_Open[3] : TF2_FractalUpZone[1]
    TF2_FractalUpZone

TF2_FractalUpZone = request.security(syminfo.tickerid, TF2, TF2_CalcFractalUpZone())
TF2_ResZone = TF2_FractalUpZone

// Fractal Down Zones
TF2_CalcFractalDownZone() =>
    TF2_FractalDownZone = 0.0
    TF2_FractalDownZone := TF2_Down and TF2_Close[3] >= TF2_Open[3] ? TF2_Open[3] : TF2_Down and TF2_Close[3] < TF2_Open[3] ? TF2_Close[3] : TF2_FractalDownZone[1]
    TF2_FractalDownZone

TF2_FractalDownZone = request.security(syminfo.tickerid, TF2, TF2_CalcFractalDownZone())
TF2_SupportZone = TF2_FractalDownZone

// Time Frame 2 = TF2 Resistance
if (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and TF2_FractalUp != TF2_FractalUp[1] and chartOnLowerTF2
    TF_ResistanceLineA(TF2_input,TF2_FractalUp,TF2_ResLinesColor,TF2_UpperResLine_array,TF2_NumZones,TF2_ResZone, TF2_LowerResLine_array,TF2_input,TF2ResLabel_array,bar_index[TF2_Hi_Bi], bar_index[3], bar_index,bar_index[2], TF2_extRight)
else if (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and na(TF2_FractalUp != TF2_FractalUp[1]) and chartOnLowerTF2 and na(ta.barssince(TF2_FractalUp != TF2_FractalUp[1]))
    TF_ResistanceLineB(TF2_FractalUp,TF2_ResLinesColor,TF2_UpperResLine_array,TF2_NumZones,TF2_ResZone,TF2_LowerResLine_array,TF2_input,TF2ResLabel_array,bar_index[3],bar_index, TF2_extRight)

if (TF2_Menu == 'S/R Zones')
    linefill.new(array.get(TF2_UpperResLine_array, TF2_NumZones-1), array.get(TF2_LowerResLine_array, TF2_NumZones-1), TF2_ResZoneColor)

if ShowLabel == true and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF2_FractalUp, TF2_input+"(R)", TF2_ResLinesColor, TF2ResLabel_array)


// Time Frame 2 = TF2 Support
if (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and TF2_FractalDown != TF2_FractalDown[1] and chartOnLowerTF2
    TF_SupportLineA(TF2_input,TF2_FractalDown,TF2_SupLinesColor,TF2_UpperSupportLine_array,TF2_NumZones,TF2_SupportZone, TF2_LowerSupportLine_array,TF2_input,TF2SupLabel_array,bar_index[TF2_Lo_Bi], bar_index[3], bar_index,bar_index[2], TF2_extRight)
else if (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and na(TF2_FractalDown != TF2_FractalDown[1]) and chartOnLowerTF2 and na(ta.barssince(TF2_FractalDown != TF2_FractalDown[1])) 
    TF_SupportLineB(TF2_FractalDown,TF2_SupLinesColor,TF2_UpperSupportLine_array,TF2_NumZones,TF2_SupportZone,TF2_LowerSupportLine_array,TF2_input,TF2SupLabel_array,bar_index[3],bar_index, TF2_extRight)

if (TF2_Menu == 'S/R Zones')
    linefill.new(array.get(TF2_UpperSupportLine_array, TF2_NumZones-1), array.get(TF2_LowerSupportLine_array, TF2_NumZones-1), TF2_SupZoneColor)

if ShowLabel == true and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and chartOnLowerTF2 and label_loc == 'Right'
    TFLabel(bar_index+label_offset, TF2_FractalDown, TF2_input+"(S)", TF2_SupLinesColor, TF2SupLabel_array)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF2_UpperResLine_array, TF2_NumZones-1), extend.none)
    line.set_x2(array.get(TF2_UpperResLine_array, TF2_NumZones-1), bar_index)
    line.set_extend(array.get(TF2_LowerResLine_array, TF2_NumZones-1), extend.none)
    line.set_x2(array.get(TF2_LowerResLine_array, TF2_NumZones-1), bar_index)

if ext_active == false and barstate.islast
    line.set_extend(array.get(TF2_UpperSupportLine_array, TF2_NumZones-1), extend.none)
    line.set_x2(array.get(TF2_UpperSupportLine_array, TF2_NumZones-1), bar_index)
    line.set_extend(array.get(TF2_LowerSupportLine_array, TF2_NumZones-1), extend.none)
    line.set_x2(array.get(TF2_LowerSupportLine_array, TF2_NumZones-1), bar_index)


// ---------- The following lines modify the labels when there is the same S/R zone found on 2 different time frames, to combine both into one label and take the color of the higher time frame.
// ---------- This prevents 2 labels from being displayed on top of each other. For left labels, extra lines are required to reset the labels back to their original form once the SR changes for the lower time frame.

if label_loc == 'Right'
    if TF2_FractalDown == TF1_FractalDown and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF2 and not chartEqualTF2
        label.set_textcolor(id=array.get(TF1SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF2SupLabel_array, 0), text=TF1_text + '/' + TF2_input + "(S)")

// Left Labels
if label_loc == 'Left'
   
    if TF2_FractalUp == TF1_FractalUp and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF2 and not chartEqualTF2
        label.set_textcolor(id=array.get(TF1ResLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF2ResLabel_array, 0), text=TF1_text + '/' + TF2_input + "(R)")
    if TF2_FractalUp[1] == TF1_FractalUp[1] and TF2_FractalUp != TF1_FractalUp and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R')
        label.set_text(id=array.get(TF2ResLabel_array, 0), text=TF2_input + "(R)")
    if TF2_FractalDown == TF1_FractalDown and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and chartOnLowerTF1 and chartOnLowerTF2 and not chartEqualTF2
        label.set_textcolor(id=array.get(TF1SupLabel_array, 0), textcolor=color.new(color.white, 100))
        label.set_text(id=array.get(TF2SupLabel_array, 0), text=TF1_text + '/' + TF2_input + "(S)")
    if TF2_FractalDown[1] == TF1_FractalDown[1] and TF2_FractalDown != TF1_FractalDown and (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R')
        label.set_text(id=array.get(TF2SupLabel_array, 0), text=TF2_input + "(S)")

// ---------------- Alert Logic
// TF1
PriceEntersTF1ResZone = ta.crossover(close, TF1_ResZone)
PriceTestResAsSupportTF1 = ta.crossunder(close, TF1_FractalUp)
PriceEntersTF1SupZone = ta.crossunder(close, TF1_SupportZone)
PriceTestSupportAsResTF1 = ta.crossover(close, TF1_FractalDown)
PriceBreakingTF1Resistance = ta.crossover(close, TF1_FractalUp)
PriceBreakingTF1Support = ta.crossunder(close, TF1_FractalDown)
NewResFoundTF1 = (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and TF1_FractalUp != TF1_FractalUp[1]
NewSupFoundTF1 = (TF1_Menu == 'S/R Zones' or TF1_Menu == 'S/R') and TF1_FractalDown != TF1_FractalDown[1]

// TF2
PriceEntersTF2ResZone = ta.crossover(close, TF2_ResZone)
PriceTestResAsSupportTF2 = ta.crossunder(close, TF2_FractalUp)
PriceEntersTF2SupZone = ta.crossunder(close, TF2_SupportZone)
PriceTestSupportAsResTF2 = ta.crossover(close, TF2_FractalDown)
PriceBreakingTF2Resistance = ta.crossover(close, TF2_FractalUp)
PriceBreakingTF2Support = ta.crossunder(close, TF2_FractalDown)
NewResFoundTF2 = (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and TF2_FractalUp != TF2_FractalUp[1]
NewSupFoundTF2 = (TF2_Menu == 'S/R Zones' or TF2_Menu == 'S/R') and TF2_FractalDown != TF2_FractalDown[1]


// Define entry conditions
// define resistance zones
// TF1 Reistance xones
lastLowerResLine = line.get_price(array.get(TF1_LowerResLine_array, TF1_NumZones-1), bar_index)
lastUpperResLine = line.get_price(array.get(TF1_UpperResLine_array, TF1_NumZones-1), bar_index)
inTF1ResZone = close >= lastLowerResLine and close <= lastUpperResLine

// TF2 resistance zones
lastLowerResLineTF2 = line.get_price(array.get(TF2_LowerResLine_array, TF2_NumZones-1), bar_index)
lastUpperResLineTF2 = line.get_price(array.get(TF2_UpperResLine_array, TF2_NumZones-1), bar_index)
inTF2ResZone = close >= lastLowerResLineTF2 and close <= lastUpperResLineTF2


// Define TF1 support zones
lastLowerSupLine = line.get_price(array.get(TF1_LowerSupportLine_array, TF1_NumZones-1), bar_index)
lastUpperSupLine = line.get_price(array.get(TF1_UpperSupportLine_array, TF1_NumZones-1), bar_index)
inTF1SupZone = close <= lastUpperSupLine and close >= lastLowerSupLine

// Define TF2 support zones
lastLowerSupLineTF2 = line.get_price(array.get(TF2_LowerSupportLine_array, TF2_NumZones-1), bar_index)
lastUpperSupLineTF2 = line.get_price(array.get(TF2_UpperSupportLine_array, TF2_NumZones-1), bar_index)
inTF2SupZone = close <= lastUpperSupLineTF2 and close >= lastLowerSupLineTF2

//and not inTF1SupZone and not inTF2SupZone
//and not inTF1ResZone and not inTF2ResZone


// END SnD
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}







// Date Ranges
show_table = input(true, title='Show table')
text_size_switch = input(true, title='Small text in the table')
from_month = input.int(defval=5, title='From Month', minval=1, maxval=12)
from_day = input.int(defval=1, title='From Day', minval=1, maxval=31)
from_year = input(defval=2021, title='From Year')
to_month = input.int(defval=12, title='To Month', minval=1, maxval=12)
to_day = input.int(defval=1, title='To Day', minval=1, maxval=31)
to_year = input(defval=2024, title='To Year')
start = timestamp(from_year, from_month, from_day, 00, 00)  // backtest start window
finish = timestamp(to_year, to_month, to_day, 23, 59)  // backtest finish window
window = time >= start and time <= finish ? true : false  // create function "within window of time"


// Triggers
long_trigger = input(title='Long trigger value', defval=1)
short_trigger = input(title='Short trigger value', defval=-1)
trigger = input(defval=close, title="Enter trigger")

var current_so = 0
var current_S_so = 0
var initial_order = 0.0
var initial_S_order = 0.0
var original_ttp_value = 0.0
var quantity = 0.0
var entry_price = 0.0
var firstBarTime = 0.0
var maxDiffDays = 0.0
var soCount = 0
var SO1 = 0
var SO2 = 0
var SO3 = 0
var SO4 = 0
var SO5 = 0
var SO6 = 0
var SO7 = 0
var noSO = 0
var initial_price = 0.0
var initial_S_price = 0.0
var price_drop = 0.0
var price_pump = 0.0
var max_drop = 0.0
var max_pump = 0.0
var pump_date = 0
var pump_month = 0
var drop_date = 0
var drop_month = 0
var longest_trade_day = 0
var longest_trade_month = 0
var take_profit_level = 0.0
var take_S_profit_level = 0.0
var tp_plot = 0.0
var tp_S_plot = 0.0
var threshold = 0.0
var S_threshold = 0.0
timeDiff = time - firstBarTime
maxDev = 0.0
maxSDev = 0.0
closedTrades = 0
var tradeCount = 0
var i = 0
var avg_price = 0.0
var total_funds_in_trade = 0.0
var total_qty_in_trade = 0.0
var capital = 100.0

// Turn that time difference into days
diffDays = timeDiff / 86400000

// Calculate our TP levels
take_profit_level := avg_price * (1 + take_profit)
take_S_profit_level := avg_price * (1 - take_S_profit)


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
//Long and short entry
///Strategy Inputs
groupTitleLongEntry = "Long Entry"
trigger_long_Input = input.bool(false, "Trigger Long", group = groupTitleLongEntry)
AIbuyInput = input.bool(true, "AI Buy", group = groupTitleLongEntry)
rmi_buyInput = input.bool(false, "RMI Buy", group = groupTitleLongEntry)
rmi_buy_filterInput = input.bool(false, "RMI Buy Filter", group = groupTitleLongEntry)
STlongTriggerInput = input.bool(false, "ST Long Trigger", group = groupTitleLongEntry)
STlongFilterInput = input.bool(true, "ST Long Filter", group = groupTitleLongEntry)
ST2longTriggerInput = input.bool(false, "ST2 Long Trigger", group = groupTitleLongEntry)
ST2longFilterInput = input.bool(true, "ST2 Long Filter", group = groupTitleLongEntry)
//JMA1LongTriggerInput = input.bool(false, "JMA1 Long Trigger", group = groupTitleLongEntry)
//JMA1LongFilterInput = input.bool(false, "JMA1 Long Filter", group = groupTitleLongEntry)
//JMA2LongTriggerInput = input.bool(false, "JMA2 Long Trigger", group = groupTitleLongEntry)
//JMA2LongFilterInput = input.bool(false, "JMA2 Long Filter", group = groupTitleLongEntry)
HTbuyInput = input.bool(false, "HT Buy", group = groupTitleLongEntry)
DomMCADRisisingBuyFilterInput = input.bool(true, "DomMCAD Rising Buy Filter", group = groupTitleLongEntry)
DomMCAD_OB_BuyFilterInput = input.bool(false, "DomMCAD OB Buy Filter", group = groupTitleLongEntry)
DomMCAD_OS_BuyFilterInput = input.bool(false, "DomMCAD OS Buy Filter", group = groupTitleLongEntry)

groupTitleShortEntry = "Short Entry"
trigger_short_Input = input.bool(false, "Trigger Short", group = groupTitleShortEntry)
AIsellInput = input.bool(false, "AI Sell", group = groupTitleShortEntry)
rmi_sellInput = input.bool(false, "RMI Sell", group = groupTitleShortEntry)
rmi_sell_filterInput = input.bool(false, "RMI Sell Filter", group = groupTitleShortEntry)
STshortTriggerInput = input.bool(false, "ST Short Trigger", group = groupTitleShortEntry)
STshortFilterInput = input.bool(false, "ST Short Filter", group = groupTitleShortEntry)
ST2shortTriggerInput = input.bool(false, "ST2 Short Trigger", group = groupTitleShortEntry)
ST2shortFilterInput = input.bool(false, "ST2 Short Filter", group = groupTitleShortEntry)
//JMA1ShortTriggerInput = input.bool(false, "JMA1 Short Trigger", group = groupTitleShortEntry)
//JMA1ShortFilterInput = input.bool(false, "JMA1 Short Filter", group = groupTitleShortEntry)
//JMA2ShortTriggerInput = input.bool(false, "JMA2 Short Trigger", group = groupTitleShortEntry)
//JMA2ShortFilterInput = input.bool(false, "JMA2 Short Filter", group = groupTitleShortEntry)
HTsellInput = input.bool(false, "HT Sell", group = groupTitleShortEntry)
DomMCADFallingSellFilterInput = input.bool(false, "DomMCAD Falling Sell Filter", group = groupTitleShortEntry)
DomMCAD_OS_SellFilterInput = input.bool(false, "DomMCAD OS Sell Filter", group = groupTitleShortEntry)
DomMCAD_OB_SellFilterInput = input.bool(false, "DomMCAD OB Sell Filter", group = groupTitleShortEntry)

groupTitleSOsExit = "SOs and Exit"
use_rmi_filter_for_subsequent_sos = input.bool(true, "Use RMI Filter for subsequent SOs", group = groupTitleSOsExit)
use_last_SO_as_SL = input.bool(false, "Use Last SO as Stop Loss", group = groupTitleSOsExit)

// First Position
//for i = 0 to max_safe_order - 1 by 1
for j = 0 to max_safe_order - 1 by 1
    maxDev := int((maxDev + price_deviation * 100 * math.pow(safe_order_step_scale, i)) * 100) / 100
    maxDev
//for i = 0 to max_S_safe_order - 1 by 1
for j = 0 to max_S_safe_order - 1 by 1
    maxSDev := int((maxSDev + price_S_deviation * 100 * math.pow(safe_S_order_step_scale, i)) * 100) / 100
    maxSDev

//strategy.close_all(math.abs(strategy.position_size) != 0 and current_so[1] == 0)
if math.abs(strategy.position_size) != 0 and current_so[1] == 0
    strategy.close_all()

var int longEntryBarIndex = na
var int shortEntryBarIndex = na

//plot(long_trigger ? 1 : 0, title="Long Trigger", color=color.green)

if long and strategy.position_size == 0 and source_function(source_type) > 0 and window and not(hour(time) == 0 and minute(time) < 59) and (rmi_buyInput ? rmi_buy : true) and (STlongTriggerInput ? STlongTrigger : true) and (STlongFilterInput ? STlongFilter : true) and (ST2longTriggerInput ? ST2longTrigger : true) and (ST2longFilterInput ? ST2longFilter : true) and (trigger_long_Input ? trigger == long_trigger : true) and (HTbuyInput ? buySignal : true) and (DomMCADRisisingBuyFilterInput ? DomMCADRisingBuyFilter : true) and (DomMCAD_OB_BuyFilterInput ? DomMCAD_OB_BuyFilter : true) and (DomMCAD_OS_BuyFilterInput ? DomMCAD_OS_BuyFilter : true) and (rmi_buy_filterInput ? rmi_buy_filter : true) and (AIbuyInput ? AIbuy : true) and not inTF1ResZone and not inTF2ResZone//and (JMA1LongTriggerInput ? JMA1LongTrigger : true) and (JMA1LongFilterInput ? JMA1LongFilter : true) and (JMA2LongTriggerInput ? JMA2LongTrigger : true) and (JMA2LongFilterInput ? JMA2LongFilter : true)
    _string_long = ID + ',long,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_order/10000) + ',comment="' + version + '-' + tf + '"'
    strategy.entry('Long @' + str.tostring(source_function(source_type)), strategy.long, qty=base_order, alert_message=_string_long)
    initial_order := source_function(source_type)
    current_so := 1
    initial_price := close
    price_drop := close
    original_ttp_value := 0
    firstBarTime := time
    tradeCount += 1
    avg_price := close
    total_funds_in_trade := avg_price * base_order
    total_qty_in_trade := base_order
    total_qty_in_trade
    longEntryBarIndex := bar_index


else if short and strategy.position_size == 0 and source_function(source_type) > 0 and window and not(hour(time) == 0 and minute(time) < 59) and (rmi_sellInput ? rmi_sell : true) and (STshortTriggerInput ? STshortTrigger : true) and (STshortFilterInput ? STshortFilter : true) and (ST2shortTriggerInput ? ST2shortTrigger : true) and (ST2shortFilterInput ? ST2shortFilter : true) and (trigger_short_Input ? trigger == short_trigger : true) and (HTsellInput ? sellSignal : true)  and (DomMCADFallingSellFilterInput ? DomMCADFallingSellFilter : true) and (DomMCAD_OS_SellFilterInput ? DomMCAD_OS_SellFilter : true) and (DomMCAD_OB_SellFilterInput ? DomMCAD_OB_SellFilter : true) and (rmi_sell_filterInput ? rmi_sell_filter : true) and (AIsellInput ? AIsell : true) and not inTF1SupZone and not inTF2SupZone //and (JMA1ShortTriggerInput ? JMA1ShortTrigger : true) and (JMA1ShortFilterInput ? JMA1ShortFilter : true) and (JMA2ShortTriggerInput ? JMA2ShortTrigger : true) and (JMA2ShortFilterInput ? JMA2ShortFilter : true)
    _string_short = ID + ',short,' + syminfo.ticker + '.PRO' + ',risk=' + str.tostring(base_S_order/10000) + ',comment="' + version + '-' + tf + '"'
    strategy.entry('Short @' + str.tostring(source_function(source_type)), strategy.short, qty=base_S_order, alert_message=_string_short)
    initial_S_order := source_function(source_type)
    current_so := 1
    firstBarTime := time
    tradeCount += 1
    initial_S_price := close
    price_pump := close
    avg_price := close
    total_funds_in_trade := avg_price * base_S_order
    total_qty_in_trade := base_S_order
    total_qty_in_trade
    shortEntryBarIndex := bar_index


//makes the red and green line plot pretty at the position opening
if strategy.position_size == 0
    threshold := low[1]
    S_threshold := high[1]
    S_threshold


//Safety order levels
//Long Safety order levels
if strategy.position_size > 0 and i == 0
    if safe_order_step_scale == 1.0
        threshold := initial_order - initial_order * price_deviation * safe_order_step_scale * current_so
        threshold
    else
        threshold := initial_order - initial_order * (price_deviation * (math.pow(safe_order_step_scale, current_so) - 1) / (safe_order_step_scale - 1))
        threshold

//Short Safety order levels
else if strategy.position_size < 0 and i == 0
    if safe_S_order_step_scale == 1.0
        S_threshold := initial_S_order * (1 + price_S_deviation * current_so)
        S_threshold
    else
        S_threshold := initial_S_order * (1 + price_S_deviation * (math.pow(safe_S_order_step_scale, current_so) - 1) / (safe_S_order_step_scale - 1))
        S_threshold


// Long SO (Average Down)
// Average Down
if current_so > 0 and i == 0 and strategy.position_size > 0 and low <= threshold and current_so <= max_safe_order and not(hour(time) == 0 and minute(time) < 59) and (not use_rmi_filter_for_subsequent_sos or rmi_buy_filter)
    if use_last_SO_as_SL and current_so == max_safe_order
        _string_close_long = ID + ',closelong,' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + tf + '"'
        strategy.close_all(comment='Stop Loss @' + str.tostring(source_function(source_type)), alert_message=_string_close_long)
        soCount := current_so
        current_so := 0
        original_ttp_value := 0
        price_drop := na
        initial_price := na
        diffDays := time - firstBarTime
        if diffDays > maxDiffDays
            maxDiffDays := diffDays
            longest_trade_day := dayofmonth
            longest_trade_month := month
            longest_trade_month
        i := 1
        initial_order := 0.0
        avg_price := na
    else
        _string_long_so = str.replace(ID, " ", "") + ',long,' + str.replace(syminfo.ticker, " ", "") + '.PRO' + ',risk=' + str.tostring((safe_order * math.pow(safe_order_volume_scale, current_so - 1)) / 10000) + ',comment="' + version + '-' + tf + '"'
        strategy.entry('SO ' + str.tostring(current_so) + '@' + str.tostring(source_function(source_type)), strategy.long, qty=safe_order * math.pow(safe_order_volume_scale, current_so - 1), alert_message=_string_long_so)
        total_funds_in_trade += threshold * safe_order * math.pow(safe_order_volume_scale, current_so - 1)
        total_qty_in_trade += safe_order * math.pow(safe_order_volume_scale, current_so - 1)
        avg_price := total_funds_in_trade / total_qty_in_trade
        current_so += 1
        tradeCount += 1
        tradeCount


// Short SO (Average Up)
if current_so > 0 and i == 0 and strategy.position_size < 0 and high >= S_threshold and current_so <= max_S_safe_order and not(hour(time) == 0 and minute(time) < 59) and (not use_rmi_filter_for_subsequent_sos or rmi_sell_filter)
    if use_last_SO_as_SL and current_so == max_S_safe_order
        _string_close_short = ID + ',closeshort,' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + tf + '"'
        strategy.close_all(comment='Stop Loss Short @' + str.tostring(source_function(source_type)), alert_message=_string_close_short)
        soCount := current_so
        current_so := 0
        price_pump := na
        initial_S_price := na
        diffDays := time - firstBarTime
        if diffDays > maxDiffDays
            maxDiffDays := diffDays
            maxDiffDays
        initial_S_order := 0.0
        avg_price := na
    else
        _string_short_so = str.replace(ID, " ", "") + ',short,' + str.replace(syminfo.ticker, " ", "") + '.PRO' + ',risk=' + str.tostring((safe_S_order * math.pow(safe_S_order_volume_scale, current_so - 1)) / 10000) + ',comment="' + version + '-' + tf + '"'
        strategy.entry('SSO ' + str.tostring(current_so) + '@' + str.tostring(source_function(source_type)), strategy.short, qty=safe_S_order * math.pow(safe_S_order_volume_scale, current_so - 1), alert_message=_string_short_so)
        total_funds_in_trade += S_threshold * safe_S_order * math.pow(safe_S_order_volume_scale, current_so - 1)
        total_qty_in_trade += safe_S_order * math.pow(safe_S_order_volume_scale, current_so - 1)
        avg_price := total_funds_in_trade / total_qty_in_trade
        current_so += 1
        tradeCount += 1
        tradeCount



// Take Profit! 
if i == 1
    strategy.close_all()
    i := 0
    i

if take_profit_level <= high and strategy.position_size > 0 and not(hour(time) == 0 and minute(time) < 59)
    _string_close_long = ID + ',closelong,' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + tf + '"'
    strategy.close_all(comment='Close @' + str.tostring(source_function(source_type)), alert_message=_string_close_long)
    soCount := current_so
    current_so := 0
    original_ttp_value := 0
    price_drop := na
    initial_price := na
    diffDays := time - firstBarTime
    if diffDays > maxDiffDays
        maxDiffDays := diffDays
        longest_trade_day := dayofmonth
        longest_trade_month := month
        longest_trade_month
    i := 1
    initial_order := 0.0
    avg_price := na
    capital *= (1 + total_qty_in_trade * take_profit / 100)
    capital


// Take Short Profit! 
if take_S_profit_level >= low and strategy.position_size < 0 and not(hour(time) == 0 and minute(time) < 59)
    _string_close_short = ID + ',closeshort,' + syminfo.ticker + '.PRO' + ',comment="' + version + '-' + tf + '"'
    strategy.close_all(comment='Close Short @' + str.tostring(source_function(source_type)), alert_message=_string_close_short)
    soCount := current_so
    current_so := 0
    price_pump := na
    initial_S_price := na
    diffDays := time - firstBarTime
    if diffDays > maxDiffDays
        maxDiffDays := diffDays
        maxDiffDays
    initial_S_order := 0.0
    avg_price := na
    capital *= (1 + total_qty_in_trade * take_S_profit / 100)
    capital



//Table building and calculations
if strategy.position_size == 0
    if soCount == 1
        noSO += 1
        noSO
    else if soCount == 2
        SO1 += 1
        SO1
    else if soCount == 3
        SO2 += 1
        SO2
    else if soCount == 4
        SO3 += 1
        SO3
    else if soCount == 5
        SO4 += 1
        SO4
    else if soCount == 6
        SO5 += 1
        SO5
    else if soCount == 7
        SO6 += 1
        SO6
    else if soCount == 8
        SO7 += 1
        SO7
    soCount := 0
    soCount
closedTrades := noSO + SO1 * 2 + SO2 * 3 + SO3 * 4 + SO4 * 5 + SO5 * 6 + SO6 * 7 + SO7 * 8

if low < price_drop and window and strategy.position_size > 0
    price_drop := low
    if max_drop < int((1 - price_drop / initial_price) * 10000) / 100
        max_drop := int((1 - price_drop / initial_price) * 10000) / 100
        drop_date := dayofmonth(time)
        drop_month := month(time)
        drop_month
bgcolor(max_drop[1] < max_drop ? color.new(color.rgb(11, 90, 100), 50) : na)

if high > price_pump and window and strategy.position_size < 0
    price_pump := high
    if max_pump < int((price_pump / initial_S_price - 1) * 10000) / 100
        max_pump := int((price_pump / initial_S_price - 1) * 10000) / 100
        pump_date := dayofmonth(time)
        pump_month := month(time)
        pump_month
bgcolor(max_pump[1] < max_pump ? color.new(color.rgb(155, 39, 176), 70) : na)

if take_profit_level > 0 and strategy.position_size > 0
    tp_plot := take_profit_level
    tp_plot
else
    tp_plot := close
    tp_plot

if take_S_profit_level > 0 and strategy.position_size < 0
    tp_S_plot := take_S_profit_level
    tp_S_plot
else
    tp_S_plot := close
    tp_S_plot

//Plotting the levels
p1 = plot(tp_plot, color=strategy.position_size <= 0 ? na : TTBColors.colorUp()) // Up color
p2 = plot(avg_price, color=strategy.position_size == 0 ? na : TTBColors.colorNeutral()) // Neutral color
p3 = plot(threshold, color=strategy.position_size <= 0 ? na : TTBColors.colorDown()) // Down color
p4 = plot(tp_S_plot, color=strategy.position_size >= 0 ? na : TTBColors.colorUpPlus()) // UpPlus color
p5 = plot(S_threshold, color=strategy.position_size >= 0 ? na : TTBColors.colorDownPlus()) // DownPlus color
fill(p1, p2, color=strategy.position_size > 0 ? color.new(TTBColors.colorUp(), 90) : na) // Semi-transparent Up color
fill(p2, p3, strategy.position_size > 0 ? color.new(TTBColors.colorNeutral(), 90) : na) // Semi-transparent Neutral color
fill(p4, p2, color=strategy.position_size < 0 ? color.new(TTBColors.colorUpPlus(), 90) : na) // Semi-transparent UpPlus color
fill(p5, p2, color=strategy.position_size < 0 ? color.new(TTBColors.colorDownPlus(), 90) : na) // Semi-transparent DownPlus color
profit_color = strategy.openprofit < 0 ? TTBColors.colorDown() : TTBColors.colorUp() // Down color for loss, Up color for profit

text_size = text_size_switch ? size.small : size.normal

// plot(strategy.opentrades)
// plot(current_so, color = color.yellow)
// plot(abs(strategy.position_size), color = color.red)
// plot(quantity, color=color.purple)

//Table formatting
if show_table
    var Table = table.new(position.bottom_right, columns=2, rows=20, border_width=1, bgcolor=color.new(#363a45, 0), border_color=color.gray)
    table.cell(table_id=Table, column=0, row=0, text_color=color.gray, text_size=text_size, text='Net Profit')
    table.cell(table_id=Table, column=1, row=0, text=str.tostring(int((capital - 100) * 100) / 100) + '%', text_size=text_size, text_color=TTBColors.colorUplight())
    table.cell(table_id=Table, column=0, row=1, text_color=color.gray, text_size=text_size, text='Max Deviation ')
    table.cell(table_id=Table, column=1, row=1, text=str.tostring(maxDev) + '%', text_size=text_size, text_color=TTBColors.colorDownlight())
    table.cell(table_id=Table, column=0, row=2, text_color=color.gray, text_size=text_size, text='Max Short Dev ')
    table.cell(table_id=Table, column=1, row=2, text=str.tostring(maxSDev) + '%', text_size=text_size, text_color=TTBColors.colorDownlight())
    table.cell(table_id=Table, column=0, row=3, text='No SO ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=3, text=str.tostring(noSO), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=4, text='SO 1 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=4, text=str.tostring(SO1), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=5, text='SO 2 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=5, text=str.tostring(SO2), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=6, text='SO 3 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=6, text=str.tostring(SO3), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=7, text='SO 4 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=7, text=str.tostring(SO4), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=8, text='SO 5 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=8, text=str.tostring(SO5), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=9, text='SO 6 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=9, text=str.tostring(SO6), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=10, text='SO 7 ', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=10, text=str.tostring(SO7), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=11, text='Closed/Open trades', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=11, text=str.tostring(strategy.closedtrades) + '/' + str.tostring(strategy.opentrades), text_size=text_size, text_color=TTBColors.colorNeutral())
    table.cell(table_id=Table, column=0, row=12, text='Current Deal Time', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=12, text=strategy.position_size != 0 ? str.tostring(int((time - firstBarTime) / 8640000) / 10) + ' days' : '0', text_size=text_size, text_color=color.green)
    table.cell(table_id=Table, column=0, row=13, text='Unrealized position', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=13, text=str.tostring(int(strategy.openprofit / (strategy.initial_capital + strategy.netprofit) * 10000) / 100) + ' %', text_size=text_size, text_color=profit_color)
    table.cell(table_id=Table, column=0, row=14, text='Longest deal:', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=14, text=str.tostring(int(maxDiffDays / 8640000) / 10) + ' days, ' + str.tostring(longest_trade_day) + '/' + str.tostring(longest_trade_month), text_size=text_size, text_color=TTBColors.colorDownlight())
    table.cell(table_id=Table, column=0, row=15, text='Max price drop:', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=15, text=str.tostring(max_drop) + ' %, ' + str.tostring(drop_date) + '/' + str.tostring(drop_month), text_size=text_size, text_color=TTBColors.colorDownlight())
    table.cell(table_id=Table, column=0, row=16, text='Max price pump:', text_size=text_size, text_color=color.gray)
    table.cell(table_id=Table, column=1, row=16, text=str.tostring(max_pump) + ' %, ' + str.tostring(pump_date) + '/' + str.tostring(pump_month), text_size=text_size, text_color=TTBColors.colorDownlight())
